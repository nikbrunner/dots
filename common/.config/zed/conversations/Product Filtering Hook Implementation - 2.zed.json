{
  "id": "c9c4f02a-544c-4c91-a9a0-5f3010c49a8b",
  "zed": "context",
  "version": "0.4.0",
  "text": "\n\n\n```ts bc-desktop-client/src/client/commons/libs/queries/use-product-filter.ts\nimport React, { useCallback } from \"react\";\nimport { QueryClient, QueryKey, useQueryClient } from \"@tanstack/react-query\";\nimport { useLocation } from \"react-router\";\n\nimport { compactPromiseErrors as promiseSequence } from \"../../../../commons/libs/promise\";\nimport { getSpecConfig } from \"../../../../commons/specs\";\nimport {\n  ActiveFilters,\n  FilterKey,\n  getTypedFilterConfigEntries,\n  getTypedFilterConfigKeys,\n  ProductFilterValues\n} from \"../../../../commons/specs/filters\";\nimport { ProductSpecKey, ProductType } from \"../../../../commons/specs/product\";\nimport { Currency } from \"../../../../commons/types/currency\";\nimport { GlobalLocationState } from \"../../../../commons/types/location\";\nimport {\n  AssortmentPriceSettings,\n  AutomaticAssortmentFilter,\n  ProductFinderAssortmentFilterSettings\n} from \"../../../../commons/types/settings\";\nimport * as sessionActions from \"../../actions/session\";\nimport { getPossibleValues as getPossibleValuesLib } from \"../content-service\";\nimport {\n  clearActiveFilter,\n  clearActiveFilters,\n  clearAllActiveFilters,\n  getEvaluatedDefaultActiveFilters,\n  hasActiveFilters,\n  isFilterItemActive as isFilterItemActiveLib\n} from \"../filters\";\nimport useDispatch from \"../hooks/use-dispatch\";\nimport useGetFilterKeysWithInsufficientFilterValues from \"../hooks/use-get-filter-keys-with-insufficient-filter-values\";\nimport useQuery, { UseQueryOptions } from \"../hooks/use-query\";\nimport useSelectedBrands from \"../hooks/use-selected-brands\";\nimport useSelector from \"../hooks/use-selector\";\nimport { selectInitializedSettings } from \"../selectors\";\n\ninterface Arguments<Type extends ProductType> {\n  options?: Omit<UseQueryOptions<ProductFilterValues<Type>>, \"queryKey\" | \"queryFn\">;\n  productType: Type;\n  assortmentFilterSettings: ProductFinderAssortmentFilterSettings;\n  assortmentPriceSettings: AssortmentPriceSettings;\n  automaticAssortmentFilter?: AutomaticAssortmentFilter;\n  brandKey?: string;\n  useSessionState?: boolean;\n  shouldSetDefaultActiveFilters?: boolean;\n}\n\nconst useProductFilter = <Type extends ProductType>({\n  productType,\n  assortmentFilterSettings,\n  assortmentPriceSettings,\n  automaticAssortmentFilter,\n  brandKey = \"\",\n  useSessionState = true,\n  shouldSetDefaultActiveFilters = false,\n  options = {}\n}: Arguments<Type>) => {\n  const queryClient = useQueryClient();\n  const specConfig = getSpecConfig(productType);\n  const filterKeys = getTypedFilterConfigKeys(specConfig);\n  const filterConfigEntries = getTypedFilterConfigEntries(specConfig.filterConfig);\n\n  const [activeFilters, setActiveFilters] = useSessionOrLocalState<Type>(useSessionState);\n  const [wereDefaultActiveFiltersEvaluated, setWereDefaultActiveFiltersEvaluated] = React.useState<boolean>(false);\n  const currency = useSelector(state => selectInitializedSettings(state).currency);\n  const assortmentSettings = useSelector(state => selectInitializedSettings(state).assortment);\n  const selectedBrands = useSelectedBrands({ activeFilters, brandKey });\n\n  const query = useQuery({\n    ...options,\n    queryKey: queryKey({ brandKey, currency, assortmentPriceSettings, filterKeys }),\n    queryFn: () => getPossibleValues({ brandKey, currency, filterKeys, assortmentPriceSettings }),\n    onSuccess: data => {\n      options?.onSuccess?.(data);\n      if (!wereDefaultActiveFiltersEvaluated) {\n        if (activeFilters !== null && !shouldSetDefaultActiveFilters) {\n          setWereDefaultActiveFiltersEvaluated(true);\n        } else {\n          const defaultActiveFilters = getEvaluatedDefaultActiveFilters<Type>({\n            assortmentType: assortmentSettings.type,\n            assortmentFilterSettings,\n            automaticAssortmentFilter,\n            activeFilters,\n            productFilterValues: data\n          });\n\n          setActiveFilters(defaultActiveFilters);\n          // setDefaultActiveFilters();\n\n          setWereDefaultActiveFiltersEvaluated(true);\n        }\n      }\n    }\n  });\n\n  const filterKeysWithInsufficientFilterValues = useGetFilterKeysWithInsufficientFilterValues({\n    selectedBrands,\n    activeFilters\n  });\n\n  const clearAllFilters = useCallback(() => {\n    setActiveFilters(clearAllActiveFilters(activeFilters, assortmentSettings.productFinderFilterSettings));\n  }, [activeFilters, setActiveFilters, assortmentSettings.productFinderFilterSettings]);\n\n  const clearFilters = useCallback(\n    (filterKeys: FilterKey<Type>[]) => {\n      setActiveFilters(clearActiveFilters(activeFilters, filterKeys));\n    },\n    [activeFilters, setActiveFilters]\n  );\n\n  const clearFilter = useCallback(\n    (filterKey: FilterKey<Type>) => {\n      setActiveFilters(clearActiveFilter(activeFilters, filterKey));\n    },\n    [activeFilters, setActiveFilters]\n  );\n\n  const isFilterItemActive = useCallback(\n    (key: FilterKey<Type>) => {\n      const filterConfigItem = filterConfigEntries.find(entry => entry[0] === key)?.[1];\n      return filterConfigItem ? isFilterItemActiveLib(key, filterConfigItem, activeFilters) : 0;\n    },\n    [activeFilters, filterConfigEntries]\n  );\n\n  const setDefaultActiveFilters = useCallback(\n    (overrides: ActiveFilters<Type> = {}) => {\n      if (query.data) {\n        const defaultActiveFilters = getEvaluatedDefaultActiveFilters<Type>({\n          assortmentType: assortmentSettings.type,\n          assortmentFilterSettings,\n          automaticAssortmentFilter,\n          activeFilters,\n          productFilterValues: query.data\n        });\n\n        // TypeScript handles object merging differently for spread ({...a, ...b}) and Object.assign.\n        // Spread seems to triggers strict excess property checks,\n        // while Object.assign merges the incoming object types. (See type declaration)\n        return setActiveFilters(Object.assign({}, defaultActiveFilters, overrides));\n      }\n    },\n    [activeFilters, setActiveFilters]\n  );\n\n  const getProductFiltersForBrand = async (brandKey: string) => {\n    return await queryClient.ensureQueryData({\n      queryKey: queryKey({ brandKey, currency, assortmentPriceSettings, filterKeys }),\n      queryFn: () => getPossibleValues({ brandKey, currency, assortmentPriceSettings, filterKeys })\n    });\n  };\n\n  const setDefaultActiveFiltersForBrand = async (brandKey: string, overrides: ActiveFilters<Type> = {}) => {\n    const productFilterValues = await getProductFiltersForBrand(brandKey);\n\n    if (productFilterValues) {\n      const defaultActiveFilters = getEvaluatedDefaultActiveFilters<Type>({\n        assortmentType: assortmentSettings.type,\n        assortmentFilterSettings,\n        automaticAssortmentFilter,\n        activeFilters,\n        productFilterValues\n      });\n\n      // TypeScript handles object merging differently for spread ({...a, ...b}) and Object.assign.\n      // Spread seems to triggers strict excess property checks,\n      // while Object.assign merges the incoming object types. (See type declaration)\n      return setActiveFilters(Object.assign({}, defaultActiveFilters, overrides));\n    }\n  };\n\n  return {\n    query,\n    activeFilters,\n    selectedBrands,\n    filterKeysWithInsufficientFilterValues,\n    wereDefaultActiveFiltersEvaluated,\n    hasActiveFilters: hasActiveFilters(activeFilters),\n    setActiveFilters,\n    clearAllFilters,\n    clearFilters,\n    clearFilter,\n    isFilterItemActive,\n    setDefaultActiveFilters,\n    getProductFiltersForBrand,\n    setDefaultActiveFiltersForBrand\n  };\n};\n\nconst useSessionOrLocalState = <Type extends ProductType>(useSessionState: boolean) => {\n  const location = useLocation<GlobalLocationState<Type>>();\n  // Disable syncing the active filters with the session state\n  const localState = React.useState<ActiveFilters<Type>>(location.state?.activeFilters ?? null);\n\n  const dispatch = useDispatch();\n  const activeFilters = useSelector(state => state.session.activeFilters as ActiveFilters<Type>);\n  const setActiveFilters = React.useCallback(\n    (activeFilters: ActiveFilters<Type>) => dispatch(sessionActions.setActiveFilters(activeFilters)),\n    [dispatch]\n  );\n\n  if (!useSessionState) {\n    return localState;\n  }\n\n  return [activeFilters, setActiveFilters] as const;\n};\n\nconst queryKey = <Type extends ProductType>({\n  currency,\n  assortmentPriceSettings,\n  filterKeys,\n  brandKey\n}: {\n  currency: Currency;\n  assortmentPriceSettings: AssortmentPriceSettings;\n  filterKeys: FilterKey<Type>[];\n  brandKey?: string;\n}): QueryKey => [\"product-filter\", ...(!!brandKey ? [brandKey] : []), filterKeys, currency, assortmentPriceSettings];\n\nconst getPossibleValues = <Type extends ProductType>({\n  currency,\n  assortmentPriceSettings,\n  filterKeys,\n  brandKey\n}: {\n  currency: Currency;\n  assortmentPriceSettings: AssortmentPriceSettings;\n  filterKeys: FilterKey<Type>[];\n  brandKey?: string;\n}): Promise<ProductFilterValues<Type>> => {\n  const filters = brandKey ? [{ key: ProductSpecKey.BrandKey, value: brandKey }] : [];\n  return getPossibleValuesLib(filterKeys, currency, assortmentPriceSettings, filters);\n};\n\nexport const prefetchFilterValues = async <Type extends ProductType>({\n  queryClient,\n  currency,\n  assortmentPriceSettings,\n  filterKeys,\n  brandKey\n}: {\n  queryClient: QueryClient;\n  currency: Currency;\n  assortmentPriceSettings: AssortmentPriceSettings;\n  filterKeys: FilterKey<Type>[];\n  brandKey?: string;\n}) => {\n  await queryClient.prefetchQuery({\n    queryKey: queryKey({ brandKey, currency, assortmentPriceSettings, filterKeys }),\n    queryFn: () => getPossibleValues({ brandKey, currency, assortmentPriceSettings, filterKeys })\n  });\n};\n\nexport const prefetchAllFilterValues = async <Type extends ProductType>({\n  queryClient,\n  currency,\n  assortmentPriceSettings,\n  filterKeys,\n  activeBrandKeys\n}: {\n  queryClient: QueryClient;\n  currency: Currency;\n  assortmentPriceSettings: AssortmentPriceSettings;\n  filterKeys: FilterKey<Type>[];\n  activeBrandKeys: string[];\n}) => {\n  const sharedArgs = { queryClient, currency, assortmentPriceSettings, filterKeys };\n\n  const generalFilterValues = prefetchFilterValues({\n    ...sharedArgs\n  });\n\n  const brandFilterValues = activeBrandKeys.map(brandKey =>\n    prefetchFilterValues({\n      ...sharedArgs,\n      brandKey\n    })\n  );\n\n  await promiseSequence([generalFilterValues, ...brandFilterValues]);\n};\nexport default useProductFilter;\n```\n\n\nWhat is this?\nThis is a custom React hook called `useProductFilter` that's used for managing product filtering in an e-commerce application. The hook provides functionality for:\n\n1. Loading and managing filter values for products\n2. Managing active filter states (either in local state or session state)\n3. Handling default filters\n4. Clearing filters (all filters, specific filters, or individual filters)\n5. Checking if filter items are active\n6. Working with brand-specific filters\n\nThe code uses React Query (TanStack Query) for data fetching and caching of filter values, and can synchronize filter states with either local component state or global session state. It also handles complex filtering logic including default filter evaluation based on assortment settings.\n\nThe exported prefetch functions (`prefetchFilterValues` and `prefetchAllFilterValues`) allow preloading filter data before it's needed, which improves the user experience by reducing loading times when users navigate to filtered product views.\n\nThis appears to be part of a larger e-commerce or product catalog system, specifically handling the filtering functionality that lets users refine product selections.\n",
  "messages": [
    {
      "id": { "replica_id": 0, "value": 0 },
      "start": 0,
      "metadata": {
        "role": "user",
        "status": "Done",
        "timestamp": { "replica_id": 0, "value": 55 }
      }
    },
    {
      "id": { "replica_id": 0, "value": 20 },
      "start": 10314,
      "metadata": {
        "role": "assistant",
        "status": "Done",
        "timestamp": { "replica_id": 0, "value": 56 }
      }
    },
    {
      "id": { "replica_id": 0, "value": 21 },
      "start": 11489,
      "metadata": {
        "role": "user",
        "status": "Done",
        "timestamp": { "replica_id": 0, "value": 57 }
      }
    }
  ],
  "summary": "Product Filtering Hook Implementation",
  "slash_command_output_sections": [
    {
      "range": { "start": 0, "end": 1 },
      "icon": "Library",
      "label": "Default",
      "metadata": null
    },
    {
      "range": { "start": 3, "end": 10298 },
      "icon": "File",
      "label": "bc-desktop-client/src/client/commons/libs/queries/use-product-filter.ts",
      "metadata": {
        "path": "bc-desktop-client/src/client/commons/libs/queries/use-product-filter.ts"
      }
    }
  ]
}
