{
  "id": "726c2047-7b96-4220-9a0d-fe9a86822ac8",
  "zed": "context",
  "version": "0.4.0",
  "text": "\n\n\n```tsx bc-desktop-client/src/client/commons/container/ProductDetails/ProductDetailsPartial.tsx\nimport React, { useMemo } from \"react\";\nimport { goBack, replace } from \"connected-react-router\";\nimport { useTranslation } from \"react-i18next\";\nimport { ConnectedProps } from \"react-redux\";\nimport { Route, useLocation, useParams } from \"react-router-dom\";\n\nimport { getProduct } from \"../../../../commons/libs/content-service\";\nimport { byDefined } from \"../../../../commons/libs/filter-guards\";\nimport { getSpecFormatter } from \"../../../../commons/libs/formatters\";\nimport { getBrandLogoUrl } from \"../../../../commons/libs/resource-paths\";\nimport { getFirstVariantId, getSingleSpecValue, getStandaloneProductVariant } from \"../../../../commons/libs/specs\";\nimport { getSpecConfig } from \"../../../../commons/specs\";\nimport { Product, ProductId, ProductKey, ProductSpecKey } from \"../../../../commons/specs/product\";\nimport { Brand } from \"../../../../commons/types/brand\";\nimport { GlobalLocationState } from \"../../../../commons/types/location\";\nimport * as icons from \"../../../../resources/icons\";\nimport { IconSmallCross } from \"../../../../resources/icons\";\nimport { useTrackingContext } from \"../../../commons/container/utils/tracking-context\";\nimport { buildProductPath } from \"../../../commons/libs/path\";\nimport { getNeighbouringProducts } from \"../../../commons/libs/products\";\nimport actions from \"../../actions\";\nimport BrandImage from \"../../components/BrandImage/BrandImage\";\nimport Button from \"../../components/Button/Button\";\nimport CenteredPageLayout from \"../../components/CenteredPageLayout/CenteredPageLayout\";\nimport FlexLayout from \"../../components/FlexLayout/FlexLayout\";\nimport Icon from \"../../components/Icon/Icon\";\nimport LoadingIndicator from \"../../components/LoadingIndicator/LoadingIndicator\";\nimport MainContentLayout from \"../../components/MainContentLayout/MainContentLayout\";\nimport ProductDetailsContentLayout from \"../../components/ProductDetailsContentLayout/ProductDetailsContentLayout\";\nimport SwipeableContent, { TransitionDirection } from \"../../components/SwipeableContent/SwipeableContent\";\nimport TabBarPageLayout from \"../../components/TabBarPageLayout/TabBarPageLayout\";\nimport useFetchData from \"../../libs/hooks/use-fetch-data\";\nimport useVeloconnectEndpoint, { UseVeloconnectEndpointReturn } from \"../../libs/hooks/use-veloconnect-endpoint\";\nimport { useActiveBrands } from \"../../libs/queries/use-active-brands\";\nimport { selectAssortmentPriceSettings, selectInitializedSettings } from \"../../libs/selectors\";\nimport { State } from \"../../reducers\";\nimport { ROUTES } from \"../../routes\";\nimport ProductTitlePartial from \"../partials/ProductTitlePartial\";\nimport { connect } from \"../utils/loop\";\nimport { VeloconnectEndpointProvider } from \"../utils/veloconnect-endpoint-context\";\n\nimport ProductDetailsImagePartial from \"./ProductDetailsImagePartial\";\n\nconst mapStateToProps = (state: State) => ({\n  settings: selectInitializedSettings(state),\n  assortmentPriceSettings: selectAssortmentPriceSettings(state)\n});\n\nconst mapDispatchToProps = {\n  onReplace: replace,\n  onGoBack: goBack,\n  onError: actions.error.set\n};\n\nconst connector = connect(mapStateToProps, mapDispatchToProps);\n\nexport interface ProductDetailsPartialRenderProps {\n  productId: ProductId;\n  variantId: ProductId | undefined;\n  product: Product | undefined;\n  productContent?: {\n    key: string;\n    link: string;\n  };\n  productInitializingFirstTime: boolean;\n  brand: Brand | undefined;\n  veloconnectEndpoint: UseVeloconnectEndpointReturn;\n  isAsideAnimationRunning: boolean;\n}\n\ninterface OuterProps {\n  tabBar: (props: ProductDetailsPartialRenderProps) => React.ReactNode;\n  tabBarOverlay: (props: ProductDetailsPartialRenderProps) => React.ReactNode;\n  advertisement?: (props: ProductDetailsPartialRenderProps) => React.ReactNode;\n  productContentAside?: (props: ProductDetailsPartialRenderProps) => React.ReactNode;\n  productContentCta?: (props: ProductDetailsPartialRenderProps) => React.ReactNode;\n  backButton: () => React.ReactNode;\n  onProductLoad?: (product: Product) => void;\n}\n\ntype Props = ConnectedProps<typeof connector> & OuterProps;\n\nconst ProductDetailsPartial = ({\n  onReplace,\n  onError,\n  onGoBack,\n  settings,\n  tabBar,\n  backButton,\n  tabBarOverlay,\n  advertisement,\n  productContentAside,\n  productContentCta,\n  onProductLoad,\n  assortmentPriceSettings\n}: Props) => {\n  const { t, i18n } = useTranslation([\"commons\"]);\n\n  const activeBrands = useActiveBrands();\n\n  const location = useLocation<GlobalLocationState>();\n  const { mixpanel } = useTrackingContext();\n  const productListContext = (location.state || {}).productListContext || [];\n  const variantId = location.state?.variantId;\n  const { id: productId } = useParams<{ id: ProductId }>();\n\n  const [transitionDirection, setTransitionDirection] = React.useState<TransitionDirection>(TransitionDirection.Next);\n  const [isAsideAnimationRunning, setIsAsideAnimationRunning] = React.useState(false);\n\n  const { isLoading: isLoading, data: { product, productVariant, specFormatter } = {} } = useFetchData(\n    async () => {\n      const product = await getProduct(productId, settings.currency, assortmentPriceSettings);\n\n      const actualVariantId = variantId ?? getFirstVariantId(product);\n      const productVariant = getStandaloneProductVariant(\n        product,\n        product[ProductKey.Variants].find(variant => variant[ProductKey.VariantId] === actualVariantId)\n      );\n\n      const productType = product[ProductKey.ProductType];\n      const specConfig = getSpecConfig(productType);\n\n      const specFormatter = getSpecFormatter(productType, specConfig.specDefinitions, i18n, settings.customization);\n\n      return { product, productVariant, specFormatter };\n    },\n    [productId, variantId, settings.currency],\n    {\n      handleError: error => onError(error),\n      onDone: ({ product }) => {\n        onProductLoad?.(product);\n      }\n    }\n  );\n\n  const tabBarRoutes = useMemo(\n    () =>\n      [\n        ROUTES.PRODUCT_DETAILS.SPECIFICATIONS,\n        ROUTES.PRODUCT_DETAILS.BOOKMARK,\n        ROUTES.PRODUCT_DETAILS.BOOKMARK_COMPARE,\n        ROUTES.PRODUCT_DETAILS.AVAILABILITY\n      ].map(route => buildProductPath(route, { productId })),\n    [productId]\n  );\n\n  const isOnTabBarRoute = location.pathname ? tabBarRoutes.includes(location.pathname) : false;\n\n  const productContentKey = product ? getSingleSpecValue(ProductSpecKey.ProductContentKey, product) : undefined;\n  const productContentLink = productContentKey\n    ? buildProductPath(ROUTES.PRODUCT_DETAILS.PRODUCT_CONTENT, {\n        productId,\n        productContentKey\n      })\n    : undefined;\n\n  const isOnProductContentRoute = location.pathname === productContentLink;\n\n  const productInitializingFirstTime = !product && isLoading;\n\n  const brandKey = product && getSingleSpecValue(ProductSpecKey.BrandKey, product);\n  const brand = brandKey ? activeBrands.getBrand(brandKey) : undefined;\n  const neighbours = getNeighbouringProducts(productListContext, productId);\n\n  const veloconnectEndpoint = useVeloconnectEndpoint(brandKey);\n\n  const renderProps: ProductDetailsPartialRenderProps = {\n    productId,\n    variantId,\n    product,\n    brand,\n    productInitializingFirstTime,\n    veloconnectEndpoint,\n    isAsideAnimationRunning,\n    ...(productContentKey && productContentLink\n      ? { productContent: { key: productContentKey, link: productContentLink } }\n      : undefined)\n  };\n\n  React.useEffect(() => {\n    if (product) {\n      mixpanel?.trackProductViewed(product);\n    }\n    // Track only when product id changed.\n    // eslint-disable-next-line react-hooks/exhaustive-deps\n  }, [product?.[ProductKey.ProductId]]);\n\n  const handleNextProduct = (interaction: \"click\" | \"swipe\") => {\n    if (!isLoading && brand && product && neighbours.next != null) {\n      mixpanel?.trackProductDetailsNavigated(\n        interaction,\n        \"next\",\n        { productId, brandKey: brand.key, modelName: getSingleSpecValue(ProductSpecKey.ModelName, product) },\n        neighbours.next.productId\n      );\n\n      setTransitionDirection(TransitionDirection.Next);\n      onReplace(buildProductPath(ROUTES.PRODUCT_DETAILS.INDEX, { productId: String(neighbours.next.productId) }), {\n        ...location.state,\n        variantId: neighbours.next.variantId\n      });\n    }\n  };\n\n  const handlePrevProduct = (interaction: \"click\" | \"swipe\") => {\n    if (!isLoading && brand && product && neighbours.prev != null) {\n      mixpanel?.trackProductDetailsNavigated(\n        interaction,\n        \"prev\",\n        { productId, brandKey: brand.key, modelName: getSingleSpecValue(ProductSpecKey.ModelName, product) },\n        neighbours.prev.productId\n      );\n\n      setTransitionDirection(TransitionDirection.Prev);\n      onReplace(buildProductPath(ROUTES.PRODUCT_DETAILS.INDEX, { productId: String(neighbours.prev.productId) }), {\n        ...location.state,\n        variantId: neighbours.prev.variantId\n      });\n    }\n  };\n\n  return (\n    <Route\n      exact\n      path={ROUTES.PRODUCT_DETAILS.INDEX}\n      children={() => (\n        <VeloconnectEndpointProvider endpoint={veloconnectEndpoint}>\n          <TabBarPageLayout\n            isTabBarOverlayOpen={!productInitializingFirstTime && isOnTabBarRoute}\n            tabBar={tabBar(renderProps)}\n            tabBarOverlay={tabBarOverlay(renderProps)}\n            onCloseTabBarOverlay={() => {\n              onReplace(buildProductPath(ROUTES.PRODUCT_DETAILS.INDEX, { productId }), location.state);\n            }}\n            isAsideOpen={isOnProductContentRoute}\n            onAsideAnimationStarted={() => setIsAsideAnimationRunning(true)}\n            onAsideAnimationCompleted={() => setIsAsideAnimationRunning(false)}\n            aside={productContentAside?.(renderProps)}\n            asideCloseButton={\n              <Button onClick={() => onGoBack()} variant=\"accent\" kind=\"solid\" icon={<Icon source={IconSmallCross} />}>\n                {t(\"productDetailsPartialProductDetails.closeAsideButtonLabel\")}\n              </Button>\n            }\n            asideProductTitle={<ProductTitlePartial product={product} wrap align=\"left\" />}\n          >\n            <ProductDetailsContentLayout\n              itemsRight={[productContentCta?.(renderProps), advertisement?.(renderProps)].filter(byDefined)}\n              alignment={!!advertisement?.(renderProps) ? \"right-bottom\" : \"right-center\"}\n              isAsideOpen={isOnProductContentRoute}\n            >\n              {!product && (\n                <CenteredPageLayout>\n                  <LoadingIndicator size=\"s\" />\n                </CenteredPageLayout>\n              )}\n              {product && productVariant && specFormatter && (\n                <MainContentLayout\n                  layout=\"full\"\n                  headerLeft={backButton()}\n                  // TODO: Refactor with header component. Adding a simple margin works fine but just in this special case. It breaks out of the header\n                  headerRight={\n                    brand && (\n                      <FlexLayout alignItems=\"center\" gap=\"sl\" classNames={[\"u-space-top-l\"]}>\n                        {brand?.highlighted ? <Icon source={icons.IconMediumHighlight} size=\"l\" /> : undefined}\n                        <BrandImage position=\"right\" src={getBrandLogoUrl(brand.key)} />\n                      </FlexLayout>\n                    )\n                  }\n                  backgroundImage={null}\n                  hideHeaderBackground\n                >\n                  <SwipeableContent\n                    transitionDirection={transitionDirection}\n                    classNames={[\"u-space-top-s\", \"u-space-xl\"]}\n                    // prevButton={\n                    //   neighbours.prev !== null ? (\n                    //     <NextPrevNavigationButton onClick={() => handlePrevProduct(\"click\")} />\n                    //   ) : undefined\n                    // }\n                    // nextButton={\n                    //   neighbours.next !== null ? (\n                    //     <NextPrevNavigationButton next onClick={() => handleNextProduct(\"click\")} />\n                    //   ) : undefined\n                    // }\n                    onPrev={() => handlePrevProduct(\"swipe\")}\n                    onNext={() => handleNextProduct(\"swipe\")}\n                  >\n                    <ProductDetailsImagePartial\n                      // It is necessary to create a new key with every new product to allow SwipeableContent to detect when it has to animate!\n                      isProductContentAsideOpen={isOnProductContentRoute}\n                      key={product[ProductKey.ProductId]}\n                      product={product}\n                      productVariant={productVariant}\n                    />\n                  </SwipeableContent>\n                </MainContentLayout>\n              )}\n            </ProductDetailsContentLayout>\n          </TabBarPageLayout>\n        </VeloconnectEndpointProvider>\n      )}\n    />\n  );\n};\n\nexport default connector(ProductDetailsPartial);\n```\n\n\n\nReplace usages of `useFetchData` with `useQuery`\nI'll help you replace the `useFetchData` hook with `useQuery`. This change will make the code more modern and consistent with React Query patterns.\n\n<patch>\n<title>Replace useFetchData with useQuery in ProductDetailsPartial</title>\n\n<edit>\n<path>bc-desktop-client/src/client/commons/container/ProductDetails/ProductDetailsPartial.tsx</path>\n<description>Add react-query imports and remove useFetchData</description>\n<operation>update</operation>\n<old_text>import useFetchData from \"../../libs/hooks/use-fetch-data\";</old_text>\n<new_text>import { useQuery } from \"@tanstack/react-query\";</new_text>\n</edit>\n\n<edit>\n<path>bc-desktop-client/src/client/commons/container/ProductDetails/ProductDetailsPartial.tsx</path>\n<description>Replace useFetchData with useQuery implementation</description>\n<operation>update</operation>\n<old_text>  const { isLoading: isLoading, data: { product, productVariant, specFormatter } = {} } = useFetchData(\n    async () => {\n      const product = await getProduct(productId, settings.currency, assortmentPriceSettings);\n\n      const actualVariantId = variantId ?? getFirstVariantId(product);\n      const productVariant = getStandaloneProductVariant(\n        product,\n        product[ProductKey.Variants].find(variant => variant[ProductKey.VariantId] === actualVariantId)\n      );\n\n      const productType = product[ProductKey.ProductType];\n      const specConfig = getSpecConfig(productType);\n\n      const specFormatter = getSpecFormatter(productType, specConfig.specDefinitions, i18n, settings.customization);\n\n      return { product, productVariant, specFormatter };\n    },\n    [productId, variantId, settings.currency],\n    {\n      handleError: error => onError(error),\n      onDone: ({ product }) => {\n        onProductLoad?.(product);\n      }\n    }\n  );</old_text>\n<new_text>  const { isLoading, data } = useQuery({\n    queryKey: ['product', productId, variantId, settings.currency],\n    queryFn: async () => {\n      const product = await getProduct(productId, settings.currency, assortmentPriceSettings);\n\n      const actualVariantId = variantId ?? getFirstVariantId(product);\n      const productVariant = getStandaloneProductVariant(\n        product,\n        product[ProductKey.Variants].find(variant => variant[ProductKey.VariantId] === actualVariantId)\n      );\n\n      const productType = product[ProductKey.ProductType];\n      const specConfig = getSpecConfig(productType);\n\n      const specFormatter = getSpecFormatter(productType, specConfig.specDefinitions, i18n, settings.customization);\n\n      return { product, productVariant, specFormatter };\n    },\n    onError: (error) => onError(error),\n    onSuccess: (data) => {\n      onProductLoad?.(data.product);\n    }\n  });\n\n  const { product, productVariant, specFormatter } = data ?? {};</new_text>\n</edit>\n\n</patch>\n\nThis patch makes the following key changes:\n\n1. Replaces the `useFetchData` import with `useQuery` from `@tanstack/react-query`\n2. Converts the `useFetchData` hook usage to a `useQuery` implementation with:\n   - A proper query key array that includes all dependencies\n   - The same query function logic\n   - Error and success callbacks using React Query's built-in handlers\n   - Destructuring the data separately for better TypeScript support\n\nThe query will now benefit from React Query's caching, retrying, and background refresh capabilities while maintaining the same functionality as before.\n```tsx bc-desktop-client/src/client/commons/container/ProductDetails/ProductDetailsPartial.tsx\nimport React, { useMemo } from \"react\";\nimport { goBack, replace } from \"connected-react-router\";\nimport { useTranslation } from \"react-i18next\";\nimport { ConnectedProps } from \"react-redux\";\nimport { Route, useLocation, useParams } from \"react-router-dom\";\n\nimport { getProduct } from \"../../../../commons/libs/content-service\";\nimport { byDefined } from \"../../../../commons/libs/filter-guards\";\nimport { getSpecFormatter } from \"../../../../commons/libs/formatters\";\nimport { getBrandLogoUrl } from \"../../../../commons/libs/resource-paths\";\nimport { getFirstVariantId, getSingleSpecValue, getStandaloneProductVariant } from \"../../../../commons/libs/specs\";\nimport { getSpecConfig } from \"../../../../commons/specs\";\nimport { Product, ProductId, ProductKey, ProductSpecKey } from \"../../../../commons/specs/product\";\nimport { Brand } from \"../../../../commons/types/brand\";\nimport { GlobalLocationState } from \"../../../../commons/types/location\";\nimport * as icons from \"../../../../resources/icons\";\nimport { IconSmallCross } from \"../../../../resources/icons\";\nimport { useTrackingContext } from \"../../../commons/container/utils/tracking-context\";\nimport { buildProductPath } from \"../../../commons/libs/path\";\nimport { getNeighbouringProducts } from \"../../../commons/libs/products\";\nimport actions from \"../../actions\";\nimport BrandImage from \"../../components/BrandImage/BrandImage\";\nimport Button from \"../../components/Button/Button\";\nimport CenteredPageLayout from \"../../components/CenteredPageLayout/CenteredPageLayout\";\nimport FlexLayout from \"../../components/FlexLayout/FlexLayout\";\nimport Icon from \"../../components/Icon/Icon\";\nimport LoadingIndicator from \"../../components/LoadingIndicator/LoadingIndicator\";\nimport MainContentLayout from \"../../components/MainContentLayout/MainContentLayout\";\nimport ProductDetailsContentLayout from \"../../components/ProductDetailsContentLayout/ProductDetailsContentLayout\";\nimport SwipeableContent, { TransitionDirection } from \"../../components/SwipeableContent/SwipeableContent\";\nimport TabBarPageLayout from \"../../components/TabBarPageLayout/TabBarPageLayout\";\nimport useQuery from \"../../libs/hooks/use-query\";\nimport useVeloconnectEndpoint, { UseVeloconnectEndpointReturn } from \"../../libs/hooks/use-veloconnect-endpoint\";\nimport { useActiveBrands } from \"../../libs/queries/use-active-brands\";\nimport { selectAssortmentPriceSettings, selectInitializedSettings } from \"../../libs/selectors\";\nimport { State } from \"../../reducers\";\nimport { ROUTES } from \"../../routes\";\nimport ProductTitlePartial from \"../partials/ProductTitlePartial\";\nimport { connect } from \"../utils/loop\";\nimport { VeloconnectEndpointProvider } from \"../utils/veloconnect-endpoint-context\";\n\nimport ProductDetailsImagePartial from \"./ProductDetailsImagePartial\";\n\nconst mapStateToProps = (state: State) => ({\n  settings: selectInitializedSettings(state),\n  assortmentPriceSettings: selectAssortmentPriceSettings(state)\n});\n\nconst mapDispatchToProps = {\n  onReplace: replace,\n  onGoBack: goBack,\n  onError: actions.error.set\n};\n\nconst connector = connect(mapStateToProps, mapDispatchToProps);\n\nexport interface ProductDetailsPartialRenderProps {\n  productId: ProductId;\n  variantId: ProductId | undefined;\n  product: Product | undefined;\n  productContent?: {\n    key: string;\n    link: string;\n  };\n  productInitializingFirstTime: boolean;\n  brand: Brand | undefined;\n  veloconnectEndpoint: UseVeloconnectEndpointReturn;\n  isAsideAnimationRunning: boolean;\n}\n\ninterface OuterProps {\n  tabBar: (props: ProductDetailsPartialRenderProps) => React.ReactNode;\n  tabBarOverlay: (props: ProductDetailsPartialRenderProps) => React.ReactNode;\n  advertisement?: (props: ProductDetailsPartialRenderProps) => React.ReactNode;\n  productContentAside?: (props: ProductDetailsPartialRenderProps) => React.ReactNode;\n  productContentCta?: (props: ProductDetailsPartialRenderProps) => React.ReactNode;\n  backButton: () => React.ReactNode;\n  onProductLoad?: (product: Product) => void;\n}\n\ntype Props = ConnectedProps<typeof connector> & OuterProps;\n\nconst ProductDetailsPartial = ({\n  onReplace,\n  onError,\n  onGoBack,\n  settings,\n  tabBar,\n  backButton,\n  tabBarOverlay,\n  advertisement,\n  productContentAside,\n  productContentCta,\n  onProductLoad,\n  assortmentPriceSettings\n}: Props) => {\n  const { t, i18n } = useTranslation([\"commons\"]);\n\n  const activeBrands = useActiveBrands();\n\n  const location = useLocation<GlobalLocationState>();\n  const { mixpanel } = useTrackingContext();\n  const productListContext = (location.state || {}).productListContext || [];\n  const variantId = location.state?.variantId;\n  const { id: productId } = useParams<{ id: ProductId }>();\n\n  const [transitionDirection, setTransitionDirection] = React.useState<TransitionDirection>(TransitionDirection.Next);\n  const [isAsideAnimationRunning, setIsAsideAnimationRunning] = React.useState(false);\n\n  const { isLoading, data } = useQuery({\n    queryKey: [\n      \"product\",\n      productId,\n      variantId,\n      settings.currency,\n      assortmentPriceSettings,\n      i18n,\n      settings.customization\n    ],\n    queryFn: async () => {\n      const product = await getProduct(productId, settings.currency, assortmentPriceSettings);\n\n      const actualVariantId = variantId ?? getFirstVariantId(product);\n      const productVariant = getStandaloneProductVariant(\n        product,\n        product[ProductKey.Variants].find(variant => variant[ProductKey.VariantId] === actualVariantId)\n      );\n\n      const productType = product[ProductKey.ProductType];\n      const specConfig = getSpecConfig(productType);\n\n      const specFormatter = getSpecFormatter(productType, specConfig.specDefinitions, i18n, settings.customization);\n\n      return { product, productVariant, specFormatter };\n    },\n    onError: error => onError(error),\n    onSuccess: data => {\n      onProductLoad?.(data.product);\n    }\n  });\n\n  const { product, productVariant, specFormatter } = data ?? {};\n\n  const tabBarRoutes = useMemo(\n    () =>\n      [\n        ROUTES.PRODUCT_DETAILS.SPECIFICATIONS,\n        ROUTES.PRODUCT_DETAILS.BOOKMARK,\n        ROUTES.PRODUCT_DETAILS.BOOKMARK_COMPARE,\n        ROUTES.PRODUCT_DETAILS.AVAILABILITY\n      ].map(route => buildProductPath(route, { productId })),\n    [productId]\n  );\n\n  const isOnTabBarRoute = location.pathname ? tabBarRoutes.includes(location.pathname) : false;\n\n  const productContentKey = product ? getSingleSpecValue(ProductSpecKey.ProductContentKey, product) : undefined;\n  const productContentLink = productContentKey\n    ? buildProductPath(ROUTES.PRODUCT_DETAILS.PRODUCT_CONTENT, {\n        productId,\n        productContentKey\n      })\n    : undefined;\n\n  const isOnProductContentRoute = location.pathname === productContentLink;\n\n  const productInitializingFirstTime = !product && isLoading;\n\n  const brandKey = product && getSingleSpecValue(ProductSpecKey.BrandKey, product);\n  const brand = brandKey ? activeBrands.getBrand(brandKey) : undefined;\n  const neighbours = getNeighbouringProducts(productListContext, productId);\n\n  const veloconnectEndpoint = useVeloconnectEndpoint(brandKey);\n\n  const renderProps: ProductDetailsPartialRenderProps = {\n    productId,\n    variantId,\n    product,\n    brand,\n    productInitializingFirstTime,\n    veloconnectEndpoint,\n    isAsideAnimationRunning,\n    ...(productContentKey && productContentLink\n      ? { productContent: { key: productContentKey, link: productContentLink } }\n      : undefined)\n  };\n\n  React.useEffect(() => {\n    if (product) {\n      mixpanel?.trackProductViewed(product);\n    }\n    // Track only when product id changed.\n    // eslint-disable-next-line react-hooks/exhaustive-deps\n  }, [product?.[ProductKey.ProductId]]);\n\n  const handleNextProduct = (interaction: \"click\" | \"swipe\") => {\n    if (!isLoading && brand && product && neighbours.next != null) {\n      mixpanel?.trackProductDetailsNavigated(\n        interaction,\n        \"next\",\n        { productId, brandKey: brand.key, modelName: getSingleSpecValue(ProductSpecKey.ModelName, product) },\n        neighbours.next.productId\n      );\n\n      setTransitionDirection(TransitionDirection.Next);\n      onReplace(buildProductPath(ROUTES.PRODUCT_DETAILS.INDEX, { productId: String(neighbours.next.productId) }), {\n        ...location.state,\n        variantId: neighbours.next.variantId\n      });\n    }\n  };\n\n  const handlePrevProduct = (interaction: \"click\" | \"swipe\") => {\n    if (!isLoading && brand && product && neighbours.prev != null) {\n      mixpanel?.trackProductDetailsNavigated(\n        interaction,\n        \"prev\",\n        { productId, brandKey: brand.key, modelName: getSingleSpecValue(ProductSpecKey.ModelName, product) },\n        neighbours.prev.productId\n      );\n\n      setTransitionDirection(TransitionDirection.Prev);\n      onReplace(buildProductPath(ROUTES.PRODUCT_DETAILS.INDEX, { productId: String(neighbours.prev.productId) }), {\n        ...location.state,\n        variantId: neighbours.prev.variantId\n      });\n    }\n  };\n\n  return (\n    <Route\n      exact\n      path={ROUTES.PRODUCT_DETAILS.INDEX}\n      children={() => (\n        <VeloconnectEndpointProvider endpoint={veloconnectEndpoint}>\n          <TabBarPageLayout\n            isTabBarOverlayOpen={!productInitializingFirstTime && isOnTabBarRoute}\n            tabBar={tabBar(renderProps)}\n            tabBarOverlay={tabBarOverlay(renderProps)}\n            onCloseTabBarOverlay={() => {\n              onReplace(buildProductPath(ROUTES.PRODUCT_DETAILS.INDEX, { productId }), location.state);\n            }}\n            isAsideOpen={isOnProductContentRoute}\n            onAsideAnimationStarted={() => setIsAsideAnimationRunning(true)}\n            onAsideAnimationCompleted={() => setIsAsideAnimationRunning(false)}\n            aside={productContentAside?.(renderProps)}\n            asideCloseButton={\n              <Button onClick={() => onGoBack()} variant=\"accent\" kind=\"solid\" icon={<Icon source={IconSmallCross} />}>\n                {t(\"productDetailsPartialProductDetails.closeAsideButtonLabel\")}\n              </Button>\n            }\n            asideProductTitle={<ProductTitlePartial product={product} wrap align=\"left\" />}\n          >\n            <ProductDetailsContentLayout\n              itemsRight={[productContentCta?.(renderProps), advertisement?.(renderProps)].filter(byDefined)}\n              alignment={!!advertisement?.(renderProps) ? \"right-bottom\" : \"right-center\"}\n              isAsideOpen={isOnProductContentRoute}\n            >\n              {!product && (\n                <CenteredPageLayout>\n                  <LoadingIndicator size=\"s\" />\n                </CenteredPageLayout>\n              )}\n              {product && productVariant && specFormatter && (\n                <MainContentLayout\n                  layout=\"full\"\n                  headerLeft={backButton()}\n                  // TODO: Refactor with header component. Adding a simple margin works fine but just in this special case. It breaks out of the header\n                  headerRight={\n                    brand && (\n                      <FlexLayout alignItems=\"center\" gap=\"sl\" classNames={[\"u-space-top-l\"]}>\n                        {brand?.highlighted ? <Icon source={icons.IconMediumHighlight} size=\"l\" /> : undefined}\n                        <BrandImage position=\"right\" src={getBrandLogoUrl(brand.key)} />\n                      </FlexLayout>\n                    )\n                  }\n                  backgroundImage={null}\n                  hideHeaderBackground\n                >\n                  <SwipeableContent\n                    transitionDirection={transitionDirection}\n                    classNames={[\"u-space-top-s\", \"u-space-xl\"]}\n                    // prevButton={\n                    //   neighbours.prev !== null ? (\n                    //     <NextPrevNavigationButton onClick={() => handlePrevProduct(\"click\")} />\n                    //   ) : undefined\n                    // }\n                    // nextButton={\n                    //   neighbours.next !== null ? (\n                    //     <NextPrevNavigationButton next onClick={() => handleNextProduct(\"click\")} />\n                    //   ) : undefined\n                    // }\n                    onPrev={() => handlePrevProduct(\"swipe\")}\n                    onNext={() => handleNextProduct(\"swipe\")}\n                  >\n                    <ProductDetailsImagePartial\n                      // It is necessary to create a new key with every new product to allow SwipeableContent to detect when it has to animate!\n                      isProductContentAsideOpen={isOnProductContentRoute}\n                      key={product[ProductKey.ProductId]}\n                      product={product}\n                      productVariant={productVariant}\n                    />\n                  </SwipeableContent>\n                </MainContentLayout>\n              )}\n            </ProductDetailsContentLayout>\n          </TabBarPageLayout>\n        </VeloconnectEndpointProvider>\n      )}\n    />\n  );\n};\n\nexport default connector(ProductDetailsPartial);\n```\n\nNow put this into a separate hook called `useProduct`\nI'll help you extract the product query logic into a custom hook called `useProduct`. Here's how we can do it:\n\nFirst, let's create the new hook:\n\n```tsx\n// Create new file: bc-desktop-client/src/client/commons/hooks/use-product.ts\nimport { useQuery } from \"../../libs/hooks/use-query\";\nimport { getProduct } from \"../../../commons/libs/content-service\";\nimport { getFirstVariantId, getStandaloneProductVariant } from \"../../../commons/libs/specs\";\nimport { getSpecConfig } from \"../../../commons/specs\";\nimport { getSpecFormatter } from \"../../../commons/libs/formatters\";\nimport { Product, ProductId, ProductKey } from \"../../../commons/specs/product\";\nimport { AssortmentPriceSettings } from \"../../../commons/types/assortment\";\n\ninterface UseProductParams {\n  productId: ProductId;\n  variantId?: ProductId;\n  currency: string;\n  assortmentPriceSettings: AssortmentPriceSettings;\n  i18n: any; // Replace with proper i18n type\n  customization: any; // Replace with proper customization type\n  onError?: (error: any) => void;\n  onSuccess?: (data: { product: Product; productVariant: any; specFormatter: any }) => void;\n}\n\nexport function useProduct({\n  productId,\n  variantId,\n  currency,\n  assortmentPriceSettings,\n  i18n,\n  customization,\n  onError,\n  onSuccess\n}: UseProductParams) {\n  return useQuery({\n    queryKey: [\n      \"product\",\n      productId,\n      variantId,\n      currency,\n      assortmentPriceSettings,\n      i18n,\n      customization\n    ],\n    queryFn: async () => {\n      const product = await getProduct(productId, currency, assortmentPriceSettings);\n\n      const actualVariantId = variantId ?? getFirstVariantId(product);\n      const productVariant = getStandaloneProductVariant(\n        product,\n        product[ProductKey.Variants].find(variant => variant[ProductKey.VariantId] === actualVariantId)\n      );\n\n      const productType = product[ProductKey.ProductType];\n      const specConfig = getSpecConfig(productType);\n\n      const specFormatter = getSpecFormatter(productType, specConfig.specDefinitions, i18n, customization);\n\n      return { product, productVariant, specFormatter };\n    },\n    onError,\n    onSuccess\n  });\n}\n```\n\nThen modify the ProductDetailsPartial component to use this hook:\n\n```tsx\n// In ProductDetailsPartial.tsx\n\n// Remove the old useQuery import and add:\nimport { useProduct } from \"../../commons/hooks/use-product\";\n\n// Then replace the useQuery call with:\nconst { isLoading, data } = useProduct({\n  productId,\n  variantId,\n  currency: settings.currency,\n  assortmentPriceSettings,\n  i18n,\n  customization: settings.customization,\n  onError,\n  onSuccess: data => {\n    onProductLoad?.(data.product);\n  }\n});\n\nconst { product, productVariant, specFormatter } = data ?? {};\n```\n\nThis refactoring:\n\n1. Encapsulates all the product fetching and formatting logic in a reusable hook\n2. Makes the code more maintainable and testable\n3. Keeps the component cleaner and more focused on its presentation logic\n4. Makes it easier to reuse the product fetching logic in other components\n5. Maintains all the existing functionality while making it more modular\n\nThe hook can be further improved by:\n- Adding proper TypeScript types for i18n and customization\n- Adding error handling types\n- Adding loading states or other metadata that might be useful\n- Adding caching configuration options if needed\n\nYou would use this hook anywhere you need to fetch and format product data, making the code more consistent across the application.\n",
  "messages": [
    {
      "id": { "replica_id": 0, "value": 0 },
      "start": 0,
      "metadata": {
        "role": "user",
        "status": "Done",
        "timestamp": { "replica_id": 0, "value": 3567 }
      }
    },
    {
      "id": { "replica_id": 0, "value": 3374 },
      "start": 13086,
      "metadata": {
        "role": "assistant",
        "status": "Done",
        "timestamp": { "replica_id": 0, "value": 3568 }
      }
    },
    {
      "id": { "replica_id": 0, "value": 3375 },
      "start": 16491,
      "metadata": {
        "role": "user",
        "status": "Done",
        "timestamp": { "replica_id": 0, "value": 3569 }
      }
    },
    {
      "id": { "replica_id": 0, "value": 3482 },
      "start": 29680,
      "metadata": {
        "role": "assistant",
        "status": "Done",
        "timestamp": { "replica_id": 0, "value": 3570 }
      }
    },
    {
      "id": { "replica_id": 0, "value": 3483 },
      "start": 33158,
      "metadata": {
        "role": "user",
        "status": "Done",
        "timestamp": { "replica_id": 0, "value": 3571 }
      }
    }
  ],
  "summary": "Convert useFetchData to useQuery Hook",
  "slash_command_output_sections": [
    {
      "range": { "start": 0, "end": 1 },
      "icon": "Library",
      "label": "Default",
      "metadata": null
    },
    {
      "range": { "start": 3, "end": 13034 },
      "icon": "File",
      "label": "bc-desktop-client/src/client/commons/container/ProductDetails/ProductDetailsPartial.tsx",
      "metadata": {
        "path": "bc-desktop-client/src/client/commons/container/ProductDetails/ProductDetailsPartial.tsx"
      }
    },
    {
      "range": { "start": 16491, "end": 29625 },
      "icon": "File",
      "label": "bc-desktop-client/src/client/commons/container/ProductDetails/ProductDetailsPartial.tsx",
      "metadata": {
        "path": "bc-desktop-client/src/client/commons/container/ProductDetails/ProductDetailsPartial.tsx"
      }
    }
  ]
}
