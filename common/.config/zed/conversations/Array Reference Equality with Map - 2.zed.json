{
  "id": "22b98397-42fe-4dfe-a2c3-87fc95f59cc8",
  "zed": "context",
  "version": "0.4.0",
  "text": "\n\n\n```ts bc-desktop-client/src/client/commons/libs/queries/use-active-brands.ts\nimport { useMutation, UseMutationOptions, useQueryClient } from \"@tanstack/react-query\";\nimport { keyBy } from \"lodash\";\n\nimport { addBrand, addBrands, getActiveBrands, removeBrand } from \"../../../../commons/libs/content-service\";\nimport { Brand } from \"../../../../commons/types/brand\";\nimport useQuery, { UseQueryOptions } from \"../hooks/use-query\";\n\nexport const queryKey = {\n  activeBrands: [\"activeBrands\"] as const,\n  addActiveBrand: [\"addActiveBrand\"] as const,\n  removeActiveBrand: [\"removeActiveBrand\"] as const,\n  addActiveBrands: [\"addActiveBrands\"] as const\n} as const;\n\ntype BrandsQueryOptions = Omit<Partial<UseQueryOptions<Brand[]>>, \"queryKey\" | \"queryFn\">;\ntype BrandMutationOption = Omit<Partial<UseMutationOptions<Brand[], Error, Brand>>, \"mutationFn\">;\ntype BrandsMutationOption = Omit<Partial<UseMutationOptions<Brand[], Error, Brand[]>>, \"mutationFn\">;\n\nexport const useActiveBrands = (options: BrandsQueryOptions = {}) => {\n  const query = useQuery({\n    ...options,\n    queryKey: queryKey.activeBrands,\n    placeholderData: [],\n    queryFn: getActiveBrands,\n    // Active Brands do not change during runtime (device restarts on changes),\n    // but the cache can still be invalidated by mutations. Setting staleTime\n    // to Infinity prevents unnecessary refetches.\n    staleTime: Infinity\n  });\n\n  const brands = query.data ?? [];\n  const highlightedBrands = brands.filter(brand => brand.highlighted);\n\n  const map = keyBy(brands, brand => brand.key);\n\n  const keys = brands.map(brand => brand.key);\n  const highlightedKeys = highlightedBrands.map(brand => brand.key);\n\n  const count = keys.length;\n  const highlightedCount = highlightedKeys.length;\n\n  const get = (brandKey: string) => brands.find(activeBrand => activeBrand.key === brandKey);\n\n  return {\n    query,\n    /** An array of all active brands.\n     * If no brands are active or the query is not fetched yet, an empty array is returned.\n     * You could also use `activeBrands.query.data`, but  then you need to handle the `undefined` case of `data` yourself.\n     * @default [] */\n    brands,\n    /** An array of all highlighted brands.\n     * If no brands are highlighted or the query is not fetched yet, an empty array is returned.\n     * @default [] */\n    highlightedBrands,\n    /** A map of all active brands, where the key is the brand key and the value is the brand.\n     * If no brands are active or the query is not fetched yet, an empty object is returned.\n     * @default {} */\n    map,\n    /** All active brand keys.\n     * If no brands are active or the query is not fetched yet, an empty array is returned.\n     * @default [] */\n    keys,\n    /** All highlighted brand keys.\n     * If no brands are highlighted or the query is not fetched yet, an empty array is returned.\n     * @default [] */\n    highlightedKeys,\n    /** The number of active brands. */\n    count,\n    /** The number of highlighted brands. */\n    highlightedCount,\n    /** Returns the brand with the given key. If no brand with the given key exists, undefined is returned. */\n    get\n  };\n};\n\nexport const useAddActiveBrand = (options: BrandMutationOption = {}) => {\n  const queryClient = useQueryClient();\n\n  return useMutation({\n    ...options,\n    mutationKey: queryKey.addActiveBrand,\n    mutationFn: (brand: Brand) => addBrand(brand),\n    onSuccess: (activeBrands, brand, context) => {\n      queryClient.invalidateQueries({ queryKey: queryKey.activeBrands });\n      options.onSuccess?.(activeBrands, brand, context);\n    }\n  });\n};\n\nexport const useRemoveActiveBrand = (options: BrandMutationOption = {}) => {\n  const queryClient = useQueryClient();\n\n  return useMutation({\n    ...options,\n    mutationKey: queryKey.removeActiveBrand,\n    mutationFn: (brand: Brand) => removeBrand(brand.key),\n    onSuccess: (activeBrands, brand, context) => {\n      queryClient.invalidateQueries({ queryKey: queryKey.activeBrands });\n      options.onSuccess?.(activeBrands, brand, context);\n    }\n  });\n};\n\nexport const useAddActiveBrands = (options: BrandsMutationOption = {}) => {\n  const queryClient = useQueryClient();\n\n  return useMutation({\n    ...options,\n    mutationKey: queryKey.addActiveBrands,\n    mutationFn: (brands: Brand[]) => addBrands(brands),\n    onSuccess: (activeBrands, brands, context) => {\n      queryClient.invalidateQueries({ queryKey: queryKey.activeBrands });\n      options.onSuccess?.(activeBrands, brands, context);\n    }\n  });\n};\n```\n\n\n\n```tsx bc-desktop-client/src/client/kiosk/container/App/AppLifecycles.tsx:477-540\n// Excerpt from: \nconst useVeloconnectActiveBrandsSync = () => {\n  const isOnline = useIsOnline();\n  const activeBrands = useActiveBrands();\n  const [shouldSync, setShouldSync] = useState(false);\n\n  useFetchData<Status | undefined>(\n    () => {\n      if (isOnline) {\n        return testVeloconnectProxy();\n      } else {\n        return Promise.resolve(undefined);\n      }\n    },\n    [isOnline, activeBrands.brandKeys],\n    {\n      onDone: data => {\n        if (isOnline && data?.code === 200) {\n          setShouldSync(true);\n        } else {\n          setShouldSync(false);\n        }\n      },\n      handleError: error => {\n        setShouldSync(false);\n\n        captureException(error, {\n          extra: {\n            message: \"Error while pinging proxy server\",\n            location: \"src/client/kiosk/container/App/AppLifecycles.tsx#useVeloconnectActiveBrandsSync\",\n            initiator: \"testVeloconnectProxy\"\n          }\n        });\n      }\n    }\n  );\n\n  useFetchData(\n    () => {\n      if (shouldSync) {\n        return syncActiveBrandsWithVeloconnect();\n      } else {\n        return Promise.resolve([] as string[]);\n      }\n    },\n    [shouldSync],\n    {\n      onDone: () => {\n        setShouldSync(false);\n      },\n      handleError: error => {\n        setShouldSync(false);\n\n        captureException(error, {\n          extra: {\n            message: \"Error while syncing active brands\",\n            location: \"src/client/kiosk/container/App/AppLifecycles.tsx#useVeloconnectActiveBrandsSync\",\n            initiator: \"syncActiveBrandsWithVeloconnect\"\n          }\n        });\n      }\n    }\n  );\n};\n\n```\n\n\nDespite that tanstack-query stabilizes the `query.data` property by comparing the contents, we still need to use `useMemo` when creating `brandKeys` from the `data` array.\n\n```ts bc-desktop-client/src/client/commons/libs/queries/use-active-brands.ts:33-34\n\n// Excerpt from: const useActiveBrands\n  const brandKeys = useMemo(() => data.map(brand => brand.key), [data]);\n\n```\n\nBecause if we don't and use the `brandKeys` in an dependency array of an effect, it will cause infinite loops.\n\nI am guessing this is because `.map` will create a new array every time?\nYes, that's correct! This is a common gotcha in React. Even though tanstack-query stabilizes the `data` reference itself, any derived values created using array methods like `.map()` will create new array references on every render.\n\nHere's why:\n1. `.map()` always returns a new array instance\n2. JavaScript compares arrays by reference, not by value\n3. Even if the contents are identical, `[] !== []`\n4. React's dependency comparison is shallow, so it sees these as different arrays\n\nFor example:\n```javascript\nconst arr1 = [1, 2, 3];\nconst arr2 = arr1.map(x => x); // New array reference\nconsole.log(arr1 !== arr2); // true\n```\n\nWhen this new array reference is used in a dependency array, it causes the effect to re-run, which might trigger a re-render, creating a new array again, and so on - leading to an infinite loop.\n\nThe `useMemo` hook solves this by memoizing the derived array and only creating a new reference when the source `data` actually changes:\n\n```typescript\nconst brandKeys = useMemo(() => data.map(brand => brand.key), [data]);\n```\n\nThis is a common pattern when you need to derive arrays that will be used in dependency arrays. Alternative approaches include:\n1. Using `useMemo`\n2. Moving the transformation inside the effect/callback\n3. Using a more primitive dependency (like array length) if appropriate\n\nYeah so basically there is no way around this issue?\nCorrect, when working with derived arrays that will be used in dependency arrays, you'll need to handle the referential stability issue one way or another. The most common approaches are:\n\n1. Using `useMemo` (as shown in your example):\n```typescript\nconst brandKeys = useMemo(() => data.map(brand => brand.key), [data]);\n```\n\n2. Moving the transformation inside the effect:\n```typescript\nuseEffect(() => {\n  const brandKeys = data.map(brand => brand.key);\n  // use brandKeys here\n}, [data]); // depend on data directly\n```\n\n3. If possible, depend on more primitive values:\n```typescript\n// If you only need to know when the array changes length\nuseEffect(() => {\n  // ...\n}, [data.length]);\n```\n\nThe issue is fundamental to how JavaScript handles array references and React's dependency comparison system. Even libraries like tanstack-query that handle data stabilization can't prevent new references being created by array operations like `.map()`, `.filter()`, etc.\n\nOkay, thank you. What do you think about the general structure of the hook?\n\nWe put derived values inside the hook and export them.\nWe also export the `query` directly without spreading it to uphold the tracked properties feature from `tanstack-query`.\n\nMaybe that is not good practice?\n\nWe could also return the query directly without an additional wrapper object and the derived values.\n\nThe derived values could be selectors functions that accept `data` as an argument and return the derived values, but live in the same file, but would need to be imported separately.\n\nThe current structure is actually quite good and follows several solid practices:\n\nPros of the current approach:\n1. **Encapsulation** - It hides the complexity of data transformation in one place\n2. **Convenience** - Consumers get commonly needed derived values without having to calculate them repeatedly\n3. **Type safety** - All derived values are properly typed and documented\n4. **Performance** - Calculations happen in one place, avoiding repeated computations across components\n5. **Direct query access** - Exposing the raw query object allows consumers to access status, error states, and other query features\n\n```typescript\n// Current usage is clean and intuitive\nconst { \n  brands,\n  highlightedBrands,\n  query: { isLoading, error } \n} = useActiveBrands();\n```\n\nThe selector approach you mentioned:\n```typescript\n// Alternative with selectors\nconst query = useActiveBrands();\nconst brands = selectBrands(query.data);\nconst highlightedBrands = selectHighlightedBrands(query.data);\n```\n\nCons of the selector approach:\n1. More boilerplate in consuming components\n2. Potential for repeated calculations if not memoized\n3. Less discoverable API (need to import selectors separately)\n\nI think the current structure strikes a good balance between:\n- Maintainability (calculations in one place)\n- Usability (convenient access to derived data)\n- Flexibility (raw query access)\n- Performance (single point of calculation)\n\nThe only thing I might consider adding would be memoization for computationally expensive derivations, but for simple transformations like in this case, it's probably not necessary.\nOkay thanks. I don't like destructuring that much honestly. I prefer to encapsulate the whole return under a \"topic\" namespace and then access the properties directly. That way I always know where the value is coming from and its context. According to the query documentation this is also fine:\n\n```typescript\n// So instead of this\nconst { \n  brands,\n  highlightedBrands,\n  query: { isLoading, error } \n} = useActiveBrands();\n\n// I am doing this\nconst activeBrands = useActiveBrands();\n\nactiveBrands.brands;\nactiveBrands.highlightedBrands;\nactiveBrands.query.isLoading;\nactiveBrands.query.error;\n```\n\nIs that bad? Good?\nThat's actually a really good practice! This approach has several benefits:\n\n1. **Clear Context/Namespace** - As you mentioned, it's immediately obvious where values are coming from\n```typescript\nactiveBrands.brands // clearly from active brands context\nvs\nbrands // where did this come from?\n```\n\n2. **Better Code Navigation** - IDEs can better help you find usages and references when you use dot notation\n\n3. **Reduced Name Conflicts** - No need to worry about naming conflicts or renaming during destructuring\n```typescript\n// No need for this:\nconst { brands: activeBrands } = useActiveBrands();\n```\n\n4. **Self-Documenting** - The namespace itself documents the domain/context of the properties\n\n5. **Consistent with React Query's Philosophy** - As you noted, React Query encourages this pattern for maintaining access to all query features\n\nThe only minor downside might be slightly more verbose syntax, but the benefits of clarity and maintainability outweigh this.\n\nCompare:\n```typescript\n// Less clear where isLoading is from in a large component\nif (isLoading) return <Spinner />;\n\n// Very clear context\nif (activeBrands.query.isLoading) return <Spinner />;\n```\n\nThis approach aligns well with the principle of \"explicit over implicit\" and makes code more maintainable and readable in the long run. I'd say it's a good practice!\n\nOkay thanks!\nYou're welcome! One small tip: If you're going to stick with this namespaced approach (which is good!), you might want to add it to your team's style guide or coding conventions. This helps maintain consistency across the codebase, especially when multiple developers are working with custom hooks that return complex objects.\n\nAlso, the documentation you added in the code is really good:\n```typescript\n/** A map of all active brands, where the key is the brand key and the value is the brand.\n * If no brands are active or the query is not fetched yet, an empty object is returned.\n * @default {} */\nmap,\n```\n\nThis kind of clear documentation of return values, including default values, makes the API much more user-friendly for other developers on the team!\n\nYeah I want to write a little section about this in our code guidelines.\n\n```md bc-desktop-client/docs/code-guidelines.md\n# Code Guidelines\n\n- [Disclaimer](#disclaimer)\n- [Architecture](#architecture)\n- [Containers](#containers)\n  - [Container Rules](#container-rules)\n  - [Container Structure](#container-structure)\n    - [Container Migration](#container-migration)\n  - [Container Types](#container-types)\n  - [Page](#page)\n  - [Switch](#switch)\n  - [Overlay](#overlay)\n  - [Partial](#partial)\n- [Components](#components)\n  - [Component Rules](#component-rules)\n  - [Component Types](#component-types)\n    - [Layout](#layout)\n    - [List \\& ListItems](#list--listitems)\n    - [Field](#field)\n    - [Button](#button)\n- [Props](#props)\n  - [React Nodes](#react-nodes)\n  - [Modifier prop style](#modifier-prop-style)\n    - [Modifier prop naming convention](#modifier-prop-naming-convention)\n- [React](#react)\n  - [Hooks](#hooks)\n    - [Ignoring Rules and Warnings](#ignoring-rules-and-warnings)\n    - [Best Practices for the builtin React Hooks](#best-practices-for-the-builtin-react-hooks)\n      - [`useState`](#usestate)\n      - [`useEffect`](#useeffect)\n      - [`useCallback`](#usecallback)\n      - [`useMemo`](#usememo)\n      - [`useRef`](#useref)\n    - [Custom Hooks](#custom-hooks)\n    - [Informational Links Regarding Hooks](#informational-links-regarding-hooks)\n- [Redux](#redux)\n- [Specs \\& Formatting](#specs--formatting)\n  - [Spec Keys and Spec Definitions](#spec-keys-and-spec-definitions)\n  - [Specs lib](#specs-lib)\n  - [Spec formatting and localisation](#spec-formatting-and-localisation)\n- [Storybook](#storybook)\n  - [Default component values](#default-component-values)\n  - [Story format migration](#story-format-migration)\n- [Style](#style)\n  - [Programming paradigm](#programming-paradigm)\n  - [Other code styling choices](#other-code-styling-choices)\n- [Types](#types)\n- [CSS](#css)\n- [Pull Requests](#pull-requests)\n  - [Sync UI Updates with Design Team](#sync-ui-updates-with-design-team)\n\n## Disclaimer\n\nThis document is and always be a work in progress and just represents the current state of the repository.\n\nIf you find things missing or a wrong, please create a PR!\n\n## Architecture\n\nThe components are generally built on the concept of _smart containers_ and _representational components_.\nIf you never heard of this before, you can read [this article](https://medium.com/@dan_abramov/smart-and-dumb-components-7ca2f9a7c7d0) for an explanation of this concept.\n\n## Containers\n\n### Container Rules\n\nHere are some rules taken from the [article](https://medium.com/@dan_abramov/smart-and-dumb-components-7ca2f9a7c7d0):\n\nContainers..\n\n- Are concerned with _how things work_.\n- May contain both presentational and container components inside but usually don’t have any DOM markup of their own except for some wrapping divs, and never have any styles.\n- Provide the data and behavior to presentational or other container components.\n- Call Flux actions and provide these as callbacks to the presentational components.\n- Are often stateful, as they tend to serve as data sources.\n\n### Container Structure\n\n- The container structure should be kept consistent for better readability\n- Larger logic structures for a certain topic, should be stored in a custom hook\n\nHere is a fictional example:\n\n```tsx\nimport { useProductFinderData } from \"./useProductFinderData.ts\";\nimport { useProductFinderFilter } from \"./useProductFinderFilter.ts\";\n\ninterface OuterProps {}\nconst mapStateToProps = (state: State) => ({});\nconst mapDispatchToProps = {};\nconst connector = connect(mapStateToProps, mapDispatchToProps);\ntype Props = ConnectedProps<typeof connector> & OuterProps;\nconst ProductFinder = ({}: Props) => {\n  const data = useProductFinderData();\n  const filter = useProductFinderFilter();\n  const onFilterClick = () => {};\n  return <ProductFinder data={data} filter={filter} onFilterClick={onFilterClick} />;\n};\nexport default connector(ProductFinder);\n```\n\n### Container Types\n\n**Container** in itself is just an umbrella term. We distinguish between different types of containers.\n\nThese types are then suffixed to the filename itself for easy identification.\n\nHere is also a visual implementation of this. You will find a detailed explanation below.\n\n```mermaid\nflowchart TB\n  subgraph componentGraph [Components]\n    componentId(Component) --> componentId\n    layoutId(Layout) --> componentId\n    fieldId(Field) --> componentId\n    buttonId(Button) --> componentId\n  end\n\n  subgraph containerGraph [Containers]\n    pageId(Page) --> partialId\n    pageId --> overlayId\n\n    switchId(Switch) --> partialId\n    switchId --> pageId\n\n    overlayId(Overlay) --> partialId\n\n    partialId(Partial) --> partialId\n  end\n\n  containerGraph --> componentGraph\n```\n\n_Each relationship should be seen as a 'has many' (can contain multiple) relationship. For example each container can contain multiple components, but no component can contain a container. As another example; a Switch can contain multiple Pages, Partials and Components. However, it cannot be contained by anything else._\n\n### Page\n\nA **Page** is a container that can be reached through a route.\n\nExamples: `LocalePage.tsx`, `PersonalCodePage.tsx`, `BookmarkComparePage.tsx` etc.\n\n### Switch\n\nA **Switch** serves as an entry point, which routes to different other pages, and omits any kind of suffix.\n\n_Note: Switches currently do not have a Suffix._\n\nExamples: `App.tsx`, `Wawi.tsx`, `Network.tsx` etc.\n\n### Overlay\n\nContainers whose view should overlay other views are called **Overlays**.\n\nExamples: `AvailabilityOverlay.tsx`, `BookmarkOverlay.tsx` etc.\n\n### Partial\n\nA **Partial** represents partial content for another container. Either for reusability or for readability.\n\nExamples: `VariantsContentPartial.tsx` `FilterModalPartial.tsx`, `ProductFinderPartial.tsx` etc.\n\n## Components\n\n### Component Rules\n\nHere are some rules taken from the [article](https://medium.com/@dan_abramov/smart-and-dumb-components-7ca2f9a7c7d0):\n\nComponents ..\n\n- Are concerned with _how things look_.\n- May contain both presentational and container components inside, and usually have some DOM markup and styles of their own.\n- Often allow containment via `this.props.children`.\n- Have no dependencies on the rest of the app, such as Flux actions or stores.\n- Don’t specify how the data is loaded or mutated.\n- Receive data and callbacks exclusively via props.\n- Rarely have their own state (when they do, it’s UI state rather than data).\n\n### Component Types\n\nThere are also some different types of components which _are currently not as strictly named or structured_, but will happen in an extra future step.\n\nExample: Something like `LabeledToggleField.tsx`, which only accepts React Nodes as props and places them in a layout, would be considered a Layout component, but is currently not suffixed with `Label`.\n\nNot all components belong to a certain type, but all known types are listed here.\n\n#### Layout\n\n_Layout_ components serve to visually structure the small or large content. Typically they accept React Nodes as props and don't render much by themselves.\n\nExamples: `FlexLayout.tsx`, `AvailabilityLayout.tsx` etc.\n\n#### List & ListItems\n\nLike the name suggests, these components serve to render lists and their items. There is also a accompanying, shared SCSS/Sass mixin called `@list-item`.\n\nExamples: `SpecsList.tsx`, `SingleDescribedInputList.tsx`, `BrandListItem.tsx`, `RadioListItem.tsx` etc.\n\n#### Field\n\n_Field_ components represent input components.\n\nExamples: `PinField.tsx`, `RadioField.tsx`, `InputField.tsx` etc.\n\n#### Button\n\nExamples: `KeyboardButton.tsx`, `CircularButton.tsx`, `IconButton.tsx` etc.\n\n## Props\n\n### React Nodes\n\nTo keep maximum independence between the individual components, their architecture should take advantage of Children & ReactNodes.\n\nSome Example: `SingleLabeledToggleField.tsx`, `Card.tsx`, `NextCustomerWorldLayout.tsx` etc.\n\n### Modifier prop style\n\nIf a component needs modifying props, which should exclude each other, for example, something like `variants` or `color`, the prop type should be a Union Type.\n\nIf a modifying prop can be used independently, it should be a `boolean`.\n\n```tsx\n// Headline.tsx\ntype Variant = \"base\" | \"xs\" | \"s\" | \"m\" | \"l\" | \"minor\" | \"sub\" | \"hero\";\n\ntype Tag = \"h1\" | \"h2\" | \"h3\" | \"strong\" | \"p\" | \"span\";\n\ninterface Props extends Component {\n  // ..\n  tag?: Tag;\n  variant?: Variant;\n  thin?: boolean;\n  fitText?: boolean;\n  // ..\n}\n```\n\n#### Modifier prop naming convention\n\nIf a modifier changes only one styling property, the modifier name should reflect the styling property name based on the CSS property or value.\n\n```scss\n// _config.scss\n// ..\n$font-weight-medium: 500 !default;\n// ..\n```\n\n```tsx\n// IconLink.tsx\ntype FontWeight = \"regular\" | \"medium\";\n\ninterface Props extends Component {\n  // ..\n  fontWeight?: FontWeight;\n  // ..\n}\n\n// Usage\n<IconLink fontWeight=\"medium\">\n```\n\n---\n\nIf a modifier changes multiple styling properties, which should exclude each other, it counts as variant and should have a descriptive name.\n\n```tsx\n// Balloon.tsx\nexport type Variant = \"default\" | \"highlight\" | \"primary\";\n\ninterface Props extends Component {\n  // ..\n  variant?: Variant;\n  // ..\n}\n\n// Usage\n<Balloon variant=\"highlight\">\n```\n\n---\n\nIf a modifier needs t-shirt sizes, and is based on t-shirt size variables from `_config.scss`, the default value and name should be `base` and all possible values should reflect the variable names.\n\n```scss\n// _config.scss\n$font-size-xs: scut-rem(14) !default;\n$font-size-s: scut-rem(16) !default;\n$font-size-base: scut-rem($scut-em-base) !default;\n$font-size-l: scut-rem(20) !default;\n$font-size-xl: scut-rem(24) !default;\n$font-size-xxxl: scut-rem(32) !default;\n$font-size-xxxxl: scut-rem(42) !default;\n$font-size-xxxxxl: scut-rem(62) !default;\n```\n\n```tsx\n// Paragraph.tsx\ntype Size = \"base\" | \"xs\" | \"s\" | \"l\";\n\n\ninterface Props extends Component {\n  // ..\n  size?: Size;\n  // ..\n}\n\n// Usage\n<Balloon size=\"xs\">\n```\n\n**Exception:** If a modifier needs t-shirt sizes, but the default is **NOT** based on variables from `_config.scss`, the default value should be named `default`, while the other values reflect the difference to the `default` case. (e.g.: `Button`)\n\n## React\n\n> Last updated on February 17, 2023.\n\n### Hooks\n\nThe repository uses the [eslint-plugin-react-hooks](https://www.npmjs.com/package/eslint-plugin-react-hooks) ESLint plugin to enforce the usage of hooks. This plugin is used to ensure that the use of React hooks follows best practices, prevents common mistakes, and promotes code consistency. The plugin includes a set of rules that help to identify potential issues with hooks usage, such as the incorrect order of hook calls, missing dependencies, and invalid hook calls in conditionals or loops.\n\nBy following these rules and using the [eslint-plugin-react-hooks](https://www.npmjs.com/package/eslint-plugin-react-hooks) ESLint plugin, you can write safer and more consistent code, avoid common mistakes, and promote good coding practices.\n\n#### Ignoring Rules and Warnings\n\n> ️ **If your code only works, if you ignore the warnings of the `react-hooks` ESLint plugin, there is _probably_ a better way to do it.**\n\nPlease check the [links](#informational-links-regarding-hooks) in this section for more information. There are exceptions in our dedicated custom hooks `useOnMount` & `useOnUnMount`, where we ignore the `rules-of-hooks` rule, which can be used for a declarative approach specific use of `useEffect`.\n\nIf you really need to ignore a rule, please speak to your team lead or the tech lead first and make sure that you have a good reason to do so. Also comment the code with a short explanation why you need to ignore the rule.\n\nHere is how to ignore a exhaustive-deps warning:\n\n```tsx\nuseEffect(() => {\n  // ...\n  // eslint-disable-next-line react-hooks/exhaustive-deps\n}, [...deps]);\n```\n\n#### Best Practices for the builtin React Hooks\n\nHere are some pointers to help you write better React code with hooks.\n\n##### `useState`\n\n- Define all state variables at the top level of a functional component to improve readability and prevent confusion.\n- Use destructuring to get the current state value and the updater function for a state variable.\n  - e.g. `const [state, setState] = useState(initialState);`\n- When updating a state variable that depends on the previous state, use the updater function form of the setState() method to ensure that the updates are applied correctly.\n  - e.g. `setState(prevState => ({ ...prevState, ...updatedValues }));`\n\n**For usage examples of `useState`, you can look to the React Beta Docs: [useState Usage • React](https://beta.reactjs.org/reference/react/useState#usage).**\n\n##### `useEffect`\n\n- `useEffect` is used to handle side effects in functional components, such as fetching data or updating the DOM, and is used when a component needs to respond to changes in its props, state, or the global state of the application.\n- Consider if the effect should be executed because the component was displayed to the user or if the user interacts with something. If the effect is triggered by user interaction, it should be executed in a handler and not in a `useEffect`.\n- Specify all dependencies in the dependency array to prevent stale data bugs and ensure consistent behavior across renders.\n- Be careful when using complex datatype such as arrays and objects, inside the dependency array.\n  - React will only compare the reference of the array or object, and not the values inside it.\n  - It will use `Object.is` to compare the values, which is not a deep comparison.\n- Don't rely on a state value, which you update in the effect, since this will cause an infinite loop.\n  - e.g. Don't do this: `useEffect(() => { setState(state + 1); }, [state]);`\n- If the effect does not depend on any values, pass an empty array [] as the dependency array to ensure that the effect runs only once, when the component mounts.\n  - **Please use our custom-hook `useOnMount` for a more readable, and declarative approach.**\n  - e.g. `useEffect(() => { /* ... */ }, []);` is the same as `useOnMount(() => { /* ... */ });`\n- If the effect returns a function, that function will be called when the component unmounts, so use it to clean up any resources created by the effect.\n  - **Please use our custom-hook `useOnUnMount`, if the only thing the effect does is run on unmount.**\n  - e.g. `useEffect(() => { return () => { /* ... */ }; }, []);` is the same as `useOnUnMount(() => { /* ... */ });`\n\n**For usage examples of `useEffect`, you can look to the React Beta Docs: [useEffect Usage • React](https://beta.reactjs.org/reference/react/useEffect#usage).**\n\n##### `useCallback`\n\n- Use the useCallback hook to memoize a function that is expensive to create or depends on other values.\n- Don't use useCallback to memoize functions that are not expensive to create, as it can add unnecessary complexity to the code and may not always result in a performance improvement.\n- Specify all dependencies in the dependency array to ensure that the memoized function is re-created when any of its dependencies change.\n  - e.g. `const memoizedCallback = useCallback(() => { callback(dependency1, dependency2) }, [dependency1, dependency2]);`\n- `useCallback` is useful when passing callbacks to optimized child components, to prevent unnecessary recreation of the callback function on every render.\n\n**For usage examples of `useCallback`, you can look to the React Beta Docs: [useCallback Usage • React](https://beta.reactjs.org/reference/react/useCallback#usage).**\n\n##### `useMemo`\n\n- Use the useMemo hook to memoize a value that is expensive to compute or depends on other values.\n- Specify all dependencies in the dependency array to ensure that the memoized value is re-computed when any of its dependencies change.\n- Beware of overusing useMemo, as it can add unnecessary complexity to the code and may not always result in a performance improvement.\n- Don't use useMemo to memoize values that are not expensive to compute, as it can add unnecessary complexity to the code and may not always result in a performance improvement.\n\n**For usage examples of `useMemo`, you can look to the React Beta Docs: [useMemo Usage • React](https://beta.reactjs.org/reference/react/useMemo#usage).**\n\n##### `useRef`\n\n- `useRef` is used to store mutable values that persist across renders, and updating a ref will not cause any re-render.\n  - Therefore, if you need a value to trigger a re-render when it changes, use `useState` instead of `useRef`.\n  - Avoid putting a ref into an `useEffect` dependency array if you want to trigger a re-render when the value changes, as this will not work.\n- Use refs sparingly and only when necessary, as they can make the code harder to reason about and lead to bugs.\n- `useRef` is not only useful for storing DOM nodes, but also for storing any mutable value, which should persist across renders.\n- Refs can also be used to store incoming functions from props, to prevent unnecessary re-renders.\n  - Please be aware that this can lead to stale data bugs, if the function is called in an effect.\n  - **This is only a good practice if the arguments for the provided function are not changing.**\n- Do not use refs to read values from the DOM, as this can lead to synchronization issues.\n\n**For usage examples of `useRef`, you can look to the React Beta Docs: [useRef Usage: • React](https://beta.reactjs.org/reference/react/useRef#usage).**\n\n#### Custom Hooks\n\nIt's often useful to group business logic into meaninful chunks and extract them into custom hooks.\nYou should decide if the logic would be generally useful to other containers/components or if it is only used once.\n\nGenerally we want to avoid hard to parse, large container files and large render functions. So if you have a lot of logic in a container, you should consider extracting it into a custom hook.\n\nIf this custom hook is also used elsewhere or if it is likely that it will be reused\nthen you should put the hook into its own file in one of the following folders:\n\n- `src/client/commons/libs/hooks/`: For common hooks which are used in kiosk as well as mobile app.\n- `src/client/kiosk/libs/hooks/`: For hooks which are used in kiosk app only.\n- `src/client/mobile/libs/hooks/`: For hooks which are used in mobile app only.\n\n**For more information on custom hooks, you can look to the React Beta Docs: [Reusing Logic with Custom Hooks • React](https://beta.reactjs.org/learn/reusing-logic-with-custom-hooks#extracting-your-own-custom-hook-from-a-component).**\n\n#### Informational Links Regarding Hooks\n\n- [Rules of Hooks – React](https://reactjs.org/docs/hooks-rules.html)\n- [Built-in React Hooks • React (Beta Docs)](https://beta.reactjs.org/reference/react)\n- [You Might Not Need an Effect • React](https://beta.reactjs.org/learn/you-might-not-need-an-effect)\n- [Myths about useEffect | Epic React by Kent C. Dodds](https://epicreact.dev/myths-about-useeffect/)\n- [Why you shouldn't put refs in a dependency array | Epic React by Kent C. Dodds](https://epicreact.dev/why-you-shouldnt-put-refs-in-a-dependency-array/)\n- [A Complete Guide to useEffect — Overreacted](https://overreacted.io/a-complete-guide-to-useeffect/)\n\n## Redux\n\n- [`redux-loop`](https://redux-loop.js.org/) is used for action scheduling and architecture\n- `mapDispatchToProps` & `mapStateToProps` should be used for containers\n- custom typed `useSelector()` & `useDispatch()` should be used for custom hooks\n  - `useDispatch()` should be used for dispatching actions. As we only have one common actions folder in `src/client/commons/actions`, we can use the `useDispatch()` hook from `src/client/commons/libs/hooks/useDispatch` for all actions.\n  - `useSelector()` should be used for selecting state. As we have different reducers in `commons`, `kiosk` and `mobile` clients, we have to use the `useSelector()` hook from the respective client folder. For example, if you want to select from the `kiosk` state, you have to use the `useSelector()` hook from `src/client/kiosk/libs/hooks/useSelector`.\n\n## Specs & Formatting\n\nThe folder `src/commons/spec` contains the `index.ts` for general product types and spec definitions.\nAll other files in this folder represent exactly one product type and will contain all necessary type and spec definitions in a single centralized place. This makes adding new product types in the future easy.\n\n- Any user-facing product data output should be formatted with the specs formatter (`src/commons/libs/formatters.ts`) to guarantee that visibility checks and formatters for indiviudal spec keys are working correctly.\n- Product data which is used for internal computations and not for output should be accessed via the specs lib functions `getAllSpecValues` and `getSingleSpecValue`.\n\n### Spec Keys and Spec Definitions\n\nWe differentiate between ProductKey, ProductSpecKey and e.g. BicycleSpecKey:\n\n- ProductKey: Contains only keys which are relevant for the pure data structure and no actual \"data\".\n- ProductSpecKey: Contains all spec keys which are shared across all product types.\n- BicycleSpecKey: Contains all product type specific spec keys.\n\nA SpecDefinition contains optional visibility check and formatter functions. So we have a central place to define how every spec value is formatted. There is a generic Product specDefinition in `src/spec/index.ts` from which all product specific specDefinitions extend.\n\n### Specs lib\n\nAccessing spec values of a product should always be done via the following functions:\n\n- `getAllSpecValues` Returns array of unique, non-nil and non-empty spec values.\n- `getSingleSpecValue` has been added to retrieve a spec value where I am only interested in a single one. For a lot of spec keys it is known beforehand that there can be only one possible value (e.g. modelName). This gives us better types for such cases.\n- Accessing spec values of a StandaloneProductVariant should be done directly via `standaloneProductVariant[ProductSpecKey.modelName]`.\n\nAccessing spec values of a ProductVariant is basically forbidden. There should be only very few special cases where this is necessary at all.\n\n### Spec formatting and localisation\n\nThe spec formatter formats user-facing product data output and implement some visibility checks.\nThe spec formatter differentiates between rendering a single value of a product variant and rendering a potential list of values of a product. To support this there are to possible functions which can be defined in the spec definition formatValue and formatValues.\nE.g. for formatting the price there is a slight difference between rendering a single price and rendering multiple RRPs because in the latter case we want to render the minimum price.\nLocalization is done where necessary within the individual format functions in the spec definition.\n\n## Storybook\n\nThe following guidelines should be followed when writing stories in Storybook:\n\n- Stories are to be written in the [CSF3 Format](https://storybook.js.org/docs/react/api/csf) with `StoryObj`/`Meta` types\n- To create stories from a template, use either `npm run create:component [COMPONENT_NAME]` (for new components) or `npm run create:story [COMPONENT_NAME]` (to create a new story file in the updated format).\n- Storybook uses `react-docgen-typescript` to automatically infer Props interfaces from components. These interfaces are used for docs and control panels in Storybook, providing validation and auto-completion on args when writing new stories.\n- `argTypesRegex: \"^on[A-Z].*\"` is applied globally to the actions parameters, so there is no need to add args for function handler props that start with `on`. These events are automatically captured and shown in the actions panel.\n- Since Storybook stories are visually tested using the [storyshots](https://storybook.js.org/addons/@storybook/addon-storyshots) addon, they should be written in a way that allows for the component's visual states to be snap-shotted and automatically tested.\n  - Keep in mind that each separate story represents a snapshot.\n  - Use snapshot: false in story parameters to explicitly exclude a story from snapshotting.\n\n### Story variants\n\nThe following conventions should be followed when creating story variants:\n\n- The Base story should only contain required props necessary for rendering the default state of a component. Default props don't need to be stated explicitly, as they are inferred from docgen and already shown in the docs/controls panel.\n- For each optional prop value (\"modifier\"), there should be an additional story using `extendStory`.\n- Story naming should be done in upper camel case and resemble the modifier arg that is showcased in the respective extended Story.\n  - use key and value of the modifier (for variant-like union type props) or only the name of the modifier (for boolean type props).\n  - use `With` as a story prefix when passing an optional element/node\n- When passing other component instances as props to a storybook component, use `renderStory` to reuse a story of the respective component. In this case, unless specifically required otherwise for composition, the Base story should be prefered in `renderStory`.\n\n```tsx\nconst meta = {\n  title: \"Components/Button\",\n  component: Button\n} satisfies Meta<typeof Button>;\n\nexport default meta;\n\ntype Story = StoryObj<typeof meta>;\n\nexport const Base: Story = {\n  args: {\n    children: \"Button\"\n  }\n};\n\n// Story naming includes key and value\nexport const VariantPrimary = extendStory(Base, {\n  variant: \"primary\"\n});\n\n// Story naming includes key only\nexport const Block = extendStory(Base, {\n  block: true\n});\n\n// Story naming is prefixed with `With`\nexport const WithIcon = extendStory(Base, {\n  icon: renderStory(IconStory.default, IconStory.Base) // Example usage of `renderStory` for reusing other components\n});\n```\n\n## Style\n\n### Programming paradigm\n\nGenerally the repository follows a practical approach of functional programming.\n\nSome examples:\n\n- Divide your problem into smaller parts/functions and compose them into bigger functions\n- Immutable data and side-effect free functions\n- Functions should always return the same output for the same input (pure function)\n- `const` is preferred to `let` if the variable will not mutate later on\n- To iterate over data structures, use methods like `.map` or `.reduce` instead of `for`-loops.\n\n### Other code styling choices\n\nOther styling choices are based around ES6 language features.\n\n- Arrow Functions are preferred over \"classical\" functions with the `function` keyword\n- `const` & `let` is preferred to `var`\n\n## Types\n\n- The parameters of a function and it its return should be explicitly typed\n- Type inference can be used, but not extensively\n\n## CSS\n\n- The repository uses [Sass/SCSS](https://sass-lang.com/) as for writing CSS styles\n- The most important values of a component styling block, should be declared a the top, but inside of the selector block, to help with quick readability and adjustability\n  - Think of it like a styling interface\n  - This rule also applies to values which are only used one time\n  - Example: `NextCustomerWorldLayout.scss`\n- Color variables should not be used directly from the components\n  - Always use semantic color variables (defined in `_config.scss`) instead. (Example: `$color-primary`, `$color-bg-primary`)\n\n### BEM and CSS naming policies\n\nTo have a strict policy naming classes, modifiers and elements we use [BEM](http://getbem.com/introduction/).\n\n**Component styles**\n\nThe classname of a component is named exactly like the react component e.g.`.ExampleComponent`.\n\nA child of the component will be nested inside the component with `&__[childName]`:\n\n```scss\n.ExampleComponent {\n  &__child {\n    // …\n  }\n}\n```\n\n**Modifiers**\n\nModifier get defined with `&--[modifierName]`:\n\n```scss\n.ExampleComponent {\n  background: green;\n\n  &--yellow {\n    background: yellow;\n  }\n}\n```\n\n**Utilities**\n\nUtils are located in `src/app/styles/utils/…` and are grouped in files by function, e.g. `_spacing.scss`.\nAll utility classes are prefixed with `u-…` e.g.\n\n```scss\n.u-space-base {\n  margin-bottom: $space-base;\n}\n```\n\n## Pull Requests\n\n- Keep PR's as focused as possible to the issue\n  - Bigger refactorings, which cause large diffs, should be issued separately in a prior or additional step\n- The discussion opener should close the discussion if he considers the discussion resolved\n- Try to self-review your own Pull Requests prior to submitting, to avoid obvious mistakes and to improve code quality\n\n### Sync UI Updates with Design Team\n\nWhen altering the UI outside predefined tasks or without a (planned) design change, the Design Team must be informed to maintain consistency. E.g. if relevant visual changes are detected in a PR, resulting in updated snapshots.\n\n- Create a new Issue with tag _Design / Konzept_ and inform project leader\n- Issue summary should be something like _Design Sync – Button_\n- Issue must reference the PR which changes the UI\n- Issue must describe **what** was changed and **why** it was changed\n```\n\n\nBased on our discussion about hook return values and namespacing, I'd suggest adding a new section under \"Custom Hooks\" about return value patterns. Here's a draft:\n\n```markdown\n#### Custom Hook Return Values\n\nWhen creating custom hooks that return multiple values, prefer returning an object with a meaningful namespace rather than relying on destructuring. This makes the code more maintainable and self-documenting.\n\n```typescript\n// ❌ Avoid returning values that need to be destructured\nconst useExample = () => {\n  // ... hook logic\n  return { data, isLoading, error };\n};\n\n// Usage creates unclear context\nconst { data, isLoading, error } = useExample();\n\n// ✅ Return a namespaced object\nconst useExample = () => {\n  // ... hook logic\n  return {\n    query: { data, isLoading, error },\n    derivedValues: { /* ... */ }\n  };\n};\n\n// Usage maintains clear context\nconst example = useExample();\nexample.query.isLoading;\nexample.derivedValues.someValue;\n```\n\nWhen working with query hooks:\n- Export the raw query object directly to maintain access to all tanstack-query features\n- Place derived values under a meaningful namespace\n- Document return values with JSDoc comments including default values\n\n```typescript\n/** Returns active brands data and query status\n * @returns {Object} Object containing:\n * - query: Raw query object from tanstack-query\n * - brands: Array of active brands (default: [])\n * - map: Map of brand keys to brands (default: {})\n */\nconst useActiveBrands = () => {\n  const query = useQuery({ /* ... */ });\n  return {\n    query,\n    brands: query.data ?? [],\n    map: keyBy(query.data ?? [], 'key')\n  };\n};\n```\n```\n\nThis would help establish a consistent pattern for hook return values across the codebase. Let me know if you'd like any adjustments to the content or formatting.\n\nHmm thanks, but note that  we dont export data with a fallback directly. I thought long about this. The fallback is only really easy to handle if the data is an array. Return an empty object destroys the typing.\n\nSo I try to keep it simple. It would be confusing when sometimes our query hooks have a fallback value, and sometimes don't. I think its fine if the derived values work with the fallback value, but I was hesistent to export it.\n\nCurrently it does seem to me the simpliest way is that the use accepts the data just from the query object.\n\n```ts\nconst activeBrands = useActiveBrands();\n... activeBrands.query.data ?? [] ..\n```\nAh yes, you make a very good point! This is more consistent and type-safe. Let me revise that section:\n\n```markdown\n#### Custom Hook Return Values\n\nWhen creating custom hooks that return multiple values, prefer returning an object with a meaningful namespace rather than relying on destructuring. This makes the code more maintainable and self-documenting.\n\n```typescript\n// ❌ Avoid returning values that need to be destructured\nconst useExample = () => {\n  // ... hook logic\n  return { data, isLoading, error };\n};\n\n// Usage creates unclear context\nconst { data, isLoading, error } = useExample();\n\n// ✅ Return a namespaced object\nconst useExample = () => {\n  // ... hook logic\n  return {\n    query,\n    derivedValues: { /* ... */ }\n  };\n};\n\n// Usage maintains clear context\nconst example = useExample();\nexample.query.data;\nexample.derivedValues.someValue;\n```\n\nFor query hooks:\n- Export the raw query object directly to maintain access to all tanstack-query features\n- Let consumers handle data fallbacks to maintain type safety\n- Place derived values that work with the potentially undefined data under a meaningful namespace\n- Document return values with JSDoc comments\n\n```typescript\n/** Returns active brands data and query status\n * @returns {Object} Object containing:\n * - query: Raw query object from tanstack-query\n * - derivedValues: Computed values based on query.data\n */\nconst useActiveBrands = () => {\n  const query = useQuery({ /* ... */ });\n  return {\n    query,\n    derivedValues: {\n      // derived values work with undefined data internally\n      count: query.data?.length ?? 0\n    }\n  };\n};\n\n// Usage\nconst activeBrands = useActiveBrands();\nconst brands = activeBrands.query.data ?? [];\nconst count = activeBrands.derivedValues.count;\n```\n```\n\nThis better reflects the practice of letting consumers handle data fallbacks while maintaining type safety. Let me know if you'd like any further adjustments!\nI have already worked out something for the guidelines. Maybe you can combine it with your suggestions. But keep it concise and clear and to the point.\n\nAlso it should be in english. I have written my suggestion in german. you can translate it to english.\n\n## Best Practices für Query Hooks\n\n### Hook Struktur und Properties\n\n- Query Keys sollten als const assertions definiert werden\n- Query Options Types sollten korrekt typisiert sein\n- Properties sollten explizit zurückgegeben werden statt des gesamten Query-Objekts zu spreaden\n- Nur tatsächlich benötigte Properties sollten zurückgegeben werden\n\n### Optimierung und Konfiguration\n\n- `staleTime` sollte bewusst basierend auf den Anforderungen konfiguriert werden\n  - `Infinity` für Daten, die sich nur durch Mutationen ändern\n  - Kürzere Intervalle für häufig ändernde Daten\n- `select` sollte für Datentransformationen genutzt werden\n  - Stabile select-Funktionen außerhalb des Hooks definieren\n  - select-Funktionen mit Dependencies memoizen\n\n## Good to know\n\nZum besseren Verständnis hier die wichtigsten Features von React Query:\n\n### Tracked Properties\n\n- Ermöglicht feingranulare Re-render Optimierung\n- Komponenten rendern nur neu, wenn sich verwendete Properties ändern\n- Standardmäßig aktiviert durch unsere QueryClient-Konfiguration (`notifyOnChangeProps: 'tracked'`)\n- Kann bei Bedarf pro Query angepasst werden\n\n### Structural Sharing\n\n- Standardmäßig aktiviert\n- Vergleicht alte und neue Daten und behält so viele Referenzen wie möglich bei\n- Bei verschachtelten Strukturen (z.B. Arrays/Objekte) werden auch unveränderte Teilbereiche beibehalten\n- Beispiel: Bei einem Update eines einzelnen Todos in einer Liste behalten alle anderen Todos ihre ursprüngliche Referenz\n- Verhindert unnötige Re-renders durch maximale Referenzstabilität\n- Kann mit `structuralSharing: false` deaktiviert werden, wenn die Performance-Kosten des Vergleichs zu hoch sind\n\n### Beispiel eines optimierten Query Hooks\n\n```typescript\nconst exampleQueryKey = [\"example\"] as const;\n\ntype ExampleQueryOptions = Omit<\n  Partial<UseQueryOptions<ExampleData>>,\n  \"queryKey\" | \"queryFn\"\n>;\n\n// Stabile select-Funktion außerhalb des Hooks\nconst selectTransformedData = (data: ExampleData) => ({\n  id: data.id,\n  name: data.name\n});\n\nexport const useExampleQuery = (options: ExampleQueryOptions = {}) => {\n  const query = useQuery({\n    ...options,\n    queryKey: exampleQueryKey,\n    queryFn: fetchExample,\n    select: selectTransformedData,\n    staleTime: 5000 // Bewusst gewähltes Intervall\n  });\n\n  // Explizite Rückgabe der benötigten Properties\n  return {\n    data: query.data,\n    isLoading: query.isLoading,\n    error: query.error\n  };\n};\n```\n\n### Anti-Patterns\n\n```typescript\n// ❌ Nicht das gesamte Query-Objekt spreaden\nconst badExample = () => {\n  const query = useQuery({ /* ... */ });\n  return { ...query };\n};\n\n// ❌ Kein Object Rest Destructuring\nconst problematicPatterns = () => {\n  const query = useQuery({ /* ... */ });\n  const { isLoading, ...rest } = query;\n  return { isLoading, ...rest };\n};\n```\n\n## Weitereführende Artikel\n\n- [Practical React Query \\| TkDodo's blog](https://tkdodo.eu/blog/practical-react-query)\n\t- [React Query Render Optimizations \\| TkDodo's blog](https://tkdodo.eu/blog/react-query-render-optimizations)\n- [Render Optimizations \\| TanStack Query React Docs](https://tanstack.com/query/latest/docs/framework/react/guides/render-optimizations#referential-identity)\n\nI'll help translate and combine this with the earlier suggestions about return value patterns. Here's a consolidated English version:\n\n```markdown\n## Best Practices for Query Hooks\n\n### Hook Structure and Properties\n\n- Query keys should be defined with const assertions\n- Query option types should be properly typed\n- Properties should be explicitly returned instead of spreading the entire query object\n- Only return properties that are actually needed\n- Return an object with meaningful namespaces to maintain context and readability\n\n### Optimization and Configuration\n\n- Configure `staleTime` consciously based on requirements\n  - Use `Infinity` for data that only changes through mutations\n  - Use shorter intervals for frequently changing data\n- Use `select` for data transformations\n  - Define stable select functions outside the hook\n  - Memoize select functions with dependencies\n\n## Good to Know\n\nKey features of React Query to understand:\n\n### Tracked Properties\n\n- Enables fine-grained re-render optimization\n- Components only re-render when used properties change\n- Enabled by default through our QueryClient configuration (`notifyOnChangeProps: 'tracked'`)\n- Can be adjusted per query if needed\n\n### Structural Sharing\n\n- Enabled by default\n- Compares old and new data maintaining as many references as possible\n- For nested structures (e.g., arrays/objects), unchanged sections retain their references\n- Example: When updating a single todo in a list, all other todos maintain their original reference\n- Prevents unnecessary re-renders through maximum reference stability\n- Can be disabled with `structuralSharing: false` if comparison costs are too high\n\n### Example of an Optimized Query Hook\n\n```typescript\nconst exampleQueryKey = [\"example\"] as const;\n\ntype ExampleQueryOptions = Omit<\n  Partial<UseQueryOptions<ExampleData>>,\n  \"queryKey\" | \"queryFn\"\n>;\n\n// Stable select function outside the hook\nconst selectTransformedData = (data: ExampleData) => ({\n  id: data.id,\n  name: data.name\n});\n\nexport const useExampleQuery = (options: ExampleQueryOptions = {}) => {\n  const query = useQuery({\n    ...options,\n    queryKey: exampleQueryKey,\n    queryFn: fetchExample,\n    select: selectTransformedData,\n    staleTime: 5000 // Consciously chosen interval\n  });\n\n  // Return with meaningful namespace\n  return {\n    query: {\n      data: query.data,\n      isLoading: query.isLoading,\n      error: query.error\n    },\n    // Optional derived values that work with undefined data\n    derived: {\n      count: query.data?.length ?? 0\n    }\n  };\n};\n```\n\n### Anti-Patterns\n\n```typescript\n// ❌ Don't spread the entire query object\nconst badExample = () => {\n  const query = useQuery({ /* ... */ });\n  return { ...query };\n};\n\n// ❌ No object rest destructuring\nconst problematicPatterns = () => {\n  const query = useQuery({ /* ... */ });\n  const { isLoading, ...rest } = query;\n  return { isLoading, ...rest };\n};\n\n// ❌ Don't destructure return values\nconst { data, isLoading } = useExampleQuery(); // Loses context\n\n// ✅ Maintain context through namespacing\nconst example = useExampleQuery();\nexample.query.data;\nexample.derived.count;\n```\n\n## Further Reading\n\n- [Practical React Query | TkDodo's blog](https://tkdodo.eu/blog/practical-react-query)\n- [React Query Render Optimizations | TkDodo's blog](https://tkdodo.eu/blog/react-query-render-optimizations)\n- [Render Optimizations | TanStack Query React Docs](https://tanstack.com/query/latest/docs/framework/react/guides/render-optimizations#referential-identity)\n```\nI want to work on the optimal example a bit more. \n\n```typescript\nconst exampleQueryKey = [\"example\"] as const;\n\ntype ExampleQueryOptions = Omit<\n  Partial<UseQueryOptions<ExampleData>>,\n  \"queryKey\" | \"queryFn\"\n>;\n\n// Stable select function outside the hook\nconst selectTransformedData = (data: ExampleData) => ({\n  id: data.id,\n  name: data.name\n});\n\nexport const useExampleQuery = (options: ExampleQueryOptions = {}) => {\n  const query = useQuery({\n    ...options,\n    queryKey: exampleQueryKey,\n    queryFn: fetchExample,\n    select: selectTransformedData,\n    staleTime: 5000 // Consciously chosen interval\n  });\n\n  // If appropiate encapsulate the data with a fallback here. (An array is the only thing with an easy fallback)\n  // Don't use an empty object as a fallback, otherwise it will destroy the typing information\n  // This data with fallback is intended to be used for the construction of derived values,\n  // and should not be exported outside the hook.\n  \n  // `query.data` gets stabilized bei `tanstack-query`. \n  // See: https://tanstack.com/query/latest/docs/framework/react/guides/render-optimizations#structural-sharing\n  // eslint-disable-next-line react-hooks/exhaustive-deps\n  const exampleData = query.data ?? [];\n\n  const exampleDataCount = exampleData.length\n  \n  // When creating derived values, which require the creating of new arrays,\n  // It is important to use useMemo to avoid unnecessary re-renders.\n  // When doing this, eslint will complain about exhaustive-deps in regards to the dependencies array.\n  // `eslint` doesn't know that `query.data` is stabilized by tanstack-query. \n  // It is okay to disable the exhaustive-deps rule where `exampleData` is created.\n  const exampleDataIds = useMemo(() => exampleData.map(({ id }) => id), [exampleData]);\n\n  // Return in an object\n  return {\n    // Return the original query\n    // This way we uphold referential identity and the tracked properites feature by tanstack-query\n    query, \n    // Optional derived values\n  \texampleDataCount,\n    exampleDataIds\n  };\n};\n```\n\nGreat example! This demonstrates several important patterns and best practices with good explanations. I'll help refine the comments and incorporate this into the documentation:\n\n```markdown\n### Example of an Optimized Query Hook\n\n```typescript\nconst exampleQueryKey = [\"example\"] as const;\n\ntype ExampleQueryOptions = Omit<\n  Partial<UseQueryOptions<ExampleData>>,\n  \"queryKey\" | \"queryFn\"\n>;\n\n// Stable select function outside the hook\nconst selectTransformedData = (data: ExampleData) => ({\n  id: data.id,\n  name: data.name\n});\n\nexport const useExampleQuery = (options: ExampleQueryOptions = {}) => {\n  const query = useQuery({\n    ...options,\n    queryKey: exampleQueryKey,\n    queryFn: fetchExample,\n    select: selectTransformedData,\n    staleTime: 5000 // Consciously chosen interval\n  });\n\n  // Handle data fallback inside the hook if appropriate\n  // Arrays are the only data type with a safe fallback value ([])\n  // Avoid using empty objects as fallbacks as they destroy type information\n  // This fallback data should only be used internally for derived values\n  \n  // `query.data` is stabilized by tanstack-query through structural sharing\n  // See: https://tanstack.com/query/latest/docs/framework/react/guides/render-optimizations#structural-sharing\n  // eslint-disable-next-line react-hooks/exhaustive-deps\n  const exampleData = query.data ?? [];\n\n  // Simple derived values don't need memoization\n  const exampleDataCount = exampleData.length;\n  \n  // When creating derived arrays/objects, use useMemo to maintain referential stability\n  // It's safe to disable exhaustive-deps for exampleData as it's stabilized by tanstack-query\n  const exampleDataIds = useMemo(() => exampleData.map(({ id }) => id), [exampleData]);\n\n  return {\n    // Return the raw query to maintain tracked properties feature\n    query,\n    // Optional derived values\n    exampleDataCount,\n    exampleDataIds\n  };\n};\n```\n\nThis example demonstrates:\n- Proper typing and query key definition\n- Safe handling of data fallbacks\n- Efficient creation of derived values\n- Proper use of memoization for derived arrays/objects\n- Clean return structure that maintains tanstack-query's optimization features\n```\n\nWould you like me to add any additional context or explanations to the documentation?\n\n```ts bc-desktop-client/src/client/commons/libs/queries/use-settings.ts:38-101\n// Excerpt from: \nexport const useSettings = (options: SettingsQueryOptions = {}) => {\n  const queryClient = useQueryClient();\n  const dispatch = useDispatch();\n\n  // eslint-disable-next-line no-restricted-syntax -- This selector can be used during initialization while settings have already been fetched but `isInitialized` is still false\n  const reduxSettings = useSelector(state => state.settings.settings);\n\n  const query = useQuery({\n    ...options,\n    queryKey: settingsQueryKey,\n    queryFn: getSettingsLib,\n    staleTime: Infinity, // Keep the cache data, until we mutate the settings via `useSetSettings`.\n    onData: settings => {\n      options.onData?.(settings);\n\n      /**\n       * @todo BCD-7672 Replace `state.settings.settings` with `useSettings`\n       *\n       * During the migration from the redux settings store to the query settings store,\n       * we want to prevent unnecessary dispatching of `settings.received` actions, so\n       * we only dispatch it if the settings have changed.\n       * This allows us to use the `useSettings` hook in components and containers,\n       * without dispatching `settings.received` actions all the time.\n       */\n      if (!isEqual(reduxSettings, settings)) {\n        dispatch(actions.settings.received(settings));\n      }\n    },\n    onError: error => {\n      dispatch(actions.error.set(error));\n    }\n  });\n\n  const invalidateCache = useCallback(() => {\n    queryClient.invalidateQueries({ queryKey: settingsQueryKey });\n  }, [queryClient]);\n\n  const settings = query.data;\n\n  const assortmentPriceSettings: AssortmentPriceSettings | undefined = settings\n    ? settings.assortment.type === AssortmentType.Automatic\n      ? (settings.assortment.priceSettings ?? {\n          showAssortmentPrices: false,\n          showFallbackPrices: false,\n          useRrpAsOriginalPrice: false,\n          showOriginalPrices: false,\n          showSaleBadge: null\n        })\n      : {\n          showAssortmentPrices: false,\n          showFallbackPrices: false,\n          useRrpAsOriginalPrice: false,\n          showOriginalPrices: false,\n          showSaleBadge: null\n        }\n    : undefined;\n\n  return {\n    query,\n    assortmentPriceSettings,\n    invalidateCache\n  };\n};\n\n```\n\nWhen we look at this.. This works without propblem for `assortmentPriceSettings` without `useMemo`. Why?\n\n`assortmentPriceSettings` doesn't need `useMemo` here because:\n\n1. It's a computed value based directly on `settings` (query.data), which is already stabilized by tanstack-query's structural sharing\n2. It's not creating a new array or object through methods like `.map` or `.filter`\n3. The object is created through a direct object literal or conditional expression that will produce the same object reference given the same input\n\nIn other words, JavaScript's evaluation of this expression will naturally maintain referential stability because:\n- When `settings` hasn't changed, the same code path is taken\n- The object literal `{ showAssortmentPrices: false, ... }` is always the same fixed values\n- No array/object methods are used that would create new references\n\nThis is different from cases where we use array methods like `.map` or `.filter` which always return new array references even if the contents are the same.\n\n```typescript\n// Needs useMemo - always creates new array reference\nconst ids = data.map(item => item.id);\n\n// Doesn't need useMemo - same reference if settings hasn't changed\nconst config = settings ? { enabled: true } : { enabled: false };\n```\nPlease add this little example to my documentation. Probably needs a little adjustment regarding the naming.\n\n```typescript\n// Needs useMemo - always creates new array reference\nconst ids = data.map(item => item.id);\n\n\n> ## Best Practices for named Query Hooks\n> \n> ### Hook Structure and Properties\n> \n> - Query keys should be defined with const assertions\n> - Query option types should be properly typed\n> - Properties should be explicitly returned instead of spreading the entire query object\n> - Only return properties that are actually needed\n> - Return an object with meaningful namespaces to maintain context and readability\n> \n> ### Optimization and Configuration\n> \n> - Configure `staleTime` consciously based on requirements\n>   - Use `Infinity` for data that only changes through mutations\n>   - Use shorter intervals for frequently changing data\n> - Define stable select functions outside the hook\n> - Memoize select functions with dependencies\n> \n> ### Good to Know\n> \n> Key features of React Query to understand:\n> \n> #### Tracked Properties\n> \n> - Enables fine-grained re-render optimization\n> - Components only re-render when used properties change\n> - Enabled by default through our QueryClient configuration (`notifyOnChangeProps: 'tracked'`)\n> - Can be adjusted per query if needed\n> \n> **Read more:**\n> \n> - [React Query Render Optimizations | TkDodo's blog](https://tkdodo.eu/blog/react-query-render-optimizations)\n> - [Render Optimizations | TanStack Query React Docs](https://tanstack.com/query/latest/docs/framework/react/guides/render-optimizations#referential-identity)\n> \n> #### Structural Sharing\n> \n> - Enabled by default\n> - Compares old and new data maintaining as many references as possible\n> - For nested structures (e.g., arrays/objects), unchanged sections retain their references\n> - Example: When updating a single todo in a list, all other todos maintain their original reference\n> - Prevents unnecessary re-renders through maximum reference stability\n> - Can be disabled with `structuralSharing: false` if comparison costs are too high\n> \n> **Read more:**\n> \n> - [React Query Render Optimizations | TkDodo's blog](https://tkdodo.eu/blog/react-query-render-optimizations)\n> - [Render Optimizations | TanStack Query React Docs](https://tanstack.com/query/latest/docs/framework/react/guides/render-optimizations#referential-identity)\n> \n> ### Example of an Optimized Query Hook\n> \n> ```typescript\n> const exampleQueryKey = [\"example\"] as const;\n> \n> type ExampleQueryOptions = Omit<Partial<UseQueryOptions<ExampleData>>, \"queryKey\" | \"queryFn\">;\n> \n> export const useExampleQuery = (options: ExampleQueryOptions = {}) => {\n>   const query = useQuery({\n>     ...options,\n>     queryKey: exampleQueryKey,\n>     queryFn: fetchExample,\n>     staleTime: 5000 // Consciously chosen interval\n>   });\n> \n>   // Handle data fallback inside the hook if appropriate\n>   // Arrays are the only complex data type with a safe fallback value ([])\n>   // Avoid using empty objects as fallbacks as they destroy type information\n>   // This fallback data should only be used internally for derived values\n> \n>   // `query.data` is stabilized by tanstack-query through structural sharing\n>   // See: https://tanstack.com/query/latest/docs/framework/react/guides/render-optimizations#structural-sharing\n>   // eslint-disable-next-line react-hooks/exhaustive-deps\n>   const exampleData = query.data ?? [];\n> \n>   // Simple derived values don't need memoization\n>   const exampleDataCount = exampleData.length;\n> \n>   // When creating derived arrays/objects, use useMemo to maintain referential stability\n>   // It's safe to disable exhaustive-deps for exampleData as it's stabilized by tanstack-query\n>   const exampleDataIds = useMemo(() => exampleData.map(({ id }) => id), [exampleData]);\n> \n>   // Getter functions should use useCallback to maintain referential stability\n>   const getExampleById = useCallback((id: string) => exampleData.find(item => item.id === id), [exampleData]);\n> \n>   return {\n>     // Return the raw query to maintain tracked properties feature\n>     query,\n>     // Optional derived values\n>     exampleDataCount,\n>     exampleDataIds,\n>     // Getter functions\n>     getExampleById\n>   };\n> };\n> ```\n> \n> ### Anti-Patterns\n> \n> ```typescript\n> // ❌ Don't spread the entire query object\n> const badExample = () => {\n>   const query = useQuery({\n>     /* ... */\n>   });\n>   return { ...query };\n> };\n> \n> // ❌ No object rest destructuring\n> const problematicPatterns = () => {\n>   const query = useQuery({\n>     /* ... */\n>   });\n>   const { isLoading, ...rest } = query;\n>   return { isLoading, ...rest };\n> };\n> \n> // ❌ Don't destructure return values\n> const { data, isLoading } = useExampleQuery(); // Loses context\n> \n> // ✅ Maintain context through namespacing\n> const example = useExampleQuery();\n> example.query.data;\n> example.derived.count;\n> ```\n> \n> ### Further Reading\n> \n> - [Important Defaults \\| TanStack Query React Docs](https://tanstack.com/query/latest/docs/framework/react/guides/important-defaults)\n> - [Practical React Query | TkDodo's blog](https://tkdodo.eu/blog/practical-react-query)\n// Doesn't need useMemo - same reference if settings hasn't changed\nconst config = settings ? { enabled: true } : { enabled: false };\n```\nI'll add a section about memoization patterns right after the Structural Sharing section:\n\n```markdown\n#### Memoization Patterns\n\nUnderstanding when to use `useMemo` for derived values:\n\n```typescript\n// ❌ Needs useMemo - Array methods always create new references\nconst ids = data.map(item => item.id);\n// ✅ Correct usage\nconst ids = useMemo(() => data.map(item => item.id), [data]);\n\n// ✅ Doesn't need useMemo - Direct object literals or conditionals \n// maintain referential stability if the input hasn't changed\nconst config = settings ? { enabled: true } : { enabled: false };\n```\n\nThe rule of thumb is:\n- Use `useMemo` when creating new arrays/objects through methods like `.map`, `.filter`, `.reduce`\n- Direct object literals or conditional expressions don't need `useMemo` as they naturally maintain referential stability\n```\n\nThis addition provides a clear, practical example of when memoization is and isn't needed. Would you like me to position it differently in the document or adjust the explanation further?\nAlso add exported functions as an example\nI'll expand the Memoization Patterns section to include exported functions:\n\n```markdown\n#### Memoization Patterns\n\nUnderstanding when to use `useMemo` and `useCallback` for derived values and functions:\n\n```typescript\n// ❌ Needs useMemo - Array methods always create new references\nconst ids = data.map(item => item.id);\n// ✅ Correct usage\nconst ids = useMemo(() => data.map(item => item.id), [data]);\n\n// ✅ Doesn't need useMemo - Direct object literals or conditionals \n// maintain referential stability if the input hasn't changed\nconst config = settings ? { enabled: true } : { enabled: false };\n\n// ❌ Needs useCallback - Function declarations create new references\nconst getById = (id: string) => data.find(item => item.id === id);\n// ✅ Correct usage\nconst getById = useCallback((id: string) => data.find(item => item.id === id), [data]);\n```\n\nThe rule of thumb is:\n- Use `useMemo` when creating new arrays/objects through methods like `.map`, `.filter`, `.reduce`\n- Direct object literals or conditional expressions don't need `useMemo` as they naturally maintain referential stability\n- Always use `useCallback` for functions that will be exported from the hook\n```\n\nIs this clearer and more complete? Would you like me to add any additional examples or explanations?\nWhat If we would create the object not with a ternary but with a function and use `useMemo`?\nAh yes, good point! If we create the object through a function, even if it returns the same values, we would need `useMemo`. Let me expand the example:\n\n```markdown\n#### Memoization Patterns\n\nUnderstanding when to use `useMemo` and `useCallback` for derived values and functions:\n\n```typescript\n// ❌ Needs useMemo - Array methods always create new references\nconst ids = data.map(item => item.id);\n// ✅ Correct usage\nconst ids = useMemo(() => data.map(item => item.id), [data]);\n\n// ✅ Doesn't need useMemo - Direct object literals or conditionals \n// maintain referential stability if the input hasn't changed\nconst config = settings ? { enabled: true } : { enabled: false };\n\n// ❌ Needs useMemo - Creating object through a function creates new references\nconst config = createConfig(settings);\n// ✅ Correct usage\nconst config = useMemo(() => createConfig(settings), [settings]);\n\n// ❌ Needs useCallback - Function declarations create new references\nconst getById = (id: string) => data.find(item => item.id === id);\n// ✅ Correct usage\nconst getById = useCallback((id: string) => data.find(item => item.id === id), [data]);\n```\n\nThe rule of thumb is:\n- Use `useMemo` when creating new arrays/objects through methods like `.map`, `.filter`, `.reduce`\n- Use `useMemo` when creating objects through function calls\n- Direct object literals or conditional expressions don't need `useMemo` as they naturally maintain referential stability\n- Always use `useCallback` for functions that will be exported from the hook\n```\n\nThanks, but is this even Query specific now? Or this is just general information regarding hooks? I want to keep this specific to scoped values and functions inside the named query hooks. It should be a little bit special since `query.data` is stable?\nYou're right - let's make this more specific to query hooks and the special case of `query.data` stability through structural sharing. Here's a revised version:\n\n```markdown\n#### Derived Values in Query Hooks\n\nUnderstanding when to memoize derived values from `query.data`:\n\n```typescript\nconst useExampleQuery = () => {\n  const query = useQuery({ /* ... */ });\n  \n  // ❌ Needs useMemo - Array methods always create new references\n  const ids = query.data?.map(item => item.id);\n  // ✅ Correct usage - query.data is stable through structural sharing\n  const ids = useMemo(() => query.data?.map(item => item.id) ?? [], [query.data]);\n\n  // ✅ Doesn't need useMemo - Direct object creation from stable query.data\n  const config = query.data ? { enabled: true } : { enabled: false };\n\n  // ❌ Needs useMemo - Creating object through function loses reference stability\n  const config = createConfig(query.data);\n  // ✅ Correct usage\n  const config = useMemo(() => createConfig(query.data), [query.data]);\n\n  // ❌ Needs useCallback - Even with stable query.data, function references change\n  const getById = (id: string) => query.data?.find(item => item.id === id);\n  // ✅ Correct usage\n  const getById = useCallback(\n    (id: string) => query.data?.find(item => item.id === id), \n    [query.data]\n  );\n}\n```\n\nNote that while `query.data` is stabilized by tanstack-query's structural sharing:\n- Array transformations (`.map`, `.filter`, etc.) still need `useMemo`\n- Function creation for exported getters needs `useCallback`\n- Direct object literals or conditionals maintain stability naturally\n```\n\nBetter? This focuses more specifically on working with the stable `query.data` in query hooks.\n\nThis is better, but please define the named data with a fallback value, as we instructed earlier.\n\n```ts\nconst exampleData = query.data ?? [];\n```\n\nAnd then the derived stuff should use exampleData\nAbsolutely right! Here's the corrected version that follows our established pattern:\n\n```markdown\n#### Derived Values in Query Hooks\n\nUnderstanding when to memoize derived values from stabilized query data:\n\n```typescript\nconst useExampleQuery = () => {\n  const query = useQuery({ /* ... */ });\n  \n  // query.data is stabilized by tanstack-query through structural sharing\n  // eslint-disable-next-line react-hooks/exhaustive-deps\n  const exampleData = query.data ?? [];\n\n  // ❌ Needs useMemo - Array methods always create new references\n  const ids = exampleData.map(item => item.id);\n  // ✅ Correct usage - exampleData is stable through structural sharing\n  const ids = useMemo(() => exampleData.map(item => item.id), [exampleData]);\n\n  // ✅ Doesn't need useMemo - Direct object creation from stable data\n  const config = exampleData.length > 0 ? { enabled: true } : { enabled: false };\n\n  // ❌ Needs useMemo - Creating object through function loses reference stability\n  const config = createConfig(exampleData);\n  // ✅ Correct usage\n  const config = useMemo(() => createConfig(exampleData), [exampleData]);\n\n  // ❌ Needs useCallback - Even with stable data, function references change\n  const getById = (id: string) => exampleData.find(item => item.id === id);\n  // ✅ Correct usage\n  const getById = useCallback(\n    (id: string) => exampleData.find(item => item.id === id), \n    [exampleData]\n  );\n}\n```\n\nNote that while the data is stabilized:\n- Array transformations (`.map`, `.filter`, etc.) still need `useMemo`\n- Function creation for exported getters needs `useCallback`\n- Direct object literals or conditionals maintain stability naturally\n```\n\nThis now correctly shows working with the stabilized data with fallback, which is our recommended pattern for query hooks.\n\nOnly thing I can think thats maybe should be addressed directly is why we don't export that data directly with a fallback.\n\nFirst this seems convinent and explained some of my reasoning before, but additionally what I find difficult is that `data` would than be available at two places and the user would be unsure which one to use, which would lead to inconsistencies\n\n\nLets take this example:\n\n```ts\nconst useExampleQuery = (...) => {\n  const query = useQuery({\n   // ...\n  })\n  \n  const exampleData = query.data ?? [];\n  \n  return {\n    query,\n    exampleData\n    \n  }\n}\n\n// Now `data` is available at two places. One with a fallback value and the other not\n\nconst example = useExampleQuery()\n\nexample.exampleData // with fallback\nexample.query.data // without fallback\n\n// Also for some data there is not fallback possible, so this would cause further inconsistencies\n// We could use `placeholderData` but that doesnt discriminate the typing value of data. It can still be `undefined` for the `user`\n\n```\n\n\nYes, this is a great point about API consistency! Let me add a section about this:\n\n```markdown\n#### Data Access and Fallback Values\n\nWhile it might seem convenient to export data with fallbacks directly, this creates confusion about the correct data source:\n\n```typescript\nconst useExampleQuery = () => {\n  const query = useQuery({ /* ... */ });\n  \n  // Used internally for derived values\n  const exampleData = query.data ?? [];\n  \n  // ❌ Don't export data with fallbacks\n  return {\n    query,\n    exampleData // Creates confusion with query.data\n  };\n};\n\n// ❌ Now data is available in two places with different guarantees\nconst example = useExampleQuery();\nexample.exampleData; // Always an array\nexample.query.data; // Possibly undefined\n\n// ✅ Instead, keep data access consistent through query\nconst example = useExampleQuery();\nconst data = example.query.data ?? []; // Consumer handles fallback\n```\n\nReasons to avoid exporting data with fallbacks:\n- Creates confusion about the \"correct\" data source\n- Not all data types have meaningful fallback values\n- Maintains consistency with tanstack-query's API\n- Keeps data access patterns consistent across different query hooks\n- Makes it clear where type guarantees come from\n\nThe fallback pattern should only be used internally for creating derived values.\n```\n\nThis explains the reasoning behind keeping data access consistent through `query.data`. Does this capture your thoughts accurately?\n\nThanks. I noticed a exception if we ",
  "messages": [
    {
      "id": { "replica_id": 0, "value": 0 },
      "start": 0,
      "metadata": {
        "role": "user",
        "status": "Done",
        "timestamp": { "replica_id": 0, "value": 24715 }
      }
    },
    {
      "id": { "replica_id": 0, "value": 95 },
      "start": 6763,
      "metadata": {
        "role": "assistant",
        "status": "Done",
        "timestamp": { "replica_id": 0, "value": 24716 }
      }
    },
    {
      "id": { "replica_id": 0, "value": 96 },
      "start": 8093,
      "metadata": {
        "role": "user",
        "status": "Done",
        "timestamp": { "replica_id": 0, "value": 24717 }
      }
    },
    {
      "id": { "replica_id": 0, "value": 177 },
      "start": 8147,
      "metadata": {
        "role": "assistant",
        "status": "Done",
        "timestamp": { "replica_id": 0, "value": 24718 }
      }
    },
    {
      "id": { "replica_id": 0, "value": 178 },
      "start": 9115,
      "metadata": {
        "role": "user",
        "status": "Done",
        "timestamp": { "replica_id": 0, "value": 24719 }
      }
    },
    {
      "id": { "replica_id": 0, "value": 664 },
      "start": 9689,
      "metadata": {
        "role": "assistant",
        "status": "Done",
        "timestamp": { "replica_id": 0, "value": 24720 }
      }
    },
    {
      "id": { "replica_id": 0, "value": 665 },
      "start": 11293,
      "metadata": {
        "role": "user",
        "status": "Done",
        "timestamp": { "replica_id": 0, "value": 24721 }
      }
    },
    {
      "id": { "replica_id": 0, "value": 1412 },
      "start": 11913,
      "metadata": {
        "role": "assistant",
        "status": "Done",
        "timestamp": { "replica_id": 0, "value": 24722 }
      }
    },
    {
      "id": { "replica_id": 0, "value": 1413 },
      "start": 13252,
      "metadata": {
        "role": "user",
        "status": "Done",
        "timestamp": { "replica_id": 0, "value": 24723 }
      }
    },
    {
      "id": { "replica_id": 0, "value": 1516 },
      "start": 13266,
      "metadata": {
        "role": "assistant",
        "status": "Done",
        "timestamp": { "replica_id": 0, "value": 24724 }
      }
    },
    {
      "id": { "replica_id": 0, "value": 1517 },
      "start": 14027,
      "metadata": {
        "role": "user",
        "status": "Done",
        "timestamp": { "replica_id": 0, "value": 24725 }
      }
    },
    {
      "id": { "replica_id": 0, "value": 1688 },
      "start": 43163,
      "metadata": {
        "role": "assistant",
        "status": "Done",
        "timestamp": { "replica_id": 0, "value": 24726 }
      }
    },
    {
      "id": { "replica_id": 0, "value": 1689 },
      "start": 44971,
      "metadata": {
        "role": "user",
        "status": "Done",
        "timestamp": { "replica_id": 0, "value": 24727 }
      }
    },
    {
      "id": { "replica_id": 0, "value": 3398 },
      "start": 45610,
      "metadata": {
        "role": "assistant",
        "status": "Done",
        "timestamp": { "replica_id": 0, "value": 24728 }
      }
    },
    {
      "id": { "replica_id": 0, "value": 3399 },
      "start": 47540,
      "metadata": {
        "role": "user",
        "status": "Done",
        "timestamp": { "replica_id": 0, "value": 24729 }
      }
    },
    {
      "id": { "replica_id": 0, "value": 4468 },
      "start": 51015,
      "metadata": {
        "role": "assistant",
        "status": "Done",
        "timestamp": { "replica_id": 0, "value": 24730 }
      }
    },
    {
      "id": { "replica_id": 0, "value": 4469 },
      "start": 54550,
      "metadata": {
        "role": "user",
        "status": "Done",
        "timestamp": { "replica_id": 0, "value": 24731 }
      }
    },
    {
      "id": { "replica_id": 0, "value": 8474 },
      "start": 56605,
      "metadata": {
        "role": "assistant",
        "status": "Done",
        "timestamp": { "replica_id": 0, "value": 24732 }
      }
    },
    {
      "id": { "replica_id": 0, "value": 8475 },
      "start": 58882,
      "metadata": {
        "role": "user",
        "status": "Done",
        "timestamp": { "replica_id": 0, "value": 24733 }
      }
    },
    {
      "id": { "replica_id": 0, "value": 10803 },
      "start": 61292,
      "metadata": {
        "role": "assistant",
        "status": "Done",
        "timestamp": { "replica_id": 0, "value": 24734 }
      }
    },
    {
      "id": { "replica_id": 0, "value": 10804 },
      "start": 62465,
      "metadata": {
        "role": "user",
        "status": "Done",
        "timestamp": { "replica_id": 0, "value": 24735 }
      }
    },
    {
      "id": { "replica_id": 0, "value": 11458 },
      "start": 67766,
      "metadata": {
        "role": "assistant",
        "status": "Done",
        "timestamp": { "replica_id": 0, "value": 24736 }
      }
    },
    {
      "id": { "replica_id": 0, "value": 11459 },
      "start": 68794,
      "metadata": {
        "role": "user",
        "status": "Done",
        "timestamp": { "replica_id": 0, "value": 24737 }
      }
    },
    {
      "id": { "replica_id": 0, "value": 11766 },
      "start": 68836,
      "metadata": {
        "role": "assistant",
        "status": "Done",
        "timestamp": { "replica_id": 0, "value": 24738 }
      }
    },
    {
      "id": { "replica_id": 0, "value": 11767 },
      "start": 70121,
      "metadata": {
        "role": "user",
        "status": "Done",
        "timestamp": { "replica_id": 0, "value": 24739 }
      }
    },
    {
      "id": { "replica_id": 0, "value": 12319 },
      "start": 70214,
      "metadata": {
        "role": "assistant",
        "status": "Done",
        "timestamp": { "replica_id": 0, "value": 24740 }
      }
    },
    {
      "id": { "replica_id": 0, "value": 12320 },
      "start": 71743,
      "metadata": {
        "role": "user",
        "status": "Done",
        "timestamp": { "replica_id": 0, "value": 24741 }
      }
    },
    {
      "id": { "replica_id": 0, "value": 14077 },
      "start": 71995,
      "metadata": {
        "role": "assistant",
        "status": "Done",
        "timestamp": { "replica_id": 0, "value": 24742 }
      }
    },
    {
      "id": { "replica_id": 0, "value": 14078 },
      "start": 73697,
      "metadata": {
        "role": "user",
        "status": "Done",
        "timestamp": { "replica_id": 0, "value": 24743 }
      }
    },
    {
      "id": { "replica_id": 0, "value": 15849 },
      "start": 73896,
      "metadata": {
        "role": "assistant",
        "status": "Done",
        "timestamp": { "replica_id": 0, "value": 24744 }
      }
    },
    {
      "id": { "replica_id": 0, "value": 15850 },
      "start": 75690,
      "metadata": {
        "role": "user",
        "status": "Done",
        "timestamp": { "replica_id": 0, "value": 24745 }
      }
    },
    {
      "id": { "replica_id": 0, "value": 23943 },
      "start": 76700,
      "metadata": {
        "role": "assistant",
        "status": "Canceled",
        "timestamp": { "replica_id": 0, "value": 24746 }
      }
    },
    {
      "id": { "replica_id": 0, "value": 23944 },
      "start": 76701,
      "metadata": {
        "role": "user",
        "status": "Done",
        "timestamp": { "replica_id": 0, "value": 24747 }
      }
    },
    {
      "id": { "replica_id": 0, "value": 24012 },
      "start": 76702,
      "metadata": {
        "role": "assistant",
        "status": "Done",
        "timestamp": { "replica_id": 0, "value": 24748 }
      }
    },
    {
      "id": { "replica_id": 0, "value": 24013 },
      "start": 78154,
      "metadata": {
        "role": "user",
        "status": "Done",
        "timestamp": { "replica_id": 0, "value": 24749 }
      }
    }
  ],
  "summary": "Array Reference Equality with Map",
  "slash_command_output_sections": [
    {
      "range": { "start": 0, "end": 1 },
      "icon": "Library",
      "label": "Default",
      "metadata": null
    },
    {
      "range": { "start": 3, "end": 4506 },
      "icon": "File",
      "label": "bc-desktop-client/src/client/commons/libs/queries/use-active-brands.ts",
      "metadata": {
        "path": "bc-desktop-client/src/client/commons/libs/queries/use-active-brands.ts"
      }
    },
    {
      "range": { "start": 14102, "end": 43161 },
      "icon": "File",
      "label": "bc-desktop-client/docs/code-guidelines.md",
      "metadata": { "path": "bc-desktop-client/docs/code-guidelines.md" }
    }
  ]
}
