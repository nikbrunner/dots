{
  "id": "d699020d-e820-432d-b270-c4206b7481a8",
  "zed": "context",
  "version": "0.4.0",
  "text": "\n\n\n```ts bc-desktop-client/src/client/kiosk/libs/queries/use-initial-setup.ts\n\nimport { InitialSetupStep } from \"../../../../commons/types/settings\";\nimport config from \"../../../commons/config\";\nimport { useSettings } from \"../../../commons/libs/queries/use-settings\";\n\n/** A hook to get the current state of the initial setup. */\nexport const useInitialSetup = (options: Parameters<typeof useSettings>[0] = {}) => {\n  const settings = useSettings(options);\n\n  // We use the direct `query.data` here instead of `initialized`,\n  // because this Hook is used during the initialization phase.\n  const initialSetup = settings.query.data?.initialSetup;\n\n  const finishedSteps = initialSetup?.finishedSteps ?? [];\n  const openSetupSteps = getOpenSetupSteps(finishedSteps);\n  const isSetupDone = openSetupSteps.length === 0;\n\n  const firstInitialSetup = initialSetup?.firstFinished ?? \"\";\n  const isFirstInitialSetupFinished = Boolean(firstInitialSetup);\n\n  return {\n    /** The initial setup steps that are still open. */\n    openSetupSteps,\n    /** Whether the initial setup is done. */\n    isSetupDone,\n    /** The time stamp of the first initial setup. */\n    firstInitialSetup,\n    /** Whether the first initial setup was finished. */\n    isFirstInitialSetupFinished,\n    /** The route of a setup step. */\n    getSetupStepRoute\n  };\n};\n\nexport const getSetupStepRoute = (step: InitialSetupStep): string => config?.kiosk?.setup.routes[step];\n\nexport const getOpenSetupSteps = (finishedSteps: InitialSetupStep[]) =>\n  config?.kiosk?.setup.steps.filter(step => finishedSteps.indexOf(step) < 0 && step !== InitialSetupStep.Finished);\n```\n\n```ts bc-desktop-client/src/client/commons/libs/queries/use-settings.ts\nimport { useCallback, useState } from \"react\";\nimport { useMutation, UseMutationOptions, useQueryClient } from \"@tanstack/react-query\";\nimport { FormikErrors, FormikHelpers, useFormik } from \"formik\";\nimport { camelCase, isEqual } from \"lodash\";\n\nimport {\n  getSettings as getSettingsLib,\n  storeSetting as storeSettingLib\n} from \"../../../../commons/libs/settings-service\";\nimport { Bookmarks } from \"../../../../commons/types/bookmarks\";\nimport { Settings, ToolSetting, ToolSettings } from \"../../../../commons/types/settings\";\nimport { ExternalToolKey } from \"../../../../commons/types/tool\";\nimport actions from \"../../actions\";\nimport sharedConfig from \"../../config/shared\";\nimport { hash } from \"../externals/hash\";\nimport useDispatch from \"../hooks/use-dispatch\";\nimport useOnMount from \"../hooks/use-on-mount\";\nimport useQuery, { UseQueryOptions } from \"../hooks/use-query\";\nimport useSelector from \"../hooks/use-selector\";\nimport useThrottle from \"../hooks/use-throttle\";\n\nimport select from \"./use-settings.selectors\";\n\nconst settingsQueryKey = [\"settings\"] as const;\nconst setSettingsMutationKey = [\"setSettings\"] as const;\n\ntype SettingsQueryOptions = Omit<Partial<UseQueryOptions<Settings>>, \"queryKey\" | \"queryFn\">;\n\ntype SetSettingsMutationVariables = {\n  path: Parameters<typeof storeSettingLib>[0];\n  value: Parameters<typeof storeSettingLib>[1];\n};\n\ntype SetSettingsMutationOptions = Omit<\n  Partial<UseMutationOptions<Settings, Error, SetSettingsMutationVariables>>,\n  \"mutationKey\" | \"mutationFn\"\n>;\n\n/**\n * Hook for accessing application settings.\n *\n * *Note: Settings use staleTime: Infinity and will remain cached until explicitly invalidated.*\n *\n * ## Usage\n * There are two patterns for using this hook:\n *\n * ### During initialization of app\n * ```ts\n *  } else {\n *    console.log(\"Settings are loaded!\", setings.query.data);\n *  }\n *  ```\n * ### After initialization\n * Since we are using a `staleTime` of `Infinity`, we can safely presume that settings are loaded after initialization.\n * When we are deep in the app, we can use the getter properties to have easy access to the settings,\n * without having to worry about the loading state in every container.\n *\n * For example:\n * ```ts\n * const settings = useSettings();\n * console.log(\"Customization\", settings.initialized.customization);\n * ```\n **/\nexport const useSettings = (options: SettingsQueryOptions = {}) => {\n  const queryClient = useQueryClient();\n  const dispatch = useDispatch();\n\n  // eslint-disable-next-line no-restricted-syntax -- This selector can be used during initialization while settings have already been fetched but `isInitialized` is still false\n  const reduxSettings = useSelector(state => state.settings.settings);\n\n  const query = useQuery({\n    ...options,\n    queryKey: settingsQueryKey,\n    queryFn: getSettingsLib,\n    staleTime: Infinity, // Keep the cache data, until we mutate the settings via `useSetSettings`.\n    onData: settings => {\n      options.onData?.(settings);\n\n      /**\n       * @todo BCD-7672 Replace `state.settings.settings` with `useSettings`\n       *\n       * During the migration from the redux settings store to the query settings store,\n       * we want to prevent unnecessary dispatching of `settings.received` actions, so\n       * we only dispatch it if the settings have changed.\n       * This allows us to use the `useSettings` hook in components and containers,\n       * without dispatching `settings.received` actions all the time.\n       */\n      if (!isEqual(reduxSettings, settings)) {\n        dispatch(actions.settings.received(settings));\n      }\n    },\n    onError: error => {\n      dispatch(actions.error.set(error));\n    }\n  });\n\n  const invalidateCache = useCallback(() => {\n    queryClient.invalidateQueries({ queryKey: settingsQueryKey });\n  }, [queryClient]);\n\n  return {\n    /** The raw query return object of `useSettings`. */\n    query,\n\n    // Getters\n    /** Use this to get defined settings after app initialization was done. */\n    get initialized() {\n      if (!query.data) {\n        throw new Error(\n          \"useSettings: `query.data` is still undefined! Please only use this selector after initialization.\"\n        );\n      } else {\n        return query.data;\n      }\n    },\n    get isBodySizingEnabled() {\n      return Boolean(this.initialized.toolSettings.smartfit.smartfitApiAuth);\n    },\n    get isBodySizingNotificationsEnabled() {\n      return !this.isBodySizingEnabled && Boolean(this.initialized.toolSettings.smartfit.meta.toolVisible);\n    },\n    get hasMailToPrintSettings() {\n      return Boolean(this.initialized.printing.mailToPrint.email);\n    },\n    get assortmentPriceSettings() {\n      return select.assortmentPriceSettings(this.initialized);\n    },\n    get assortmentFilterSettings() {\n      return select.assortmentFilterSettings(this.initialized);\n    },\n\n    // Actions\n    get getToolSettingsByKey() {\n      return <TS extends ToolSetting>(toolKey: keyof ToolSettings): TS => {\n        /** This is nessesary because internal tool keys are dash-cased, while the properties of its settings are camelCased.\n         * Compare the `ToolKey` type with the entries of `ToolSettings`. */\n        const convertedToolKey = camelCase(toolKey) as keyof ToolSettings;\n        return this.initialized.toolSettings[convertedToolKey] as TS;\n      };\n    },\n    /** Invalidate the settings cache. */\n    invalidateCache\n  };\n};\n\nexport const useSetSettings = (options: SetSettingsMutationOptions = {}) => {\n  const queryClient = useQueryClient();\n  const dispatch = useDispatch();\n\n  const mutation = useMutation({\n    ...options,\n    mutationKey: setSettingsMutationKey,\n    mutationFn: ({ path, value }: SetSettingsMutationVariables) => storeSettingLib(path, value),\n    onSuccess: (data, variables, context) => {\n      queryClient.invalidateQueries({ queryKey: settingsQueryKey });\n      options.onSuccess?.(data, variables, context);\n    },\n    onError: error => {\n      dispatch(actions.error.set(error));\n    }\n  });\n\n  const mutate = mutation.mutate;\n\n  const setPersonalCode = useCallback(\n    (personalCode: string) => {\n      return mutate({ path: [\"personalCode\"], value: hash(personalCode) });\n    },\n    [mutate]\n  );\n\n  const setToolSettings = useCallback(\n    <T extends ToolSetting>(toolKey: keyof ToolSettings) =>\n      (toolSettings: T) => {\n        return mutate({ path: [\"toolSettings\", toolKey], value: toolSettings });\n      },\n    [mutate]\n  );\n\n  const setBookmarks = useCallback(\n    (bookmarks: Bookmarks) => {\n      return mutate({ path: [\"bookmarks\"], value: bookmarks });\n    },\n    [mutate]\n  );\n\n  return {\n    mutation,\n    setPersonalCode,\n    setToolSettings,\n    setBookmarks\n  };\n};\n\ninterface UseToolSettingsOptions<TS> {\n  formik?: {\n    initialValues?: (toolSettings: TS) => TS;\n    onSubmit?: ({\n      values,\n      helpers,\n      setToolSettings\n    }: {\n      /** The current formik values. */\n      values: TS;\n      /** The original formik helpers */\n      helpers: FormikHelpers<TS>;\n      /** The function to set the tool settings with typed tool settings. */\n      setToolSettings: (toolSettings: TS) => void;\n    }) => Promise<void> | void;\n    validate?: ({\n      values,\n      errors\n    }: {\n      /** The current formik values. */\n      values: TS;\n      /** Initial empty, but typed error object to which the errors need to be appended to. */\n      errors: FormikErrors<TS>;\n    }) => FormikErrors<TS>;\n  };\n  query?: {\n    settings?: SettingsQueryOptions;\n    setSettings?: SetSettingsMutationOptions;\n  };\n}\n\n/** Time to throttle quickly changing loading states to avoid flickering for elements that depend on the loading states. */\nconst LOADING_STATE_THROTTLE_TIME = sharedConfig.shared.minLoadingTimeout;\n\n// BCD-7381 Improve Tool Config Type Association\nexport const useToolSettings = <TS extends ToolSetting = ToolSetting>(\n  toolKey: ExternalToolKey,\n  options: UseToolSettingsOptions<TS> = {}\n) => {\n  const settings = useSettings(options.query?.settings);\n  const setSettings = useSetSettings(options.query?.setSettings);\n\n  const [hasSubmitted, setHasSubmitted] = useState(false);\n\n  const fallbackToolSettings = { meta: {} };\n  const currentToolSettings = settings.getToolSettingsByKey<TS>(toolKey);\n  const toolSettings = currentToolSettings ?? fallbackToolSettings;\n  const setToolSettings = setSettings.setToolSettings<TS>(toolKey);\n\n  const formik = useFormik<TS>({\n    enableReinitialize: true,\n    initialValues: options.formik?.initialValues?.(toolSettings) ?? toolSettings,\n    validate: (values: TS) => {\n      if (options.formik?.validate) {\n        const errors: FormikErrors<TS> = {};\n        return options.formik.validate({ values, errors });\n      } else {\n        return {};\n      }\n    },\n    onSubmit: async (values, helpers) => {\n      helpers.setSubmitting(true);\n\n      if (options.formik?.onSubmit) {\n        await options.formik.onSubmit({ values, helpers, setToolSettings });\n      } else {\n        setToolSettings({\n          ...values,\n          meta: {\n            ...values.meta,\n            touchedSettings: true\n          }\n        });\n      }\n\n      helpers.setSubmitting(false);\n      setHasSubmitted(true);\n    }\n  });\n\n  const isFetching = useThrottle(\n    settings.query.isFetching || setSettings.mutation.isPending || formik.isSubmitting,\n    LOADING_STATE_THROTTLE_TIME\n  );\n\n  const isSuccess = useThrottle(\n    setSettings.mutation.isSuccess || settings.query.isSuccess || hasSubmitted,\n    LOADING_STATE_THROTTLE_TIME\n  );\n\n  useToolSettingsViewedTNG(toolKey);\n\n  return {\n    /** The raw query return object of `useSettings`. */\n    settingsQuery: settings,\n    /** The raw mutation return object of `useSetSettings`. */\n    setSettingsMutation: setSettings,\n    /** The current tool settings for the provided tool key. */\n    toolSettings,\n    /** The mutation function for setting the tool settings. */\n    setToolSettings,\n    /** The formik object for the tool settings form. */\n    formik,\n    /** Has the user tried to submit the form? */\n    hasSubmitted,\n    /** Convience property for checking whether the settings, the mutation is currently fetching or formik is submitting. */\n    isFetching,\n    /** Convience property for checking whether the settings or the mutation was successful. */\n    isSuccess\n  };\n};\n\nexport const useToolSettingsViewedTNG = (toolKey: keyof ToolSettings) => {\n  const settings = useSettings();\n  const setSettings = useSetSettings();\n\n  const toolSettings = settings.getToolSettingsByKey(toolKey);\n  const setToolSettings = setSettings.setToolSettings(toolKey);\n\n  useOnMount(() => {\n    if (!toolSettings.meta.viewedSettings) {\n      setToolSettings({\n        ...toolSettings,\n        meta: {\n          ...toolSettings.meta,\n          viewedSettings: true\n        }\n      });\n    }\n  });\n};\n```\n\n```ts bc-desktop-client/src/client/kiosk/libs/hooks/use-initialize-app.ts\nimport { useEffect } from \"react\";\n\nimport actions from \"../../../commons/actions\";\nimport kioskConfig from \"../../../commons/config/config-KIOSK\";\nimport useDispatch from \"../../../commons/libs/hooks/use-dispatch\";\nimport useInitCore from \"../../../commons/libs/hooks/use-init-core\";\nimport cleanupLib from \"../cleanup\";\nimport { useNetworkStatus } from \"../queries/use-network-status\";\n\nimport useCheckLicense from \"./use-check-license\";\nimport usePrinterStatus from \"./use-printer-status\";\nimport useSelector from \"./use-selector\";\n\nconst useInitializeApp = () => {\n  const isInitCoreDone = useSelector(state => state.core.isInitCoreDone);\n\n  const dispatch = useDispatch();\n\n  const setError = (error: Error) => dispatch(actions.error.set(error));\n\n  const networkStatus = useNetworkStatus({\n    enabled: isInitCoreDone,\n    refetchInterval: kioskConfig.kiosk.networkStatus.refetchInterval.default\n  });\n\n  useInitCore({\n    onError: setError\n  });\n\n  const { checkLicense } = useCheckLicense();\n  const { getPrinterStatus } = usePrinterStatus(); // BCD-7696 Replace `state.kioskApp.printerStatus` with `usePrinterStatus`\n\n  const initApp = async () => {\n    await cleanupLib().catch(setError);\n    await getPrinterStatus(); // BCD-7696 Replace `state.kioskApp.printerStatus` with `usePrinterStatus`\n    await checkLicense().catch(setError);\n    await dispatch(actions.startupTimes.fetchDays()); // BCD-6829 Replace `state.startupTimes` with `useStartupTimes`\n    await dispatch(actions.wawi.fetchConnectionInfo()); // BCD-6822 Replace `state.wawi` with `useWawi`\n    dispatch(actions.core.initAppDone());\n  };\n\n  useEffect(() => {\n    if (isInitCoreDone && networkStatus.query.isSuccess) {\n      initApp();\n    }\n\n    /* eslint-disable-next-line react-hooks/exhaustive-deps --\n     * To keep this as straightforward as possible,\n     * we only want to run `initApp` once the core is initialized,\n     * and when the first successful network status fetch has happened.\n     **/\n  }, [isInitCoreDone, networkStatus.query.isSuccess]);\n};\n\nexport default useInitializeApp;\n```\n\n\n\n\n\nCan you review that for me please? I am using `query.data` directly instead of `settings.initialized`, but I was wondering if I could use `settings.initialied` when I am working with getters as in `useSettings`.\nI've reviewed your code focusing on your question about using `query.data` directly versus `settings.initialized` in the `useInitialSetup` hook.\n\n## Current Approach Analysis\n\nIn `useInitialSetup`, you're using:\n```typescript\nconst initialSetup = settings.query.data?.initialSetup;\n```\n\nThis is done because, as your comment explains, \"this Hook is used during the initialization phase\" when `settings.initialized` might not be safe to use.\n\n## Should You Use settings.initialized?\n\nLooking at `useSettings`, the `initialized` getter throws an error if `query.data` is undefined:\n\n```typescript\nget initialized() {\n  if (!query.data) {\n    throw new Error(\n      \"useSettings: `query.data` is still undefined! Please only use this selector after initialization.\"\n    );\n  } else {\n    return query.data;\n  }\n}\n```\n\n### Analysis:\n\n1. **Initialization Context**: Your `useInitialSetup` hook is explicitly designed to be used during the initialization phase, where `settings.initialized` would throw the error.\n\n2. **Usage in `useInitializeApp`**: Looking at the app initialization flow, it's likely that `useInitialSetup` could be called before settings are fully loaded.\n\n3. **Error Prevention**: Using `query.data` with optional chaining (`?.`) is safer in this context as it gracefully handles undefined data.\n\n## Recommendation\n\n**Keep using `query.data` directly in this case.**\n\nYour current approach is correct because:\n\n1. It aligns with the hook's purpose - being used during initialization\n2. It prevents potential runtime errors that would occur if you used `settings.initialized`\n3. It properly handles the case where data is not yet available\n\nThe `settings.initialized` getter is designed for use after initialization is complete, whereas your `useInitialSetup` hook is specifically meant to assist with that initialization process.\n\nThis pattern follows good defensive programming principles by gracefully handling the undefined state during initialization.\n",
  "messages": [
    {
      "id": { "replica_id": 0, "value": 0 },
      "start": 0,
      "metadata": {
        "role": "user",
        "status": "Done",
        "timestamp": { "replica_id": 0, "value": 204 }
      }
    },
    {
      "id": { "replica_id": 0, "value": 103 },
      "start": 14894,
      "metadata": {
        "role": "assistant",
        "status": "Done",
        "timestamp": { "replica_id": 0, "value": 205 }
      }
    },
    {
      "id": { "replica_id": 0, "value": 104 },
      "start": 16865,
      "metadata": {
        "role": "user",
        "status": "Done",
        "timestamp": { "replica_id": 0, "value": 206 }
      }
    }
  ],
  "summary": "# Settings Hook Usage Improvement",
  "slash_command_output_sections": [
    {
      "range": { "start": 0, "end": 1 },
      "icon": "Library",
      "label": "Default",
      "metadata": null
    },
    {
      "range": { "start": 3, "end": 1633 },
      "icon": "File",
      "label": "bc-desktop-client/src/client/kiosk/libs/queries/use-initial-setup.ts",
      "metadata": {
        "path": "bc-desktop-client/src/client/kiosk/libs/queries/use-initial-setup.ts"
      }
    },
    {
      "range": { "start": 1634, "end": 12524 },
      "icon": "File",
      "label": "bc-desktop-client/src/client/commons/libs/queries/use-settings.ts",
      "metadata": {
        "path": "bc-desktop-client/src/client/commons/libs/queries/use-settings.ts"
      }
    },
    {
      "range": { "start": 12525, "end": 14677 },
      "icon": "File",
      "label": "bc-desktop-client/src/client/kiosk/libs/hooks/use-initialize-app.ts",
      "metadata": {
        "path": "bc-desktop-client/src/client/kiosk/libs/hooks/use-initialize-app.ts"
      }
    }
  ]
}
