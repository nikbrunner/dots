{
  "id": "7cb9eb63-388c-40e5-a5dd-eef563195c97",
  "zed": "context",
  "version": "0.4.0",
  "text": "\n\n\n```tsx bc-desktop-client/src/client/commons/container/ProductDetails/ProductDetailsPartial.tsx\nimport React, { useMemo } from \"react\";\nimport { goBack, replace } from \"connected-react-router\";\nimport { useTranslation } from \"react-i18next\";\nimport { ConnectedProps } from \"react-redux\";\nimport { Route, useLocation, useParams } from \"react-router-dom\";\n\nimport { getProduct } from \"../../../../commons/libs/content-service\";\nimport { byDefined } from \"../../../../commons/libs/filter-guards\";\nimport { getSpecFormatter } from \"../../../../commons/libs/formatters\";\nimport { getBrandLogoUrl } from \"../../../../commons/libs/resource-paths\";\nimport { getFirstVariantId, getSingleSpecValue, getStandaloneProductVariant } from \"../../../../commons/libs/specs\";\nimport { getSpecConfig } from \"../../../../commons/specs\";\nimport { Product, ProductId, ProductKey, ProductSpecKey } from \"../../../../commons/specs/product\";\nimport { Brand } from \"../../../../commons/types/brand\";\nimport { GlobalLocationState } from \"../../../../commons/types/location\";\nimport * as icons from \"../../../../resources/icons\";\nimport { IconSmallCross } from \"../../../../resources/icons\";\nimport { useTrackingContext } from \"../../../commons/container/utils/tracking-context\";\nimport { buildProductPath } from \"../../../commons/libs/path\";\nimport { getNeighbouringProducts } from \"../../../commons/libs/products\";\nimport actions from \"../../actions\";\nimport BrandImage from \"../../components/BrandImage/BrandImage\";\nimport Button from \"../../components/Button/Button\";\nimport CenteredPageLayout from \"../../components/CenteredPageLayout/CenteredPageLayout\";\nimport FlexLayout from \"../../components/FlexLayout/FlexLayout\";\nimport Icon from \"../../components/Icon/Icon\";\nimport LoadingIndicator from \"../../components/LoadingIndicator/LoadingIndicator\";\nimport MainContentLayout from \"../../components/MainContentLayout/MainContentLayout\";\nimport ProductDetailsContentLayout from \"../../components/ProductDetailsContentLayout/ProductDetailsContentLayout\";\nimport SwipeableContent, { TransitionDirection } from \"../../components/SwipeableContent/SwipeableContent\";\nimport TabBarPageLayout from \"../../components/TabBarPageLayout/TabBarPageLayout\";\nimport useFetchData from \"../../libs/hooks/use-fetch-data\";\nimport useVeloconnectEndpoint, { UseVeloconnectEndpointReturn } from \"../../libs/hooks/use-veloconnect-endpoint\";\nimport { useActiveBrands } from \"../../libs/queries/use-active-brands\";\nimport { selectAssortmentPriceSettings, selectInitializedSettings } from \"../../libs/selectors\";\nimport { State } from \"../../reducers\";\nimport { ROUTES } from \"../../routes\";\nimport ProductTitlePartial from \"../partials/ProductTitlePartial\";\nimport { connect } from \"../utils/loop\";\nimport { VeloconnectEndpointProvider } from \"../utils/veloconnect-endpoint-context\";\n\nimport ProductDetailsImagePartial from \"./ProductDetailsImagePartial\";\n\nconst mapStateToProps = (state: State) => ({\n  currency: selectInitializedSettings(state).currency,\n  assortmentPriceSettings: selectAssortmentPriceSettings(state)\n});\n\nconst mapDispatchToProps = {\n  onReplace: replace,\n  onGoBack: goBack,\n  onError: actions.error.set\n};\n\nconst connector = connect(mapStateToProps, mapDispatchToProps);\n\nexport interface ProductDetailsPartialRenderProps {\n  productId: ProductId;\n  variantId: ProductId | undefined;\n  product: Product | undefined;\n  productContent?: {\n    key: string;\n    link: string;\n  };\n  productInitializingFirstTime: boolean;\n  brand: Brand | undefined;\n  veloconnectEndpoint: UseVeloconnectEndpointReturn;\n  isAsideAnimationRunning: boolean;\n}\n\ninterface OuterProps {\n  tabBar: (props: ProductDetailsPartialRenderProps) => React.ReactNode;\n  tabBarOverlay: (props: ProductDetailsPartialRenderProps) => React.ReactNode;\n  advertisement?: (props: ProductDetailsPartialRenderProps) => React.ReactNode;\n  productContentAside?: (props: ProductDetailsPartialRenderProps) => React.ReactNode;\n  productContentCta?: (props: ProductDetailsPartialRenderProps) => React.ReactNode;\n  backButton: () => React.ReactNode;\n  onProductLoad?: (product: Product) => void;\n}\n\ntype Props = ConnectedProps<typeof connector> & OuterProps;\n\nconst ProductDetailsPartial = ({\n  onReplace,\n  onError,\n  onGoBack,\n  currency,\n  tabBar,\n  backButton,\n  tabBarOverlay,\n  advertisement,\n  productContentAside,\n  productContentCta,\n  onProductLoad,\n  assortmentPriceSettings\n}: Props) => {\n  const { t, i18n } = useTranslation([\"commons\"]);\n\n  const { getActiveBrand } = useActiveBrands();\n\n  const location = useLocation<GlobalLocationState>();\n  const { mixpanel } = useTrackingContext();\n  const productListContext = (location.state || {}).productListContext || [];\n  const variantId = location.state?.variantId;\n  const { id: productId } = useParams<{ id: ProductId }>();\n\n  const [transitionDirection, setTransitionDirection] = React.useState<TransitionDirection>(TransitionDirection.Next);\n  const [isAsideAnimationRunning, setIsAsideAnimationRunning] = React.useState(false);\n\n  const { isLoading: isLoading, data: { product, productVariant, specFormatter } = {} } = useFetchData(\n    async () => {\n      const product = await getProduct(productId, currency, assortmentPriceSettings);\n\n      const actualVariantId = variantId ?? getFirstVariantId(product);\n      const productVariant = getStandaloneProductVariant(\n        product,\n        product[ProductKey.Variants].find(variant => variant[ProductKey.VariantId] === actualVariantId)\n      );\n\n      const productType = product[ProductKey.ProductType];\n      const specConfig = getSpecConfig(productType);\n\n      const specFormatter = getSpecFormatter(productType, specConfig.specDefinitions, i18n);\n\n      return { product, productVariant, specFormatter };\n    },\n    [productId, variantId, currency],\n    {\n      handleError: error => onError(error),\n      onDone: ({ product }) => {\n        onProductLoad?.(product);\n      }\n    }\n  );\n\n  const tabBarRoutes = useMemo(\n    () =>\n      [\n        ROUTES.PRODUCT_DETAILS.SPECIFICATIONS,\n        ROUTES.PRODUCT_DETAILS.BOOKMARK,\n        ROUTES.PRODUCT_DETAILS.BOOKMARK_COMPARE,\n        ROUTES.PRODUCT_DETAILS.AVAILABILITY\n      ].map(route => buildProductPath(route, { productId })),\n    [productId]\n  );\n\n  const isOnTabBarRoute = location.pathname ? tabBarRoutes.includes(location.pathname) : false;\n\n  const productContentKey = product ? getSingleSpecValue(ProductSpecKey.ProductContentKey, product) : undefined;\n  const productContentLink = productContentKey\n    ? buildProductPath(ROUTES.PRODUCT_DETAILS.PRODUCT_CONTENT, {\n        productId,\n        productContentKey\n      })\n    : undefined;\n\n  const isOnProductContentRoute = location.pathname === productContentLink;\n\n  const productInitializingFirstTime = !product && isLoading;\n\n  const brandKey = product && getSingleSpecValue(ProductSpecKey.BrandKey, product);\n  const brand = brandKey ? getActiveBrand(brandKey) : undefined;\n  const neighbours = getNeighbouringProducts(productListContext, productId);\n\n  const veloconnectEndpoint = useVeloconnectEndpoint(brandKey);\n\n  const renderProps: ProductDetailsPartialRenderProps = {\n    productId,\n    variantId,\n    product,\n    brand,\n    productInitializingFirstTime,\n    veloconnectEndpoint,\n    isAsideAnimationRunning,\n    ...(productContentKey && productContentLink\n      ? { productContent: { key: productContentKey, link: productContentLink } }\n      : undefined)\n  };\n\n  React.useEffect(() => {\n    if (product) {\n      mixpanel?.trackProductViewed(product);\n    }\n    // Track only when product id changed.\n    // eslint-disable-next-line react-hooks/exhaustive-deps\n  }, [product?.[ProductKey.ProductId]]);\n\n  const handleNextProduct = (interaction: \"click\" | \"swipe\") => {\n    if (!isLoading && brand && product && neighbours.next != null) {\n      mixpanel?.trackProductDetailsNavigated(\n        interaction,\n        \"next\",\n        { productId, brandKey: brand.key, modelName: getSingleSpecValue(ProductSpecKey.ModelName, product) },\n        neighbours.next.productId\n      );\n\n      setTransitionDirection(TransitionDirection.Next);\n      onReplace(buildProductPath(ROUTES.PRODUCT_DETAILS.INDEX, { productId: String(neighbours.next.productId) }), {\n        ...location.state,\n        variantId: neighbours.next.variantId\n      });\n    }\n  };\n\n  const handlePrevProduct = (interaction: \"click\" | \"swipe\") => {\n    if (!isLoading && brand && product && neighbours.prev != null) {\n      mixpanel?.trackProductDetailsNavigated(\n        interaction,\n        \"prev\",\n        { productId, brandKey: brand.key, modelName: getSingleSpecValue(ProductSpecKey.ModelName, product) },\n        neighbours.prev.productId\n      );\n\n      setTransitionDirection(TransitionDirection.Prev);\n      onReplace(buildProductPath(ROUTES.PRODUCT_DETAILS.INDEX, { productId: String(neighbours.prev.productId) }), {\n        ...location.state,\n        variantId: neighbours.prev.variantId\n      });\n    }\n  };\n\n  return (\n    <Route\n      exact\n      path={ROUTES.PRODUCT_DETAILS.INDEX}\n      children={() => (\n        <VeloconnectEndpointProvider endpoint={veloconnectEndpoint}>\n          <TabBarPageLayout\n            isTabBarOverlayOpen={!productInitializingFirstTime && isOnTabBarRoute}\n            tabBar={tabBar(renderProps)}\n            tabBarOverlay={tabBarOverlay(renderProps)}\n            onCloseTabBarOverlay={() => {\n              onReplace(buildProductPath(ROUTES.PRODUCT_DETAILS.INDEX, { productId }), location.state);\n            }}\n            isAsideOpen={isOnProductContentRoute}\n            onAsideAnimationStarted={() => setIsAsideAnimationRunning(true)}\n            onAsideAnimationCompleted={() => setIsAsideAnimationRunning(false)}\n            aside={productContentAside?.(renderProps)}\n            asideCloseButton={\n              <Button onClick={() => onGoBack()} variant=\"accent\" kind=\"solid\" icon={<Icon source={IconSmallCross} />}>\n                {t(\"productDetailsPartialProductDetails.closeAsideButtonLabel\")}\n              </Button>\n            }\n            asideProductTitle={<ProductTitlePartial product={product} wrap align=\"left\" />}\n          >\n            <ProductDetailsContentLayout\n              itemsRight={[productContentCta?.(renderProps), advertisement?.(renderProps)].filter(byDefined)}\n              alignment={!!advertisement?.(renderProps) ? \"right-bottom\" : \"right-center\"}\n              isAsideOpen={isOnProductContentRoute}\n            >\n              {!product && (\n                <CenteredPageLayout>\n                  <LoadingIndicator size=\"s\" />\n                </CenteredPageLayout>\n              )}\n              {product && productVariant && specFormatter && (\n                <MainContentLayout\n                  layout=\"full\"\n                  headerLeft={backButton()}\n                  // TODO: Refactor with header component. Adding a simple margin works fine but just in this special case. It breaks out of the header\n                  headerRight={\n                    brand && (\n                      <FlexLayout alignItems=\"center\" gap=\"sl\" classNames={[\"u-space-top-l\"]}>\n                        {brand?.highlighted ? <Icon source={icons.IconMediumHighlight} size=\"l\" /> : undefined}\n                        <BrandImage position=\"right\" src={getBrandLogoUrl(brand.key)} />\n                      </FlexLayout>\n                    )\n                  }\n                  backgroundImage={null}\n                  hideHeaderBackground\n                >\n                  <SwipeableContent\n                    transitionDirection={transitionDirection}\n                    classNames={[\"u-space-top-s\", \"u-space-xl\"]}\n                    // prevButton={\n                    //   neighbours.prev !== null ? (\n                    //     <NextPrevNavigationButton onClick={() => handlePrevProduct(\"click\")} />\n                    //   ) : undefined\n                    // }\n                    // nextButton={\n                    //   neighbours.next !== null ? (\n                    //     <NextPrevNavigationButton next onClick={() => handleNextProduct(\"click\")} />\n                    //   ) : undefined\n                    // }\n                    onPrev={() => handlePrevProduct(\"swipe\")}\n                    onNext={() => handleNextProduct(\"swipe\")}\n                  >\n                    <ProductDetailsImagePartial\n                      // It is necessary to create a new key with every new product to allow SwipeableContent to detect when it has to animate!\n                      isProductContentAsideOpen={isOnProductContentRoute}\n                      key={product[ProductKey.ProductId]}\n                      product={product}\n                      productVariant={productVariant}\n                    />\n                  </SwipeableContent>\n                </MainContentLayout>\n              )}\n            </ProductDetailsContentLayout>\n          </TabBarPageLayout>\n        </VeloconnectEndpointProvider>\n      )}\n    />\n  );\n};\n\nexport default connector(ProductDetailsPartial);\n```\n\n\n```ts bc-desktop-client/src/client/commons/libs/queries/use-settings.ts\n\nimport { useCallback, useMemo, useState } from \"react\";\nimport { useMutation, UseMutationOptions, useQueryClient } from \"@tanstack/react-query\";\nimport { FormikErrors, FormikHelpers, useFormik } from \"formik\";\n\nimport {\n  getSettings as getSettingsLib,\n  storeSetting as storeSettingLib\n} from \"../../../../commons/libs/settings-service\";\nimport { AssortmentType } from \"../../../../commons/types/assortment\";\nimport { AssortmentPriceSettings, Settings, ToolSetting } from \"../../../../commons/types/settings\";\nimport { ExternalToolKey } from \"../../../../commons/types/tool\";\nimport actions from \"../../actions\";\nimport sharedConfig from \"../../config/shared\";\nimport { hash } from \"../externals/hash\";\nimport useDispatch from \"../hooks/use-dispatch\";\nimport useOnMount from \"../hooks/use-on-mount\";\nimport useQuery, { UseQueryOptions } from \"../hooks/use-query\";\nimport useThrottle from \"../hooks/use-throttle\";\n\nconst settingsQueryKey = [\"settings\"] as const;\nconst setSettingsMutationKey = [\"setSettings\"] as const;\n\ntype SettingsQueryOptions = Omit<Partial<UseQueryOptions<Settings>>, \"queryKey\" | \"queryFn\">;\n\ntype SetSettingsMutationVariables = {\n  path: Parameters<typeof storeSettingLib>[0];\n  value: Parameters<typeof storeSettingLib>[1];\n};\n\ntype SetSettingsMutationOptions = Omit<\n  Partial<UseMutationOptions<Settings, Error, SetSettingsMutationVariables>>,\n  \"mutationKey\" | \"mutationFn\"\n>;\n\nexport const useSettings = (options: SettingsQueryOptions = {}) => {\n  const dispatch = useDispatch();\n\n  const query = useQuery({\n    ...options,\n    queryKey: settingsQueryKey,\n    queryFn: getSettingsLib,\n    staleTime: Infinity, // Keep the cache data, until we mutate the settings via `useSetSettings`.\n    onData: settings => {\n      // TODO: BCD-7672 Replace `state.settings.settings` with `useSettings`\n      dispatch(actions.settings.received(settings));\n      options.onData?.(settings);\n    },\n    onError: error => {\n      dispatch(actions.error.set(error));\n    }\n  });\n\n  const settings = query.data;\n\n  const assortmentPriceSettings = useMemo(() => {\n    const fallbackAssortmentPriceSettings: AssortmentPriceSettings = {\n      showAssortmentPrices: false,\n      showFallbackPrices: false,\n      useRrpAsOriginalPrice: false,\n      showOriginalPrices: false,\n      showSaleBadge: null\n    };\n\n    if (settings) {\n      const hasAutomaticAssortmentType = settings.assortment.type === AssortmentType.Automatic;\n\n      return hasAutomaticAssortmentType\n        ? (settings.assortment.priceSettings ?? fallbackAssortmentPriceSettings)\n        : fallbackAssortmentPriceSettings;\n    } else {\n      return undefined;\n    }\n  }, [settings]);\n\n  return {\n    ...query,\n    assortmentPriceSettings\n  };\n};\n\nexport const useSetSettings = (options: SetSettingsMutationOptions = {}) => {\n  const queryClient = useQueryClient();\n  const dispatch = useDispatch();\n\n  const {\n    mutate,\n    // We destructure the mutation functions to make them usable inside the `useSetSettings` hook,\n    // but don't export them to the outside. Setting settings should only be done via specific exported typed functions.\n    // eslint-disable-next-line @typescript-eslint/no-unused-vars\n    mutateAsync,\n    ...setSettingsMutation\n  } = useMutation({\n    ...options,\n    mutationKey: setSettingsMutationKey,\n    mutationFn: ({ path, value }: SetSettingsMutationVariables) => storeSettingLib(path, value),\n    onSuccess: (data, variables, context) => {\n      queryClient.invalidateQueries({ queryKey: settingsQueryKey });\n      options.onSuccess?.(data, variables, context);\n    },\n    onError: error => {\n      dispatch(actions.error.set(error));\n    }\n  });\n\n  const setPersonalCode = useCallback(\n    (personalCode: string) => {\n      return mutate({ path: [\"personalCode\"], value: hash(personalCode) });\n    },\n    [mutate]\n  );\n\n  const setToolSettings = useCallback(\n    <T extends ToolSetting>(toolKey: ExternalToolKey) =>\n      (toolSettings: T) => {\n        return mutate({ path: [\"toolSettings\", toolKey], value: toolSettings });\n      },\n    [mutate]\n  );\n\n  return {\n    ...setSettingsMutation,\n    setPersonalCode,\n    setToolSettings\n  };\n};\n\ninterface UseToolSettingsOptions<TS> {\n  formik?: {\n    initialValues?: (toolSettings: TS) => TS;\n    onSubmit?: ({\n      values,\n      helpers,\n      setToolSettings\n    }: {\n      /** The current formik values. */\n      values: TS;\n      /** The original formik helpers */\n      helpers: FormikHelpers<TS>;\n      /** The function to set the tool settings with typed tool settings. */\n      setToolSettings: (toolSettings: TS) => void;\n    }) => Promise<void> | void;\n    validate?: ({\n      values,\n      errors\n    }: {\n      /** The current formik values. */\n      values: TS;\n      /** Initial empty, but typed error object to which the errors need to be appended to. */\n      errors: FormikErrors<TS>;\n    }) => FormikErrors<TS>;\n  };\n  query?: {\n    settings?: SettingsQueryOptions;\n    setSettings?: SetSettingsMutationOptions;\n  };\n}\n\n/** Time to throttle quickly changing loading states to avoid flickering for elements that depend on the loading states. */\nconst LOADING_STATE_THROTTLE_TIME = sharedConfig.shared.minLoadingTimeout;\n\n// BCD-7381 Improve Tool Config Type Association\nexport const useToolSettings = <TS extends ToolSetting = ToolSetting>(\n  toolKey: ExternalToolKey,\n  options: UseToolSettingsOptions<TS> = {}\n) => {\n  const settings = useSettings(options.query?.settings);\n  const setSettings = useSetSettings(options.query?.setSettings);\n\n  const [hasSubmitted, setHasSubmitted] = useState(false);\n\n  const fallbackToolSettings = { meta: {} };\n  const currentToolSettings = settings.data?.toolSettings[toolKey] as TS;\n  const toolSettings = currentToolSettings ?? fallbackToolSettings;\n  const setToolSettings = setSettings.setToolSettings<TS>(toolKey);\n\n  const formik = useFormik<TS>({\n    enableReinitialize: true,\n    initialValues: options.formik?.initialValues?.(toolSettings) ?? toolSettings,\n    validate: (values: TS) => {\n      if (options.formik?.validate) {\n        const errors: FormikErrors<TS> = {};\n        return options.formik.validate({ values, errors });\n      } else {\n        return {};\n      }\n    },\n    onSubmit: async (values, helpers) => {\n      helpers.setSubmitting(true);\n\n      if (options.formik?.onSubmit) {\n        await options.formik.onSubmit({ values, helpers, setToolSettings });\n      } else {\n        setToolSettings({\n          ...values,\n          meta: {\n            ...values.meta,\n            touchedSettings: true\n          }\n        });\n      }\n\n      helpers.setSubmitting(false);\n      setHasSubmitted(true);\n    }\n  });\n\n  const isFetching = useThrottle(\n    settings.isFetching || setSettings.isPending || formik.isSubmitting,\n    LOADING_STATE_THROTTLE_TIME\n  );\n\n  const isSuccess = useThrottle(\n    setSettings.isSuccess || settings.isSuccess || hasSubmitted,\n    LOADING_STATE_THROTTLE_TIME\n  );\n\n  // Mark the tool as viewed if we visit the page.\n  useOnMount(() => {\n    if (!toolSettings.meta.viewedSettings) {\n      setToolSettings({\n        ...toolSettings,\n        meta: {\n          ...toolSettings.meta,\n          viewedSettings: true\n        }\n      });\n    }\n  });\n\n  return {\n    /** The raw query return object of `useSettings`. */\n    settingsQuery: settings,\n    /** The raw mutation return object of `useSetSettings`. */\n    setSettingsMutation: setSettings,\n    /** The current tool settings for the provided tool key. */\n    toolSettings,\n    /** The mutation function for setting the tool settings. */\n    setToolSettings,\n    /** The formik object for the tool settings form. */\n    formik,\n    /** Has the user tried to submit the form? */\n    hasSubmitted,\n    /** Convience property for checking whether the settings, the mutation is currently fetching or formik is submitting. */\n    isFetching,\n    /** Convience property for checking whether the settings or the mutation was successful. */\n    isSuccess\n  };\n};\n```\n\n\nWhat are you seeing?\n\nI'm looking at two TypeScript/React files:\n\n1. `ProductDetailsPartial.tsx`: This is a React component that handles the display of product details. It includes:\n- Product information display\n- Navigation between products\n- Integration with Redux for state management\n- Handling of product variants\n- Routing logic\n- Support for translations (i18n)\n- Integration with Mixpanel for tracking\n- Various UI components for layout and display\n\n2. `use-settings.ts`: This is a custom hook file that handles application settings. It includes:\n- `useSettings` hook for fetching settings\n- `useSetSettings` hook for mutating settings\n- `useToolSettings` hook for managing tool-specific settings\n- Integration with React Query for data fetching\n- Form handling with Formik\n- Settings caching logic\n- Throttling for loading states\n\nThe code demonstrates a well-structured React application with:\n- Type safety through TypeScript\n- Modern React patterns (hooks, context)\n- State management (Redux + React Query)\n- Form handling\n- Routing\n- Analytics integration\n- Proper separation of concerns between UI components and data management\n\nThe code appears to be part of a larger e-commerce or product catalog application, with robust functionality for displaying and managing product details and application settings.\n",
  "messages": [
    {
      "id": { "replica_id": 0, "value": 0 },
      "start": 0,
      "metadata": {
        "role": "user",
        "status": "Done",
        "timestamp": { "replica_id": 0, "value": 73 }
      }
    },
    {
      "id": { "replica_id": 0, "value": 44 },
      "start": 21070,
      "metadata": {
        "role": "assistant",
        "status": "Done",
        "timestamp": { "replica_id": 0, "value": 74 }
      }
    },
    {
      "id": { "replica_id": 0, "value": 45 },
      "start": 22371,
      "metadata": {
        "role": "user",
        "status": "Done",
        "timestamp": { "replica_id": 0, "value": 75 }
      }
    }
  ],
  "summary": "Product Details Management with Settings Hooks",
  "slash_command_output_sections": [
    {
      "range": { "start": 0, "end": 1 },
      "icon": "Library",
      "label": "Default",
      "metadata": null
    },
    {
      "range": { "start": 3, "end": 13000 },
      "icon": "File",
      "label": "bc-desktop-client/src/client/commons/container/ProductDetails/ProductDetailsPartial.tsx",
      "metadata": {
        "path": "bc-desktop-client/src/client/commons/container/ProductDetails/ProductDetailsPartial.tsx"
      }
    },
    {
      "range": { "start": 13002, "end": 21046 },
      "icon": "File",
      "label": "bc-desktop-client/src/client/commons/libs/queries/use-settings.ts",
      "metadata": {
        "path": "bc-desktop-client/src/client/commons/libs/queries/use-settings.ts"
      }
    }
  ]
}
