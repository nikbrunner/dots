local M = {}

---Finds a pattern in a line of a file and replaces it with a value
---@param filepath string
---@param pattern string
---@param value string
function M.update_line_in_file(filepath, pattern, value)
    -- First check if file exists and is readable
    if not vim.loop.fs_stat(filepath) then
        vim.notify("File does not exist: " .. filepath, vim.log.levels.ERROR)
        return
    end

    -- Read file safely with pcall
    local ok, lines = pcall(vim.fn.readfile, filepath)
    if not ok or not lines then
        vim.notify("Failed to read file: " .. filepath, vim.log.levels.ERROR)
        return
    end

    -- Process lines
    lines = vim.tbl_map(function(line)
        if vim.fn.match(line, pattern) ~= -1 then
            line = vim.fn.substitute(line, '".*"', value, "")
        end
        return line
    end, lines)

    -- Use a delay and write file safely with pcall
    vim.defer_fn(function()
        local write_ok, err = pcall(vim.fn.writefile, lines, filepath)
        if not write_ok then
            vim.notify("Failed to write file: " .. filepath .. " - " .. (err or "unknown error"), vim.log.levels.ERROR)
        end
    end, 500)
end

---Syncs the wezterm colorscheme with the current nvim colorscheme (if configured)
---@param config VinConfig
---@param colorscheme string
---@param background string
function M.sync_wezterm_colorscheme(config, colorscheme, background)
    local current_light_colorscheme = config.colorscheme_config_map[config.colorscheme_light].wezterm
    local current_dark_colorscheme = config.colorscheme_config_map[config.colorscheme_dark].wezterm
    local colorscheme_to_update = config.colorscheme_config_map[colorscheme].wezterm

    -- Silently skip if colorscheme doesn't have wezterm config
    if not colorscheme_to_update then
        return
    end

    local wezterm_schemes_file = vim.fn.expand("~/.config/wezterm/.current_schemes.lua")

    local light_wezterm, dark_wezterm
    if background == "light" then
        light_wezterm = colorscheme_to_update
        dark_wezterm = current_dark_colorscheme
    else
        light_wezterm = current_light_colorscheme
        dark_wezterm = colorscheme_to_update
    end

    local content = string.format([[-- This file is automatically generated by Neovim
-- Contains current colorscheme mappings for light and dark modes
return {
    light = "%s",
    dark = "%s"
}]], light_wezterm, dark_wezterm)

    -- Write the file safely with pcall
    local write_ok, err = pcall(vim.fn.writefile, vim.split(content, "\n"), wezterm_schemes_file)
    if not write_ok then
        vim.notify_once("Failed to write wezterm schemes file: " .. (err or "unknown error"), vim.log.levels.ERROR)
    end
end

---Syncs the ghostty colorscheme with the current nvim colorscheme (if configured)
---@param config VinConfig
---@param colorscheme string
---@param background string
function M.sync_ghostty_colorscheme(config, colorscheme, background)
    local current_light_colorscheme = config.colorscheme_config_map[config.colorscheme_light].ghostty
    local current_dark_colorscheme = config.colorscheme_config_map[config.colorscheme_dark].ghostty
    local colorscheme_to_update = config.colorscheme_config_map[colorscheme].ghostty

    -- Silently skip if colorscheme doesn't have ghostty config
    if not colorscheme_to_update then
        return
    end

    local ghostty_config_file = vim.fn.expand("~/.config/ghostty/config")

    local theme_line = ""
    if background == "light" then
        theme_line = string.format("theme = dark:%s,light:%s", current_dark_colorscheme, colorscheme_to_update)
    else
        theme_line = string.format("theme = dark:%s,light:%s", colorscheme_to_update, current_light_colorscheme)
    end

    -- Read existing config if it exists, or create empty
    local lines = {}
    if vim.loop.fs_stat(ghostty_config_file) then
        local read_ok, file_lines = pcall(vim.fn.readfile, ghostty_config_file)
        if read_ok and file_lines then
            lines = file_lines
        end
    end

    -- Update or add theme line
    for i, line in ipairs(lines) do
        if line:match("^theme%s*=") then
            lines[i] = theme_line
            break
        end
    end

    -- Write the file safely with pcall
    local write_ok, err = pcall(vim.fn.writefile, lines, ghostty_config_file)
    if not write_ok then
        vim.notify_once("Failed to write ghostty config file: " .. (err or "unknown error"), vim.log.levels.ERROR)
    end
end

---Detects printwidth from .prettierrc or .editorconfig files
---@param start_path? string The directory to start searching from (defaults to current buffer directory)
---@return number|nil printwidth The detected printwidth or nil if not found
function M.detect_printwidth(start_path)
    start_path = start_path or vim.fn.expand("%:p:h")

    local function find_config_file(dir, filename)
        local filepath = dir .. "/" .. filename
        if vim.loop.fs_stat(filepath) then
            return filepath
        end

        local parent = vim.fn.fnamemodify(dir, ":h")
        if parent == dir then
            return nil
        end

        return find_config_file(parent, filename)
    end

    local function parse_prettierrc(filepath)
        local ok, content = pcall(vim.fn.readfile, filepath)
        if not ok or not content then
            return nil
        end

        local text = table.concat(content, "\n")

        -- Try to parse as JSON
        local json_ok, data = pcall(vim.fn.json_decode, text)
        if json_ok and data and data.printWidth then
            return tonumber(data.printWidth)
        end

        -- Fallback: simple pattern matching for printWidth
        local printwidth = text:match('"printWidth"%s*:%s*(%d+)')
        if printwidth then
            return tonumber(printwidth)
        end

        return nil
    end

    local function parse_editorconfig(filepath)
        local ok, lines = pcall(vim.fn.readfile, filepath)
        if not ok or not lines then
            return nil
        end

        local in_markdown_section = false
        local in_global_section = true
        local max_line_length = nil

        for _, line in ipairs(lines) do
            line = vim.trim(line)

            -- Skip comments and empty lines
            if line:match("^#") or line == "" then
                goto continue
            end

            -- Check for section headers
            if line:match("^%[.+%]$") then
                local section = line:match("^%[(.+)%]$")
                in_markdown_section = section:match("%.md$") or section:match("markdown") or section == "*"
                in_global_section = section == "*"
                goto continue
            end

            -- Look for max_line_length in relevant sections
            if (in_markdown_section or in_global_section) and line:match("^max_line_length") then
                local value = line:match("max_line_length%s*=%s*(%d+)")
                if value then
                    max_line_length = tonumber(value)
                    if in_markdown_section then
                        -- Prefer markdown-specific setting
                        return max_line_length
                    end
                end
            end

            ::continue::
        end

        return max_line_length
    end

    -- Try .prettierrc first
    local prettierrc_path = find_config_file(start_path, ".prettierrc")
    if prettierrc_path then
        local printwidth = parse_prettierrc(prettierrc_path)
        if printwidth then
            return printwidth
        end
    end

    -- Try .prettierrc.json
    local prettierrc_json_path = find_config_file(start_path, ".prettierrc.json")
    if prettierrc_json_path then
        local printwidth = parse_prettierrc(prettierrc_json_path)
        if printwidth then
            return printwidth
        end
    end

    -- Try .editorconfig
    local editorconfig_path = find_config_file(start_path, ".editorconfig")
    if editorconfig_path then
        local printwidth = parse_editorconfig(editorconfig_path)
        if printwidth then
            return printwidth
        end
    end

    return nil
end

return M
