#!/usr/bin/env bash
# New dots command for symlink-based dotfiles management

set -e

# Get the dots directory
DOTS_DIR="${DOTS_DIR:-$HOME/repos/nikbrunner/dots}"

# Colors for output
RED='\033[0;31m'
GREEN='\033[0;32m'
YELLOW='\033[0;33m'
BLUE='\033[0;34m'
NC='\033[0m' # No Color

# Change to dots directory for git operations
cd "$DOTS_DIR"

# Function to show usage
show_usage() {
    echo -e "${BLUE}dots - Dotfiles management command${NC}"
    echo ""
    echo "Usage: dots <command> [options]"
    echo ""
    echo "Commands:"
    echo "  install      - Initial setup with symlinks and submodules"
    echo "               Options: --dry-run"
    echo "  link         - Re-run symlink creation"
    echo "               Options: --force, --dry-run"
    echo "  sync         - Git pull + submodule updates"
    echo "  push         - Git add, commit, push"
    echo "  clean        - Remove broken symlinks"
    echo "               Options: --dry-run"
    echo "  sub-update   - Update all submodules"
    echo "  sub-add      - Add new submodule"
    echo "  status       - Show git and symlink status"
    echo "  log          - Show git log"
}

# Install command
cmd_install() {
    echo -e "${YELLOW}→${NC} Running installation..."
    "$DOTS_DIR/install.sh" "$@"
}

# Link command
cmd_link() {
    echo -e "${YELLOW}→${NC} Creating symlinks..."
    "$DOTS_DIR/scripts/link.sh" "$@"
}

# Sync command
cmd_sync() {
    echo -e "${YELLOW}→${NC} Syncing repository..."
    git pull origin main || git pull origin master
    
    if [[ -f .gitmodules ]]; then
        echo -e "${YELLOW}→${NC} Updating submodules..."
        "$DOTS_DIR/scripts/submodules.sh" update
    fi
    
    echo -e "${GREEN}✓${NC} Sync complete"
}

# Push command
cmd_push() {
    local message="${1:-Updates}"
    
    echo -e "${YELLOW}→${NC} Pushing changes..."
    
    # Check if there are changes
    if [[ -z $(git status --porcelain) ]]; then
        echo -e "${GREEN}✓${NC} No changes to commit"
        return 0
    fi
    
    git add -A
    git commit -m "$message"
    git push origin main || git push origin master
    
    echo -e "${GREEN}✓${NC} Changes pushed"
}

# Clean command
cmd_clean() {
    local dry_run=false
    if [[ "$1" == "--dry-run" ]]; then
        dry_run=true
        echo -e "${YELLOW}DRY RUN MODE - No changes will be made${NC}"
        echo ""
    fi
    
    echo -e "${YELLOW}→${NC} Cleaning broken dotfiles symlinks..."
    
    # Get current OS and mapping file
    source "$DOTS_DIR/scripts/detect-os.sh"
    local current_os=$(get_os)
    local mapping_file="$DOTS_DIR/.mappings/$current_os.json"
    
    # Generate mappings if they don't exist
    if [[ ! -f "$mapping_file" ]]; then
        echo -e "${YELLOW}→${NC} Generating mappings..."
        "$DOTS_DIR/scripts/generate-mappings.sh" > /dev/null
    fi
    
    if [[ ! -f "$mapping_file" ]]; then
        echo -e "${RED}✗${NC} Could not find or generate mapping file: $mapping_file"
        return 1
    fi
    
    local count=0
    
    # Check each symlink from our mappings
    while IFS=':' read -r source_part target_part; do
        # Skip lines that don't contain mappings
        [[ ! "$source_part" =~ \".*\" ]] && continue
        [[ ! "$target_part" =~ \".*\" ]] && continue
        
        # Clean up the target path
        local target=$(echo "$target_part" | sed 's/^[[:space:]]*"//' | sed 's/"[[:space:]]*,*[[:space:]]*$//')
        
        # Skip empty targets
        [[ -z "$target" ]] && continue
        
        # Check if this symlink is broken
        if [[ -L "$target" ]] && [[ ! -e "$target" ]]; then
            if [[ "$dry_run" == true ]]; then
                echo -e "${RED}✗${NC} [DRY] Would remove broken symlink: $target"
            else
                echo -e "${RED}✗${NC} Removing broken symlink: $target"
                rm "$target"
            fi
            ((count++))
        fi
        
    done < "$mapping_file"
    
    if [[ $count -eq 0 ]]; then
        echo -e "${GREEN}✓${NC} No broken dotfiles symlinks found"
    else
        if [[ "$dry_run" == true ]]; then
            echo -e "${GREEN}✓${NC} Would remove $count broken dotfiles symlinks"
        else
            echo -e "${GREEN}✓${NC} Removed $count broken dotfiles symlinks"
        fi
    fi
}

# Submodule update command
cmd_sub_update() {
    "$DOTS_DIR/scripts/submodules.sh" update
}

# Submodule add command
cmd_sub_add() {
    if [[ $# -lt 2 ]]; then
        echo -e "${RED}✗${NC} Usage: dots sub-add <repo_url> <path>"
        return 1
    fi
    "$DOTS_DIR/scripts/submodules.sh" add "$@"
}

# Status command - enhanced with symlink status using JSON mappings
cmd_status() {
    echo -e "${BLUE}=== Git Repository Status ===${NC}"
    git status --short
    
    echo ""
    echo -e "${BLUE}=== Symlink Status ===${NC}"
    
    # Get current OS and mapping file
    source "$DOTS_DIR/scripts/detect-os.sh"
    local current_os=$(get_os)
    local mapping_file="$DOTS_DIR/.mappings/$current_os.json"
    
    # Generate mappings if they don't exist
    if [[ ! -f "$mapping_file" ]]; then
        echo -e "${YELLOW}→${NC} Generating mappings..."
        "$DOTS_DIR/scripts/generate-mappings.sh" > /dev/null
    fi
    
    if [[ ! -f "$mapping_file" ]]; then
        echo -e "${RED}✗${NC} Could not find or generate mapping file: $mapping_file"
        return 1
    fi
    
    local total_links=0
    local valid_links=0
    local broken_links=0
    local missing_links=0
    local wrong_target_links=0
    
    echo "Checking symlinks from mappings..."
    
    # Check each symlink from our mappings
    while IFS=':' read -r source_part target_part; do
        # Skip lines that don't contain mappings
        [[ ! "$source_part" =~ \".*\" ]] && continue
        [[ ! "$target_part" =~ \".*\" ]] && continue
        
        # Clean up the paths
        local source=$(echo "$source_part" | sed 's/^[[:space:]]*"//' | sed 's/"[[:space:]]*$//')
        local target=$(echo "$target_part" | sed 's/^[[:space:]]*"//' | sed 's/"[[:space:]]*,*[[:space:]]*$//')
        
        # Skip empty paths
        [[ -z "$source" || -z "$target" ]] && continue
        
        ((total_links++))
        
        if [[ -L "$target" ]]; then
            # It's a symlink, check if it's valid
            local actual_target=$(readlink "$target")
            if [[ "$actual_target" == "$source" ]]; then
                ((valid_links++))
            else
                ((wrong_target_links++))
                echo -e "${YELLOW}⚠${NC}  Wrong target: $target → $actual_target"
                echo -e "    Expected: $source"
            fi
            
            # Check if target exists
            if [[ ! -e "$target" ]]; then
                ((broken_links++))
                echo -e "${RED}✗${NC} Broken link: $target"
            fi
        elif [[ -e "$target" ]]; then
            # File/directory exists but is not a symlink
            echo -e "${RED}✗${NC} Not a symlink: $target"
            echo -e "    Run 'dots link --force' to fix"
        else
            # Neither symlink nor file exists
            ((missing_links++))
            echo -e "${YELLOW}→${NC} Missing link: $target"
        fi
        
    done < "$mapping_file"
    
    # Summary
    echo ""
    echo -e "${BLUE}Summary:${NC}"
    echo -e "  Total expected links: $total_links"
    echo -e "  ${GREEN}✓${NC} Valid links: $valid_links"
    if [[ $wrong_target_links -gt 0 ]]; then
        echo -e "  ${YELLOW}⚠${NC} Wrong targets: $wrong_target_links"
    fi
    if [[ $broken_links -gt 0 ]]; then
        echo -e "  ${RED}✗${NC} Broken links: $broken_links"
    fi
    if [[ $missing_links -gt 0 ]]; then
        echo -e "  ${YELLOW}→${NC} Missing links: $missing_links"
    fi
    
}

# Log command
cmd_log() {
    echo -e "${YELLOW}→${NC} Recent commits:"
    git log --pretty=format:"%C(yellow)%h%Cred%d\\ %Creset%s%Cblue\\ [%cn]" --decorate -10
}

# Main command dispatcher
case "${1:-}" in
    install)
        shift
        cmd_install "$@"
        ;;
    link)
        shift
        cmd_link "$@"
        ;;
    sync)
        cmd_sync
        ;;
    push)
        shift
        cmd_push "$@"
        ;;
    clean)
        shift
        cmd_clean "$@"
        ;;
    sub-update)
        cmd_sub_update
        ;;
    sub-add)
        shift
        cmd_sub_add "$@"
        ;;
    status)
        cmd_status
        ;;
    log)
        cmd_log
        ;;
    *)
        show_usage
        ;;
esac