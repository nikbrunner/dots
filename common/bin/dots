#!/usr/bin/env bash
# New dots command for symlink-based dotfiles management

set -e

# Get the dots directory
DOTS_DIR="${DOTS_DIR:-$HOME/repos/nikbrunner/dots}"

# Capture the original working directory before changing to dots dir
ORIGINAL_PWD="$(pwd)"

# Colors for output
RED='\033[0;31m'
GREEN='\033[0;32m'
YELLOW='\033[0;33m'
BLUE='\033[0;34m'
NC='\033[0m' # No Color

# Change to dots directory for git operations
cd "$DOTS_DIR"

# Check for gum and provide helpful message if missing
check_gum() {
    if ! command -v gum >/dev/null 2>&1; then
        echo -e "${YELLOW}⚠${NC} gum not found - install for enhanced UI:"
        echo "  macOS: brew install gum"
        echo "  Linux: See https://github.com/charmbracelet/gum#installation"
        echo ""
        return 1
    fi
    return 0
}

# Enhanced output functions using gum when available
log_section() {
    if command -v gum >/dev/null 2>&1; then
        gum style --foreground=4 --bold "$1"
    else
        echo -e "${BLUE}$1${NC}"
    fi
}

log_success() {
    if command -v gum >/dev/null 2>&1; then
        gum style --foreground=2 "✓ $1"
    else
        echo -e "${GREEN}✓${NC} $1"
    fi
}

log_warning() {
    if command -v gum >/dev/null 2>&1; then
        gum style --foreground=3 "⚠ $1"
    else
        echo -e "${YELLOW}⚠${NC} $1"
    fi
}

log_error() {
    if command -v gum >/dev/null 2>&1; then
        gum style --foreground=1 "✗ $1"
    else
        echo -e "${RED}✗${NC} $1"
    fi
}

log_info() {
    if command -v gum >/dev/null 2>&1; then
        gum style --foreground=6 "→ $1"
    else
        echo -e "${YELLOW}→${NC} $1"
    fi
}

# Function to show usage
show_usage() {
    if command -v gum >/dev/null 2>&1; then
        gum style --border="rounded" --padding="1 2" --margin="1" \
            --foreground=4 --bold "dots - Dotfiles management command"
        echo ""
        gum style "Usage: dots <command> [options]"
        echo ""
        gum style --foreground=4 --bold "Commands:"
        gum style --foreground=2 "  install      - Initial setup with symlinks and submodules [--dry-run]"
        gum style --foreground=2 "  link         - Update all symlinks (clean broken + create new) [--dry-run]"
        gum style --foreground=2 "  sync         - Git pull + submodule updates"
        gum style --foreground=2 "  commit       - Open LazyGit for interactive committing"
        gum style --foreground=2 "  push         - Push commits to remote [--force]"
        gum style --foreground=2 "  sub-update   - Update all submodules"
        gum style --foreground=2 "  sub-add      - Add new submodule"
        gum style --foreground=2 "  status       - Show git and symlink status"
        gum style --foreground=2 "  test         - Run comprehensive system tests"
        gum style --foreground=2 "  format       - Format files (markdown, shell scripts, etc.)"
        gum style --foreground=2 "  hooks        - Install/reinstall git hooks"
        gum style --foreground=2 "  log          - Show git log"
        echo ""
    else
        echo -e "${BLUE}dots - Dotfiles management command${NC}"
        echo ""
        echo "Usage: dots <command> [options]"
        echo ""
        echo "Commands:"
        echo "  install      - Initial setup with symlinks and submodules [--dry-run]"
        echo "  link         - Update all symlinks (clean broken + create new) [--dry-run]"
        echo "  sync         - Git pull + submodule updates"
        echo "  commit       - Open LazyGit for interactive committing"
        echo "  push         - Push commits to remote [--force]"
        echo "  sub-update   - Update all submodules"
        echo "  sub-add      - Add new submodule"
        echo "  status       - Show git and symlink status"
        echo "  test         - Run comprehensive system tests"
        echo "  format       - Format files (markdown, shell scripts, etc.)"
        echo "  hooks        - Install/reinstall git hooks"
        echo "  log          - Show git log"
        echo ""
    fi
}

# Install command
cmd_install() {
    echo -e "${YELLOW}→${NC} Running installation..."
    "$DOTS_DIR/install.sh" "$@"
}

# Link command
cmd_link() {
    echo -e "${YELLOW}→${NC} Creating symlinks..."
    "$DOTS_DIR/scripts/link.sh" "$@"
}

# Sync command
cmd_sync() {
    echo -e "${YELLOW}→${NC} Syncing repository..."
    git pull origin main || git pull origin master

    if [[ -f .gitmodules ]]; then
        echo -e "${YELLOW}→${NC} Updating submodules..."
        "$DOTS_DIR/scripts/submodules.sh" update
    fi

    echo -e "${GREEN}✓${NC} Sync complete"
}

# Shared push function
do_push() {
    local force_flag="${1:-false}"

    log_info "Pushing to remote..."

    if [[ "$force_flag" == "true" ]]; then
        # Force push directly
        if command -v gum >/dev/null 2>&1; then
            gum spin --spinner="dot" --title="Force pushing..." -- git push --force-with-lease
        else
            git push --force-with-lease
        fi
        log_success "Changes force pushed"
    else
        # Try regular push
        if command -v gum >/dev/null 2>&1; then
            # Capture output to show error message
            local push_output
            if push_output=$(gum spin --spinner="dot" --title="Pushing..." -- git push 2>&1); then
                log_success "Changes pushed"
            else
                log_warning "Push failed:"
                echo "$push_output"
                echo ""
                if gum confirm "Force push with --force-with-lease?"; then
                    gum spin --spinner="dot" --title="Force pushing..." -- git push --force-with-lease
                    log_success "Changes force pushed"
                else
                    log_error "Push cancelled"
                    return 1
                fi
            fi
        else
            # Capture output to show error message
            local push_output
            if push_output=$(git push 2>&1); then
                log_success "Changes pushed"
            else
                log_warning "Push failed:"
                echo "$push_output"
                echo "Try: git push --force-with-lease"
                return 1
            fi
        fi
    fi
}

# Commit command - opens LazyGit for interactive committing
cmd_commit() {
    log_info "Opening LazyGit for commits..."

    if command -v lazygit >/dev/null 2>&1; then
        lazygit
    else
        log_error "LazyGit not found. Install with: brew install lazygit"
        return 1
    fi
}

# Push command - only pushes, no committing
cmd_push() {
    local force_flag=false
    if [[ "$1" == "--force" || "$1" == "-f" ]]; then
        force_flag=true
    fi

    # Check if there are any commits to push
    if [[ -z $(git log @{u}.. 2>/dev/null) ]]; then
        log_success "No commits to push"
        return 0
    fi

    do_push "$force_flag"
}

# Submodule update command
cmd_sub_update() {
    "$DOTS_DIR/scripts/submodules.sh" update
}

# Submodule add command
cmd_sub_add() {
    if [[ $# -lt 2 ]]; then
        echo -e "${RED}✗${NC} Usage: dots sub-add <repo_url> <path>"
        return 1
    fi
    "$DOTS_DIR/scripts/submodules.sh" add "$@"
}

# Status command - enhanced with symlink status using JSON mappings
cmd_status() {
    log_section "=== Git Repository Status ==="
    git status --short

    echo ""
    log_section "=== Symlink Status ==="

    # Get current OS and mapping file
    source "$DOTS_DIR/scripts/detect-os.sh"
    local current_os=$(get_os)
    local mapping_file="$DOTS_DIR/.mappings/$current_os.json"

    # Generate mappings if they don't exist
    if [[ ! -f "$mapping_file" ]]; then
        log_info "Generating mappings..."
        "$DOTS_DIR/scripts/generate-mappings.sh" >/dev/null
    fi

    if [[ ! -f "$mapping_file" ]]; then
        log_error "Could not find or generate mapping file: $mapping_file"
        return 1
    fi

    local total_links=0
    local valid_links=0
    local broken_links=0
    local missing_links=0
    local wrong_target_links=0

    if command -v gum >/dev/null 2>&1; then
        gum spin --spinner="dot" --title="Checking symlinks from mappings..." -- sleep 0.5
    else
        echo "Checking symlinks from mappings..."
    fi

    # Check each symlink from our mappings
    while IFS=':' read -r source_part target_part; do
        # Skip lines that don't contain mappings
        [[ ! "$source_part" =~ \".*\" ]] && continue
        [[ ! "$target_part" =~ \".*\" ]] && continue

        # Clean up the paths
        local source=$(echo "$source_part" | sed 's/^[[:space:]]*"//' | sed 's/"[[:space:]]*$//')
        local target=$(echo "$target_part" | sed 's/^[[:space:]]*"//' | sed 's/"[[:space:]]*,*[[:space:]]*$//')

        # Skip empty paths
        [[ -z "$source" || -z "$target" ]] && continue

        ((total_links++))

        if [[ -L "$target" ]]; then
            # It's a symlink, check if it's valid
            local actual_target=$(readlink "$target")
            if [[ "$actual_target" == "$source" ]]; then
                ((valid_links++))
            else
                ((wrong_target_links++))
                log_warning "Wrong target: $target → $actual_target"
                echo "    Expected: $source"
            fi

            # Check if target exists
            if [[ ! -e "$target" ]]; then
                ((broken_links++))
                log_error "Broken link: $target"
            fi
        elif [[ -e "$target" ]]; then
            # File/directory exists but is not a symlink
            log_error "Not a symlink: $target"
            echo "    Run 'dots link' to fix"
        else
            # Neither symlink nor file exists
            ((missing_links++))
            log_warning "Missing link: $target"
        fi

    done <"$mapping_file"

    # Summary
    echo ""
    log_section "Summary:"

    echo "  Total expected links: $total_links"
    log_success "Valid links: $valid_links"
    if [[ $wrong_target_links -gt 0 ]]; then
        log_warning "Wrong targets: $wrong_target_links"
    fi
    if [[ $broken_links -gt 0 ]]; then
        log_error "Broken links: $broken_links"
    fi
    if [[ $missing_links -gt 0 ]]; then
        log_info "Missing links: $missing_links"
    fi

}

# Test command - comprehensive system checks
cmd_test() {
    echo -e "${BLUE}=== Dotfiles System Test ===${NC}"
    echo ""

    local tests_passed=0
    local tests_failed=0

    # Test 1: Check if we're in the right directory
    echo -e "${YELLOW}→${NC} Testing repository structure..."
    if [[ -f "CLAUDE.md" && -d "scripts" && -d ".mappings" ]]; then
        echo -e "${GREEN}✓${NC} Repository structure OK"
        ((tests_passed++))
    else
        echo -e "${RED}✗${NC} Repository structure missing"
        ((tests_failed++))
    fi

    # Test 2: Check OS detection
    echo -e "${YELLOW}→${NC} Testing OS detection..."
    source "$DOTS_DIR/scripts/detect-os.sh"
    local detected_os=$(get_os)
    if [[ -n "$detected_os" && ("$detected_os" == "macos" || "$detected_os" == "linux") ]]; then
        echo -e "${GREEN}✓${NC} OS detection OK: $detected_os"
        ((tests_passed++))
    else
        echo -e "${RED}✗${NC} OS detection failed: $detected_os"
        ((tests_failed++))
    fi

    # Test 3: Check mapping generation
    echo -e "${YELLOW}→${NC} Testing mapping generation..."
    if "$DOTS_DIR/scripts/generate-mappings.sh" >/dev/null 2>&1; then
        echo -e "${GREEN}✓${NC} Mapping generation OK"
        ((tests_passed++))
    else
        echo -e "${RED}✗${NC} Mapping generation failed"
        ((tests_failed++))
    fi

    # Test 4: Check mapping files exist and are valid JSON
    echo -e "${YELLOW}→${NC} Testing mapping files..."
    local mapping_file="$DOTS_DIR/.mappings/$detected_os.json"
    if [[ -f "$mapping_file" ]] && python3 -m json.tool "$mapping_file" >/dev/null 2>&1; then
        local mapping_count=$(grep -o '":' "$mapping_file" | wc -l | tr -d ' ')
        echo -e "${GREEN}✓${NC} Mapping file OK: $mapping_count entries"
        ((tests_passed++))
    else
        echo -e "${RED}✗${NC} Mapping file invalid or missing"
        ((tests_failed++))
    fi

    # Test 5: Check symlink creation (dry run)
    echo -e "${YELLOW}→${NC} Testing symlink creation (dry run)..."
    if "$DOTS_DIR/scripts/link.sh" --dry-run >/dev/null 2>&1; then
        echo -e "${GREEN}✓${NC} Symlink creation test OK"
        ((tests_passed++))
    else
        echo -e "${RED}✗${NC} Symlink creation test failed"
        ((tests_failed++))
    fi

    # Test 6: Check critical symlinks exist and are correct
    echo -e "${YELLOW}→${NC} Testing critical symlinks..."
    local critical_links=("$HOME/.zshrc" "$HOME/.gitconfig" "$HOME/bin/dots")
    local valid_symlinks=0

    for link in "${critical_links[@]}"; do
        if [[ -L "$link" && -e "$link" ]]; then
            ((valid_symlinks++))
        fi
    done

    if [[ $valid_symlinks -eq ${#critical_links[@]} ]]; then
        echo -e "${GREEN}✓${NC} Critical symlinks OK ($valid_symlinks/${#critical_links[@]})"
        ((tests_passed++))
    else
        echo -e "${YELLOW}⚠${NC} Some critical symlinks missing ($valid_symlinks/${#critical_links[@]})"
        # Don't fail the test - symlinks might not be set up yet
        ((tests_passed++))
    fi

    # Test 7: Check git repository status
    echo -e "${YELLOW}→${NC} Testing git repository..."
    if git rev-parse --git-dir >/dev/null 2>&1; then
        echo -e "${GREEN}✓${NC} Git repository OK"
        ((tests_passed++))
    else
        echo -e "${RED}✗${NC} Git repository not found"
        ((tests_failed++))
    fi

    # Test 8: Lint shell scripts with shellcheck
    echo -e "${YELLOW}→${NC} Linting shell scripts..."
    if command -v shellcheck >/dev/null 2>&1; then
        local shell_files=()
        local lint_errors=0

        # Find all shell files
        while IFS= read -r -d '' file; do
            shell_files+=("$file")
        done < <(find . -name "*.sh" -not -path "./.git/*" -print0 2>/dev/null)

        # Add executable scripts with shell shebangs
        while IFS= read -r -d '' file; do
            if [[ -x "$file" && -f "$file" ]]; then
                local first_line=$(head -n1 "$file" 2>/dev/null)
                if [[ "$first_line" =~ ^#!.*/(bash|sh|zsh) ]]; then
                    shell_files+=("$file")
                fi
            fi
        done < <(find . -type f -not -path "./.git/*" -not -name "*.sh" -print0 2>/dev/null)

        if [[ ${#shell_files[@]} -gt 0 ]]; then
            local files_with_issues=()
            for file in "${shell_files[@]}"; do
                if ! shellcheck "$file" >/dev/null 2>&1; then
                    ((lint_errors++))
                    files_with_issues+=("$file")
                fi
            done

            if [[ $lint_errors -eq 0 ]]; then
                echo -e "${GREEN}✓${NC} Shell scripts lint OK (${#shell_files[@]} files)"
                ((tests_passed++))
            else
                echo -e "${YELLOW}⚠${NC} Shell scripts have lint issues ($lint_errors/${#shell_files[@]} files):"
                for file in "${files_with_issues[@]}"; do
                    echo ""
                    log_warning "Issues in $file:"
                    # Run shellcheck and indent the output
                    shellcheck "$file" 2>&1 | sed 's/^/      /'
                done
                # Don't fail the test - just warn about lint issues
                ((tests_passed++))
            fi
        else
            echo -e "${GREEN}✓${NC} No shell scripts found"
            ((tests_passed++))
        fi
    else
        echo -e "${YELLOW}⚠${NC} shellcheck not available, skipping shell script linting"
        echo "    Install with: brew install shellcheck"
        ((tests_passed++))
    fi

    # Summary
    echo ""
    echo -e "${BLUE}=== Test Summary ===${NC}"
    local total_tests=$((tests_passed + tests_failed))
    echo -e "  Total tests: $total_tests"
    echo -e "  ${GREEN}✓${NC} Passed: $tests_passed"

    if [[ $tests_failed -gt 0 ]]; then
        echo -e "  ${RED}✗${NC} Failed: $tests_failed"
        echo ""
        echo -e "${RED}❌ System tests FAILED${NC}"
        return 1
    else
        echo ""
        echo -e "${GREEN}🎉 All system tests PASSED${NC}"
        return 0
    fi
}

# Format command - format various file types
cmd_format() {
    echo -e "${BLUE}=== Formatting Files ===${NC}"
    echo ""

    local formatted_files=0
    local skipped_files=0
    local error_files=0

    # Check if we have prettier for markdown and JSON files
    if command -v npx >/dev/null 2>&1; then
        echo -e "${YELLOW}→${NC} Formatting markdown and JSON files..."

        # Use prettier with glob patterns for efficiency
        if npx prettier --write "**/*.{md,json}" --ignore-path /dev/null --ignore-unknown 2>/dev/null; then
            # Count the files that would be formatted
            local md_count=$(find . -name "*.md" -not -path "./.git/*" -not -path "./node_modules/*" | wc -l | tr -d ' ')
            local json_count=$(find . -name "*.json" -not -path "./.git/*" -not -path "./node_modules/*" | wc -l | tr -d ' ')
            local total_prettier_files=$((md_count + json_count))
            formatted_files=$((formatted_files + total_prettier_files))
            echo -e "${GREEN}✓${NC} Formatted $total_prettier_files files (markdown + JSON)"
        else
            echo -e "${RED}✗${NC} Failed to format with prettier"
            ((error_files++))
        fi
    else
        echo -e "${YELLOW}⚠${NC} npx not available, skipping markdown/JSON formatting"
        ((skipped_files++))
    fi

    # Check if we have shfmt for shell scripts
    if command -v shfmt >/dev/null 2>&1; then
        echo -e "${YELLOW}→${NC} Formatting shell scripts..."

        # Collect all shell files for batch processing
        local shell_files=()

        # Add .sh files
        while IFS= read -r -d '' file; do
            shell_files+=("$file")
        done < <(find . -name "*.sh" -not -path "./.git/*" -print0 2>/dev/null)

        # Add executable scripts with shell shebangs
        while IFS= read -r -d '' file; do
            if [[ -x "$file" && -f "$file" ]]; then
                local first_line=$(head -n1 "$file" 2>/dev/null)
                if [[ "$first_line" =~ ^#!.*/(bash|sh|zsh) ]]; then
                    shell_files+=("$file")
                fi
            fi
        done < <(find . -type f -not -path "./.git/*" -not -name "*.sh" -print0 2>/dev/null)

        # Format all shell files in one command if any found
        if [[ ${#shell_files[@]} -gt 0 ]]; then
            if shfmt -w -i 4 -ci "${shell_files[@]}" >/dev/null 2>&1; then
                formatted_files=$((formatted_files + ${#shell_files[@]}))
                echo -e "${GREEN}✓${NC} Formatted ${#shell_files[@]} shell scripts"
            else
                echo -e "${RED}✗${NC} Failed to format some shell scripts"
                ((error_files++))
            fi
        else
            echo -e "${YELLOW}→${NC} No shell scripts found"
        fi
    else
        echo -e "${YELLOW}⚠${NC} shfmt not available, skipping shell script formatting"
        echo -e "    Install with: brew install shfmt"
        ((skipped_files++))
    fi

    # Summary
    echo ""
    echo -e "${BLUE}=== Format Summary ===${NC}"
    echo -e "  ${GREEN}✓${NC} Formatted: $formatted_files files"
    if [[ $error_files -gt 0 ]]; then
        echo -e "  ${RED}✗${NC} Errors: $error_files files"
    fi
    if [[ $skipped_files -gt 0 ]]; then
        echo -e "  ${YELLOW}⚠${NC} Skipped: $skipped_files file types (tools not available)"
    fi

    if [[ $error_files -gt 0 ]]; then
        echo ""
        echo -e "${RED}❌ Some files failed to format${NC}"
        return 1
    else
        echo ""
        echo -e "${GREEN}🎉 Formatting complete${NC}"
        return 0
    fi
}

# Hooks command - install/reinstall git hooks
cmd_hooks() {
    log_info "Installing git hooks..."
    "$DOTS_DIR/scripts/install-hooks.sh"
}

# Log command
cmd_log() {
    echo -e "${YELLOW}→${NC} Recent commits:"
    git log --pretty=format:"%C(yellow)%h%Cred%d\\ %Creset%s%Cblue\\ [%cn]" --decorate -10
}

# Main command dispatcher
case "${1:-}" in
install)
    shift
    cmd_install "$@"
    ;;
link)
    shift
    cmd_link "$@"
    ;;
sync)
    cmd_sync
    ;;
commit)
    shift
    cmd_commit "$@"
    ;;
push)
    shift
    cmd_push "$@"
    ;;
sub-update)
    cmd_sub_update
    ;;
sub-add)
    shift
    cmd_sub_add "$@"
    ;;
status)
    cmd_status
    ;;
test)
    cmd_test
    ;;
format)
    cmd_format
    ;;
hooks)
    cmd_hooks
    ;;
log)
    cmd_log
    ;;
*)
    show_usage
    ;;
esac
