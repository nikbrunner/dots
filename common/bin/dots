#!/usr/bin/env bash
# New dots command for symlink-based dotfiles management

set -e

# Get the dots directory
DOTS_DIR="${DOTS_DIR:-$HOME/repos/nikbrunner/dots}"

# Capture the original working directory before changing to dots dir
ORIGINAL_PWD="$(pwd)"

# Colors for output
RED='\033[0;31m'
GREEN='\033[0;32m'
YELLOW='\033[0;33m'
BLUE='\033[0;34m'
NC='\033[0m' # No Color

# Change to dots directory for git operations
cd "$DOTS_DIR"

# Check for gum and provide helpful message if missing
check_gum() {
    if ! command -v gum >/dev/null 2>&1; then
        echo -e "${YELLOW}⚠${NC} gum not found - install for enhanced UI:"
        echo "  macOS: brew install gum"
        echo "  Linux: See https://github.com/charmbracelet/gum#installation"
        echo ""
        return 1
    fi
    return 0
}

# Enhanced output functions using gum when available
log_section() {
    if command -v gum >/dev/null 2>&1; then
        gum style --foreground=4 --bold "$1"
    else
        echo -e "${BLUE}$1${NC}"
    fi
}

log_success() {
    if command -v gum >/dev/null 2>&1; then
        gum style --foreground=2 "✓ $1"
    else
        echo -e "${GREEN}✓${NC} $1"
    fi
}

log_warning() {
    if command -v gum >/dev/null 2>&1; then
        gum style --foreground=3 "⚠ $1"
    else
        echo -e "${YELLOW}⚠${NC} $1"
    fi
}

log_error() {
    if command -v gum >/dev/null 2>&1; then
        gum style --foreground=1 "✗ $1"
    else
        echo -e "${RED}✗${NC} $1"
    fi
}

log_info() {
    if command -v gum >/dev/null 2>&1; then
        gum style --foreground=6 "→ $1"
    else
        echo -e "${YELLOW}→${NC} $1"
    fi
}

# Function to show usage
show_usage() {
    if command -v gum >/dev/null 2>&1; then
        gum style --border="rounded" --padding="1 2" --margin="1" \
            --foreground=4 --bold "dots - Dotfiles management command"
        echo ""
        gum style "Usage: dots <command> [options]"
        echo ""
        gum style --foreground=4 --bold "Commands:"
        gum style --foreground=2 "  install      - Initial setup with symlinks and submodules [--dry-run]"
        gum style --foreground=2 "  link         - Update all symlinks (clean broken + create new) [--dry-run] [--no-backup]"
        gum style --foreground=2 "  sync         - Git pull + submodule updates"
        gum style --foreground=2 "  commit       - Open LazyGit for interactive committing"
        gum style --foreground=2 "  push         - Push commits to remote [--force]"
        gum style --foreground=2 "  sub-update   - Update all submodules"
        gum style --foreground=2 "  sub-add      - Add new submodule"
        gum style --foreground=2 "  sub-commit   - Commit submodule hash updates"
        gum style --foreground=2 "  status       - Show git and symlink status"
        gum style --foreground=2 "  test         - Run comprehensive system tests"
        gum style --foreground=2 "  log          - Show git log"
        echo ""
    else
        echo -e "${BLUE}dots - Dotfiles management command${NC}"
        echo ""
        echo "Usage: dots <command> [options]"
        echo ""
        echo "Commands:"
        echo "  install      - Initial setup with symlinks and submodules [--dry-run]"
        echo "  link         - Update all symlinks (clean broken + create new) [--dry-run] [--no-backup]"
        echo "  sync         - Git pull + submodule updates"
        echo "  commit       - Open LazyGit for interactive committing"
        echo "  push         - Push commits to remote [--force]"
        echo "  sub-update   - Update all submodules"
        echo "  sub-add      - Add new submodule"
        echo "  sub-commit   - Commit submodule hash updates"
        echo "  status       - Show git and symlink status"
        echo "  test         - Run comprehensive system tests"
        echo "  log          - Show git log"
        echo ""
    fi
}

# Install command
cmd_install() {
    echo -e "${YELLOW}→${NC} Running installation..."
    "$DOTS_DIR/install.sh" "$@"
}

# Link command
cmd_link() {
    echo -e "${YELLOW}→${NC} Creating symlinks..."
    "$DOTS_DIR/scripts/link.sh" "$@"
}

# Sync command
cmd_sync() {
    echo -e "${YELLOW}→${NC} Syncing repository..."
    git pull origin main || git pull origin master

    if [[ -f .gitmodules ]]; then
        echo -e "${YELLOW}→${NC} Updating submodules..."
        "$DOTS_DIR/scripts/submodules.sh" update
    fi

    echo -e "${GREEN}✓${NC} Sync complete"
}

# Shared push function
do_push() {
    local force_flag="${1:-false}"

    log_info "Pushing to remote..."

    if [[ "$force_flag" == "true" ]]; then
        # Force push directly
        if command -v gum >/dev/null 2>&1; then
            gum spin --spinner="dot" --title="Force pushing..." -- git push --force-with-lease
        else
            git push --force-with-lease
        fi
        log_success "Changes force pushed"
    else
        # Try regular push
        if command -v gum >/dev/null 2>&1; then
            # Capture output to show error message
            local push_output
            if push_output=$(gum spin --spinner="dot" --title="Pushing..." -- git push 2>&1); then
                log_success "Changes pushed"
            else
                log_warning "Push failed:"
                echo "$push_output"
                echo ""
                if gum confirm "Force push with --force-with-lease?"; then
                    gum spin --spinner="dot" --title="Force pushing..." -- git push --force-with-lease
                    log_success "Changes force pushed"
                else
                    log_error "Push cancelled"
                    return 1
                fi
            fi
        else
            # Capture output to show error message
            local push_output
            if push_output=$(git push 2>&1); then
                log_success "Changes pushed"
            else
                log_warning "Push failed:"
                echo "$push_output"
                echo "Try: git push --force-with-lease"
                return 1
            fi
        fi
    fi
}

# Commit command - opens LazyGit for interactive committing
cmd_commit() {
    log_info "Opening LazyGit for commits..."

    if command -v lazygit >/dev/null 2>&1; then
        lazygit
    else
        log_error "LazyGit not found. Install with: brew install lazygit"
        return 1
    fi
}

# Push command - only pushes, no committing
cmd_push() {
    local force_flag=false
    if [[ "$1" == "--force" || "$1" == "-f" ]]; then
        force_flag=true
    fi

    # Check if there are any commits to push
    if [[ -z $(git log @{u}.. 2>/dev/null) ]]; then
        log_success "No commits to push"
        return 0
    fi

    do_push "$force_flag"
}

# Submodule update command
cmd_sub_update() {
    "$DOTS_DIR/scripts/submodules.sh" update
}

# Submodule add command
cmd_sub_add() {
    if [[ $# -lt 2 ]]; then
        echo -e "${RED}✗${NC} Usage: dots sub-add <repo_url> <path>"
        return 1
    fi
    "$DOTS_DIR/scripts/submodules.sh" add "$@"
}

# Submodule commit command - commits submodule hash updates
cmd_sub_commit() {
    log_info "Checking for submodule changes..."
    
    # Check if there are any submodule changes
    local submodule_changes
    submodule_changes=$(git status --porcelain | grep "^M " | grep -E "(common|macos|linux)/.+")
    
    if [[ -z "$submodule_changes" ]]; then
        log_warning "No submodule changes found to commit"
        return 0
    fi
    
    log_info "Found submodule changes:"
    echo "$submodule_changes" | while read -r line; do
        echo "  $line"
    done
    
    # Add all submodule changes
    echo "$submodule_changes" | while read -r status file; do
        git add "$file"
    done
    
    # Create commit message
    local commit_msg="chore: update submodule commit hashes"
    
    # Add submodule details to commit message
    local submodule_list
    submodule_list=$(echo "$submodule_changes" | sed 's/^M  /- /' | tr '\n' '\n')
    
    if command -v gum >/dev/null 2>&1; then
        gum spin --spinner="dot" --title="Committing submodule updates..." -- \
            git commit -m "$commit_msg"$'\n\n'"$submodule_list"
    else
        git commit -m "$commit_msg"$'\n\n'"$submodule_list"
    fi
    
    log_success "Submodule changes committed"
}

# Status command - enhanced with symlink status using direct directory traversal
cmd_status() {
    log_section "=== Git Repository Status ==="
    git status --short

    echo ""
    log_section "=== Symlink Status ==="

    # Get current OS
    source "$DOTS_DIR/scripts/detect-os.sh"
    local current_os=$(get_os)

    local total_links=0
    local valid_links=0
    local broken_links=0
    local missing_links=0
    local wrong_target_links=0

    if command -v gum >/dev/null 2>&1; then
        gum spin --spinner="dot" --title="Checking symlinks..." -- sleep 0.5
    else
        echo "Checking symlinks..."
    fi

    # Function to check symlinks from a directory
    check_directory_symlinks() {
        local source_dir="$1"
        local target_base="$2"
        
        [[ ! -d "$source_dir" ]] && return
        
        # Find all files and symlinks recursively
        while IFS= read -r -d '' file; do
            # Calculate relative path and target
            local rel_path="${file#"$source_dir"/}"
            local target="$target_base/$rel_path"
            
            ((total_links++))

            if [[ -L "$target" ]]; then
                # It's a symlink, check if it's valid
                local actual_target=$(readlink "$target")
                if [[ "$actual_target" == "$file" ]]; then
                    ((valid_links++))
                else
                    ((wrong_target_links++))
                    log_warning "Wrong target: $target → $actual_target"
                    echo "    Expected: $file"
                fi

                # Check if target exists
                if [[ ! -e "$target" ]]; then
                    ((broken_links++))
                    log_error "Broken link: $target"
                fi
            elif [[ -e "$target" ]]; then
                # File/directory exists but is not a symlink
                log_error "Not a symlink: $target"
                echo "    Run 'dots link' to fix"
            else
                # Neither symlink nor file exists
                ((missing_links++))
                log_warning "Missing link: $target"
            fi

        done < <(find "$source_dir" \( -type f -o -type l \) -print0 2>/dev/null)
    }

    # Check common files
    check_directory_symlinks "$DOTS_DIR/common" "$HOME"

    # Check OS-specific files
    if [[ "$current_os" == "macos" && -d "$DOTS_DIR/macos" ]]; then
        check_directory_symlinks "$DOTS_DIR/macos" "$HOME"
    elif [[ "$current_os" == "linux" && -d "$DOTS_DIR/linux" ]]; then
        check_directory_symlinks "$DOTS_DIR/linux" "$HOME"
    fi

    # Summary
    echo ""
    log_section "Summary:"

    echo "  Total expected links: $total_links"
    log_success "Valid links: $valid_links"
    if [[ $wrong_target_links -gt 0 ]]; then
        log_warning "Wrong targets: $wrong_target_links"
    fi
    if [[ $broken_links -gt 0 ]]; then
        log_error "Broken links: $broken_links"
    fi
    if [[ $missing_links -gt 0 ]]; then
        log_info "Missing links: $missing_links"
    fi

}

# Test command - comprehensive system checks
cmd_test() {
    echo -e "${BLUE}=== Dotfiles System Test ===${NC}"
    echo ""

    local tests_passed=0
    local tests_failed=0

    # Test 1: Check if we're in the right directory
    echo -e "${YELLOW}→${NC} Testing repository structure..."
    if [[ -f "CLAUDE.md" && -d "scripts" && -d "common" ]]; then
        echo -e "${GREEN}✓${NC} Repository structure OK"
        ((tests_passed++))
    else
        echo -e "${RED}✗${NC} Repository structure missing"
        ((tests_failed++))
    fi

    # Test 2: Check OS detection
    echo -e "${YELLOW}→${NC} Testing OS detection..."
    source "$DOTS_DIR/scripts/detect-os.sh"
    local detected_os=$(get_os)
    if [[ -n "$detected_os" && ("$detected_os" == "macos" || "$detected_os" == "linux") ]]; then
        echo -e "${GREEN}✓${NC} OS detection OK: $detected_os"
        ((tests_passed++))
    else
        echo -e "${RED}✗${NC} OS detection failed: $detected_os"
        ((tests_failed++))
    fi

    # Test 3: Check directory structure
    echo -e "${YELLOW}→${NC} Testing directory structure..."
    local expected_dirs=("$DOTS_DIR/common" "$DOTS_DIR/$detected_os" "$DOTS_DIR/scripts")
    local missing_dirs=0
    for dir in "${expected_dirs[@]}"; do
        if [[ ! -d "$dir" ]]; then
            ((missing_dirs++))
        fi
    done
    if [[ $missing_dirs -eq 0 ]]; then
        echo -e "${GREEN}✓${NC} Directory structure OK"
        ((tests_passed++))
    else
        echo -e "${RED}✗${NC} Directory structure incomplete ($missing_dirs missing)"
        ((tests_failed++))
    fi

    # Test 4: Check symlink creation (dry run)
    echo -e "${YELLOW}→${NC} Testing symlink creation (dry run)..."
    if "$DOTS_DIR/scripts/link.sh" --dry-run >/dev/null 2>&1; then
        echo -e "${GREEN}✓${NC} Symlink creation test OK"
        ((tests_passed++))
    else
        echo -e "${RED}✗${NC} Symlink creation test failed"
        ((tests_failed++))
    fi

    # Test 5: Check critical symlinks exist and are correct
    echo -e "${YELLOW}→${NC} Testing critical symlinks..."
    local critical_links=("$HOME/.zshrc" "$HOME/.gitconfig" "$HOME/bin/dots")
    local valid_symlinks=0

    for link in "${critical_links[@]}"; do
        if [[ -L "$link" && -e "$link" ]]; then
            ((valid_symlinks++))
        fi
    done

    if [[ $valid_symlinks -eq ${#critical_links[@]} ]]; then
        echo -e "${GREEN}✓${NC} Critical symlinks OK ($valid_symlinks/${#critical_links[@]})"
        ((tests_passed++))
    else
        echo -e "${YELLOW}⚠${NC} Some critical symlinks missing ($valid_symlinks/${#critical_links[@]})"
        # Don't fail the test - symlinks might not be set up yet
        ((tests_passed++))
    fi

    # Test 6: Check git repository status
    echo -e "${YELLOW}→${NC} Testing git repository..."
    if git rev-parse --git-dir >/dev/null 2>&1; then
        echo -e "${GREEN}✓${NC} Git repository OK"
        ((tests_passed++))
    else
        echo -e "${RED}✗${NC} Git repository not found"
        ((tests_failed++))
    fi

    # Test 7: Lint shell scripts with shellcheck
    echo -e "${YELLOW}→${NC} Linting shell scripts..."
    if command -v shellcheck >/dev/null 2>&1; then
        local shell_files=()
        local lint_errors=0

        # Find all shell files
        while IFS= read -r -d '' file; do
            shell_files+=("$file")
        done < <(find . -name "*.sh" -not -path "./.git/*" -print0 2>/dev/null)

        # Add executable scripts with shell shebangs
        while IFS= read -r -d '' file; do
            if [[ -x "$file" && -f "$file" ]]; then
                local first_line=$(head -n1 "$file" 2>/dev/null)
                if [[ "$first_line" =~ ^#!.*/(bash|sh|zsh) ]]; then
                    shell_files+=("$file")
                fi
            fi
        done < <(find . -type f -not -path "./.git/*" -not -name "*.sh" -print0 2>/dev/null)

        if [[ ${#shell_files[@]} -gt 0 ]]; then
            local files_with_issues=()
            for file in "${shell_files[@]}"; do
                if ! shellcheck "$file" >/dev/null 2>&1; then
                    ((lint_errors++))
                    files_with_issues+=("$file")
                fi
            done

            if [[ $lint_errors -eq 0 ]]; then
                echo -e "${GREEN}✓${NC} Shell scripts lint OK (${#shell_files[@]} files)"
                ((tests_passed++))
            else
                echo -e "${YELLOW}⚠${NC} Shell scripts have lint issues ($lint_errors/${#shell_files[@]} files):"
                for file in "${files_with_issues[@]}"; do
                    echo ""
                    log_warning "Issues in $file:"
                    # Run shellcheck and indent the output
                    shellcheck "$file" 2>&1 | sed 's/^/      /'
                done
                # Don't fail the test - just warn about lint issues
                ((tests_passed++))
            fi
        else
            echo -e "${GREEN}✓${NC} No shell scripts found"
            ((tests_passed++))
        fi
    else
        echo -e "${YELLOW}⚠${NC} shellcheck not available, skipping shell script linting"
        echo "    Install with: brew install shellcheck"
        ((tests_passed++))
    fi

    # Summary
    echo ""
    echo -e "${BLUE}=== Test Summary ===${NC}"
    local total_tests=$((tests_passed + tests_failed))
    echo -e "  Total tests: $total_tests"
    echo -e "  ${GREEN}✓${NC} Passed: $tests_passed"

    if [[ $tests_failed -gt 0 ]]; then
        echo -e "  ${RED}✗${NC} Failed: $tests_failed"
        echo ""
        echo -e "${RED}❌ System tests FAILED${NC}"
        return 1
    else
        echo ""
        echo -e "${GREEN}🎉 All system tests PASSED${NC}"
        return 0
    fi
}


# Log command
cmd_log() {
    echo -e "${YELLOW}→${NC} Recent commits:"
    git log --pretty=format:"%C(yellow)%h%Cred%d\\ %Creset%s%Cblue\\ [%cn]" --decorate -10
}

# Main command dispatcher
case "${1:-}" in
install)
    shift
    cmd_install "$@"
    ;;
link)
    shift
    cmd_link "$@"
    ;;
sync)
    cmd_sync
    ;;
commit)
    shift
    cmd_commit "$@"
    ;;
push)
    shift
    cmd_push "$@"
    ;;
sub-update)
    cmd_sub_update
    ;;
sub-add)
    shift
    cmd_sub_add "$@"
    ;;
sub-commit)
    cmd_sub_commit
    ;;
status)
    cmd_status
    ;;
test)
    cmd_test
    ;;
log)
    cmd_log
    ;;
*)
    show_usage
    ;;
esac
