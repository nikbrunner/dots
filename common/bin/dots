#!/usr/bin/env bash
# New dots command for symlink-based dotfiles management

set -e

# Get the dots directory
DOTS_DIR="${DOTS_DIR:-$HOME/repos/nikbrunner/dots}"

# Colors for output
RED='\033[0;31m'
GREEN='\033[0;32m'
YELLOW='\033[0;33m'
BLUE='\033[0;34m'
NC='\033[0m' # No Color

# Change to dots directory for git operations
cd "$DOTS_DIR"

# Function to show usage
show_usage() {
    echo -e "${BLUE}dots - Dotfiles management command${NC}"
    echo ""
    echo "Usage: dots <command> [options]"
    echo ""
    echo "Commands:"
    echo "  install      - Initial setup with symlinks and submodules [--dry-run]"
    echo "  link         - Re-run symlink creation [--dry-run]"
    echo "  sync         - Git pull + submodule updates"
    echo "  push         - Git add, commit, push"
    echo "  clean        - Remove broken symlinks [--dry-run]"
    echo "  sub-update   - Update all submodules"
    echo "  sub-add      - Add new submodule"
    echo "  status       - Show git and symlink status"
    echo "  test         - Run comprehensive system tests"
    echo "  log          - Show git log"
    echo ""
}

# Install command
cmd_install() {
    echo -e "${YELLOW}→${NC} Running installation..."
    "$DOTS_DIR/install.sh" "$@"
}

# Link command
cmd_link() {
    echo -e "${YELLOW}→${NC} Creating symlinks..."
    "$DOTS_DIR/scripts/link.sh" "$@"
}

# Sync command
cmd_sync() {
    echo -e "${YELLOW}→${NC} Syncing repository..."
    git pull origin main || git pull origin master
    
    if [[ -f .gitmodules ]]; then
        echo -e "${YELLOW}→${NC} Updating submodules..."
        "$DOTS_DIR/scripts/submodules.sh" update
    fi
    
    echo -e "${GREEN}✓${NC} Sync complete"
}

# Push command
cmd_push() {
    local message="${1:-Updates}"
    
    echo -e "${YELLOW}→${NC} Pushing changes..."
    
    # Check if there are changes
    if [[ -z $(git status --porcelain) ]]; then
        echo -e "${GREEN}✓${NC} No changes to commit"
        return 0
    fi
    
    git add -A
    git commit -m "$message"
    git push origin main || git push origin master
    
    echo -e "${GREEN}✓${NC} Changes pushed"
}

# Clean command
cmd_clean() {
    local dry_run=false
    if [[ "$1" == "--dry-run" ]]; then
        dry_run=true
        echo -e "${YELLOW}DRY RUN MODE - No changes will be made${NC}"
        echo ""
    fi
    
    echo -e "${YELLOW}→${NC} Cleaning broken dotfiles symlinks..."
    
    # Get current OS and mapping file
    source "$DOTS_DIR/scripts/detect-os.sh"
    local current_os=$(get_os)
    local mapping_file="$DOTS_DIR/.mappings/$current_os.json"
    
    # Generate mappings if they don't exist
    if [[ ! -f "$mapping_file" ]]; then
        echo -e "${YELLOW}→${NC} Generating mappings..."
        "$DOTS_DIR/scripts/generate-mappings.sh" > /dev/null
    fi
    
    if [[ ! -f "$mapping_file" ]]; then
        echo -e "${RED}✗${NC} Could not find or generate mapping file: $mapping_file"
        return 1
    fi
    
    local count=0
    
    # Check each symlink from our mappings
    while IFS=':' read -r source_part target_part; do
        # Skip lines that don't contain mappings
        [[ ! "$source_part" =~ \".*\" ]] && continue
        [[ ! "$target_part" =~ \".*\" ]] && continue
        
        # Clean up the target path
        local target=$(echo "$target_part" | sed 's/^[[:space:]]*"//' | sed 's/"[[:space:]]*,*[[:space:]]*$//')
        
        # Skip empty targets
        [[ -z "$target" ]] && continue
        
        # Check if this symlink is broken
        if [[ -L "$target" ]] && [[ ! -e "$target" ]]; then
            if [[ "$dry_run" == true ]]; then
                echo -e "${RED}✗${NC} [DRY] Would remove broken symlink: $target"
            else
                echo -e "${RED}✗${NC} Removing broken symlink: $target"
                rm "$target"
            fi
            ((count++))
        fi
        
    done < "$mapping_file"
    
    if [[ $count -eq 0 ]]; then
        echo -e "${GREEN}✓${NC} No broken dotfiles symlinks found"
    else
        if [[ "$dry_run" == true ]]; then
            echo -e "${GREEN}✓${NC} Would remove $count broken dotfiles symlinks"
        else
            echo -e "${GREEN}✓${NC} Removed $count broken dotfiles symlinks"
        fi
    fi
}

# Submodule update command
cmd_sub_update() {
    "$DOTS_DIR/scripts/submodules.sh" update
}

# Submodule add command
cmd_sub_add() {
    if [[ $# -lt 2 ]]; then
        echo -e "${RED}✗${NC} Usage: dots sub-add <repo_url> <path>"
        return 1
    fi
    "$DOTS_DIR/scripts/submodules.sh" add "$@"
}

# Status command - enhanced with symlink status using JSON mappings
cmd_status() {
    echo -e "${BLUE}=== Git Repository Status ===${NC}"
    git status --short
    
    echo ""
    echo -e "${BLUE}=== Symlink Status ===${NC}"
    
    # Get current OS and mapping file
    source "$DOTS_DIR/scripts/detect-os.sh"
    local current_os=$(get_os)
    local mapping_file="$DOTS_DIR/.mappings/$current_os.json"
    
    # Generate mappings if they don't exist
    if [[ ! -f "$mapping_file" ]]; then
        echo -e "${YELLOW}→${NC} Generating mappings..."
        "$DOTS_DIR/scripts/generate-mappings.sh" > /dev/null
    fi
    
    if [[ ! -f "$mapping_file" ]]; then
        echo -e "${RED}✗${NC} Could not find or generate mapping file: $mapping_file"
        return 1
    fi
    
    local total_links=0
    local valid_links=0
    local broken_links=0
    local missing_links=0
    local wrong_target_links=0
    
    echo "Checking symlinks from mappings..."
    
    # Check each symlink from our mappings
    while IFS=':' read -r source_part target_part; do
        # Skip lines that don't contain mappings
        [[ ! "$source_part" =~ \".*\" ]] && continue
        [[ ! "$target_part" =~ \".*\" ]] && continue
        
        # Clean up the paths
        local source=$(echo "$source_part" | sed 's/^[[:space:]]*"//' | sed 's/"[[:space:]]*$//')
        local target=$(echo "$target_part" | sed 's/^[[:space:]]*"//' | sed 's/"[[:space:]]*,*[[:space:]]*$//')
        
        # Skip empty paths
        [[ -z "$source" || -z "$target" ]] && continue
        
        ((total_links++))
        
        if [[ -L "$target" ]]; then
            # It's a symlink, check if it's valid
            local actual_target=$(readlink "$target")
            if [[ "$actual_target" == "$source" ]]; then
                ((valid_links++))
            else
                ((wrong_target_links++))
                echo -e "${YELLOW}⚠${NC}  Wrong target: $target → $actual_target"
                echo -e "    Expected: $source"
            fi
            
            # Check if target exists
            if [[ ! -e "$target" ]]; then
                ((broken_links++))
                echo -e "${RED}✗${NC} Broken link: $target"
            fi
        elif [[ -e "$target" ]]; then
            # File/directory exists but is not a symlink
            echo -e "${RED}✗${NC} Not a symlink: $target"
            echo -e "    Run 'dots link --force' to fix"
        else
            # Neither symlink nor file exists
            ((missing_links++))
            echo -e "${YELLOW}→${NC} Missing link: $target"
        fi
        
    done < "$mapping_file"
    
    # Summary
    echo ""
    echo -e "${BLUE}Summary:${NC}"
    echo -e "  Total expected links: $total_links"
    echo -e "  ${GREEN}✓${NC} Valid links: $valid_links"
    if [[ $wrong_target_links -gt 0 ]]; then
        echo -e "  ${YELLOW}⚠${NC} Wrong targets: $wrong_target_links"
    fi
    if [[ $broken_links -gt 0 ]]; then
        echo -e "  ${RED}✗${NC} Broken links: $broken_links"
    fi
    if [[ $missing_links -gt 0 ]]; then
        echo -e "  ${YELLOW}→${NC} Missing links: $missing_links"
    fi
    
}

# Test command - comprehensive system checks
cmd_test() {
    echo -e "${BLUE}=== Dotfiles System Test ===${NC}"
    echo ""
    
    local tests_passed=0
    local tests_failed=0
    
    # Test 1: Check if we're in the right directory
    echo -e "${YELLOW}→${NC} Testing repository structure..."
    if [[ -f "CLAUDE.md" && -d "scripts" && -d ".mappings" ]]; then
        echo -e "${GREEN}✓${NC} Repository structure OK"
        ((tests_passed++))
    else
        echo -e "${RED}✗${NC} Repository structure missing"
        ((tests_failed++))
    fi
    
    # Test 2: Check OS detection
    echo -e "${YELLOW}→${NC} Testing OS detection..."
    source "$DOTS_DIR/scripts/detect-os.sh"
    local detected_os=$(get_os)
    if [[ -n "$detected_os" && ("$detected_os" == "macos" || "$detected_os" == "linux") ]]; then
        echo -e "${GREEN}✓${NC} OS detection OK: $detected_os"
        ((tests_passed++))
    else
        echo -e "${RED}✗${NC} OS detection failed: $detected_os"
        ((tests_failed++))
    fi
    
    # Test 3: Check mapping generation
    echo -e "${YELLOW}→${NC} Testing mapping generation..."
    if "$DOTS_DIR/scripts/generate-mappings.sh" > /dev/null 2>&1; then
        echo -e "${GREEN}✓${NC} Mapping generation OK"
        ((tests_passed++))
    else
        echo -e "${RED}✗${NC} Mapping generation failed"
        ((tests_failed++))
    fi
    
    # Test 4: Check mapping files exist and are valid JSON
    echo -e "${YELLOW}→${NC} Testing mapping files..."
    local mapping_file="$DOTS_DIR/.mappings/$detected_os.json"
    if [[ -f "$mapping_file" ]] && python3 -m json.tool "$mapping_file" > /dev/null 2>&1; then
        local mapping_count=$(grep -o '":' "$mapping_file" | wc -l | tr -d ' ')
        echo -e "${GREEN}✓${NC} Mapping file OK: $mapping_count entries"
        ((tests_passed++))
    else
        echo -e "${RED}✗${NC} Mapping file invalid or missing"
        ((tests_failed++))
    fi
    
    # Test 5: Check symlink creation (dry run)
    echo -e "${YELLOW}→${NC} Testing symlink creation (dry run)..."
    if "$DOTS_DIR/scripts/link.sh" --dry-run > /dev/null 2>&1; then
        echo -e "${GREEN}✓${NC} Symlink creation test OK"
        ((tests_passed++))
    else
        echo -e "${RED}✗${NC} Symlink creation test failed"
        ((tests_failed++))
    fi
    
    # Test 6: Check critical symlinks exist and are correct
    echo -e "${YELLOW}→${NC} Testing critical symlinks..."
    local critical_links=("$HOME/.zshrc" "$HOME/.gitconfig" "$HOME/bin/dots")
    local valid_symlinks=0
    
    for link in "${critical_links[@]}"; do
        if [[ -L "$link" && -e "$link" ]]; then
            ((valid_symlinks++))
        fi
    done
    
    if [[ $valid_symlinks -eq ${#critical_links[@]} ]]; then
        echo -e "${GREEN}✓${NC} Critical symlinks OK ($valid_symlinks/${#critical_links[@]})"
        ((tests_passed++))
    else
        echo -e "${YELLOW}⚠${NC} Some critical symlinks missing ($valid_symlinks/${#critical_links[@]})"
        # Don't fail the test - symlinks might not be set up yet
        ((tests_passed++))
    fi
    
    # Test 7: Check git repository status
    echo -e "${YELLOW}→${NC} Testing git repository..."
    if git rev-parse --git-dir > /dev/null 2>&1; then
        echo -e "${GREEN}✓${NC} Git repository OK"
        ((tests_passed++))
    else
        echo -e "${RED}✗${NC} Git repository not found"
        ((tests_failed++))
    fi
    
    # Summary
    echo ""
    echo -e "${BLUE}=== Test Summary ===${NC}"
    local total_tests=$((tests_passed + tests_failed))
    echo -e "  Total tests: $total_tests"
    echo -e "  ${GREEN}✓${NC} Passed: $tests_passed"
    
    if [[ $tests_failed -gt 0 ]]; then
        echo -e "  ${RED}✗${NC} Failed: $tests_failed"
        echo ""
        echo -e "${RED}❌ System tests FAILED${NC}"
        return 1
    else
        echo ""
        echo -e "${GREEN}🎉 All system tests PASSED${NC}"
        return 0
    fi
}

# Log command
cmd_log() {
    echo -e "${YELLOW}→${NC} Recent commits:"
    git log --pretty=format:"%C(yellow)%h%Cred%d\\ %Creset%s%Cblue\\ [%cn]" --decorate -10
}

# Main command dispatcher
case "${1:-}" in
    install)
        shift
        cmd_install "$@"
        ;;
    link)
        shift
        cmd_link "$@"
        ;;
    sync)
        cmd_sync
        ;;
    push)
        shift
        cmd_push "$@"
        ;;
    clean)
        shift
        cmd_clean "$@"
        ;;
    sub-update)
        cmd_sub_update
        ;;
    sub-add)
        shift
        cmd_sub_add "$@"
        ;;
    status)
        cmd_status
        ;;
    test)
        cmd_test
        ;;
    log)
        cmd_log
        ;;
    *)
        show_usage
        ;;
esac