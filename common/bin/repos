#!/usr/bin/env bash

# Configuration
REPOS_BASE_PATH="${REPOS_BASE_PATH:-$HOME/repos}"

# List of repositories to ensure are cloned
ENSURE_CLONED=(
    # Add repositories here, examples:
    # "git@github.com:username/repo.git"
    # "https://github.com/username/repo.git"
    # "git@github.com:organization/*"  # Clone all repos from organization
    "git@github.com:nikbrunner/dots"
    "git@github.com:black-atom-industries/*"
)

# Default parallel clone jobs
DEFAULT_PARALLEL_JOBS=4

# Colors for output
GREEN='\033[0;32m'
RED='\033[0;31m'
YELLOW='\033[0;33m'
NC='\033[0m' # No Color

# Helper functions
print_success() {
    echo -e "${GREEN}✓ $1${NC}"
}

print_error() {
    echo -e "${RED}✗ $1${NC}"
}

print_warning() {
    echo -e "${YELLOW}⚠ $1${NC}"
}

# Check if gum is available
has_gum() {
    command -v gum &>/dev/null
}

# Dependency check
check_dependencies() {
    local missing_deps=()
    
    for cmd in git fzf tmux; do
        if ! command -v "$cmd" &>/dev/null; then
            missing_deps+=("$cmd")
        fi
    done
    
    if [[ ${#missing_deps[@]} -gt 0 ]]; then
        print_error "Missing required dependencies: ${missing_deps[*]}"
        echo "Please install the missing dependencies and try again."
        exit 1
    fi
    
    # Check if REPOS_BASE_PATH exists
    if [[ ! -d "$REPOS_BASE_PATH" ]]; then
        print_warning "Repository base path does not exist: $REPOS_BASE_PATH"
        echo -n "Create it? (y/N) "
        read -r create_dir
        if [[ "$create_dir" == "y" || "$create_dir" == "Y" ]]; then
            if ! mkdir -p "$REPOS_BASE_PATH"; then
                print_error "Failed to create directory: $REPOS_BASE_PATH"
                exit 1
            fi
            print_success "Created directory: $REPOS_BASE_PATH"
        else
            exit 1
        fi
    fi
}

# Confirm action with gum or fallback
confirm_action() {
    local prompt="$1"
    
    if has_gum; then
        gum confirm "$prompt"
    else
        echo -n "$prompt (y/N) "
        read -r confirm
        [[ "$confirm" == "y" || "$confirm" == "Y" ]]
    fi
}

# Select repository with fzf or gum filter
select_repo() {
    local prompt="$1"
    local repos
    repos=$(list_repos)
    
    if [[ -z "$repos" ]]; then
        print_error "No repositories found"
        return 1
    fi
    
    if has_gum; then
        echo "$repos" | gum filter --placeholder "$prompt"
    else
        echo "$repos" | fzf --prompt="$prompt" --height=10 --reverse
    fi
}

# Get tmux session name from repo path
get_session_name() {
    echo "$1" | tr '/:.' '-'
}

# Parse git URL to extract username and repo name
parse_git_url() {
    local url="$1"
    local username repo_name
    
    # Remove .git suffix if present
    url="${url%.git}"
    
    if [[ "$url" =~ ^git@.*:(.+)/(.+)$ ]]; then
        # SSH URL format: git@github.com:username/repo
        username="${BASH_REMATCH[1]}"
        repo_name="${BASH_REMATCH[2]}"
    elif [[ "$url" =~ ^https?://.*github\.com/(.+)/(.+)$ ]]; then
        # HTTPS URL format: https://github.com/username/repo
        username="${BASH_REMATCH[1]}"
        repo_name="${BASH_REMATCH[2]}"
    else
        print_error "Invalid Git URL format"
        return 1
    fi
    
    echo "$username/$repo_name"
}

# Clone a single repository
clone_single_repo() {
    local git_url="$1"
    local show_progress="${2:-true}"
    
    local repo_path
    repo_path=$(parse_git_url "$git_url") || return 1
    
    local clone_path="$REPOS_BASE_PATH/$repo_path"
    
    if [[ -d "$clone_path" ]]; then
        echo "Skipping $repo_path (already exists)"
        return 2  # Already exists
    fi
    
    # Create parent directory
    if ! mkdir -p "$(dirname "$clone_path")"; then
        print_error "Failed to create directory for $repo_path"
        return 1
    fi
    
    echo "Cloning $repo_path..."
    
    if [[ "$show_progress" == "true" ]]; then
        if git clone "$git_url" "$clone_path"; then
            print_success "Cloned $repo_path"
            return 0
        else
            print_error "Failed to clone $repo_path"
            return 1
        fi
    else
        if git clone "$git_url" "$clone_path" >/dev/null 2>&1; then
            print_success "Cloned $repo_path"
            return 0
        else
            print_error "Failed to clone $repo_path"
            return 1
        fi
    fi
}

# Add a repository
add_repo() {
    local git_url="$1"
    
    if [[ -z "$git_url" ]]; then
        print_error "Please provide a git URL"
        echo "Usage: repos add <git-url>"
        exit 1
    fi
    
    clone_single_repo "$git_url" true
}

# List all repositories
list_repos() {
    if [[ ! -d "$REPOS_BASE_PATH" ]]; then
        return
    fi
    
    find "$REPOS_BASE_PATH" -mindepth 2 -maxdepth 2 -type d 2>/dev/null |
        sed "s|$REPOS_BASE_PATH/||" |
        sort
}

# Remove a repository
remove_repo() {
    local selected
    selected=$(select_repo "Select repository to remove: ")
    
    if [[ -z "$selected" ]]; then
        echo "No repository selected"
        exit 0
    fi
    
    local repo_path="$REPOS_BASE_PATH/$selected"
    
    # Kill tmux session if it exists
    local session_name
    session_name=$(get_session_name "$selected")
    tmux kill-session -t "$session_name" 2>/dev/null && \
        print_warning "Killed tmux session: $session_name"
    
    # Confirm removal
    if confirm_action "Are you sure you want to remove $selected?"; then
        if rm -rf "$repo_path"; then
            print_success "Repository removed: $selected"
        else
            print_error "Failed to remove repository: $selected"
            exit 1
        fi
    else
        echo "Removal cancelled"
    fi
}

# Open a repository in tmux
open_repo() {
    local selected
    selected=$(select_repo "Select repository to open: ")
    
    if [[ -z "$selected" ]]; then
        echo "No repository selected"
        exit 0
    fi
    
    local repo_path="$REPOS_BASE_PATH/$selected"
    local session_name
    session_name=$(get_session_name "$selected")
    
    # Check if session already exists
    if tmux has-session -t "$session_name" 2>/dev/null; then
        if [[ -n "$TMUX" ]]; then
            tmux switch-client -t "$session_name"
        else
            tmux attach-session -t "$session_name"
        fi
    else
        # Create new session
        if [[ -n "$TMUX" ]]; then
            tmux new-session -d -s "$session_name" -c "$repo_path"
            tmux switch-client -t "$session_name"
        else
            tmux new-session -s "$session_name" -c "$repo_path"
        fi
    fi
}

# Guide user through dependency installation
install_deps() {
    echo "repos - Dependency Installation Guide"
    echo "===================================="
    echo
    
    # Check current status
    local missing_required=()
    local missing_optional=()
    
    # Check required dependencies
    for cmd in git fzf tmux; do
        if ! command -v "$cmd" &>/dev/null; then
            missing_required+=("$cmd")
        else
            print_success "$cmd is installed"
        fi
    done
    
    # Check optional dependencies
    if ! command -v gum &>/dev/null; then
        missing_optional+=("gum")
    else
        print_success "gum is installed (optional - enhanced UX)"
    fi
    
    if ! command -v gh &>/dev/null; then
        missing_optional+=("gh")
    else
        print_success "gh is installed (optional - wildcard repo cloning)"
        # Check if authenticated
        if ! gh auth status &>/dev/null; then
            print_warning "GitHub CLI is not authenticated"
            echo "  Run: gh auth login"
        else
            print_success "GitHub CLI is authenticated"
        fi
    fi
    
    echo
    
    # Installation instructions for missing dependencies
    if [[ ${#missing_required[@]} -gt 0 ]]; then
        echo "Required dependencies to install:"
        for dep in "${missing_required[@]}"; do
            print_error "$dep is missing"
        done
        echo
        
        # OS-specific installation instructions
        case "$(uname)" in
            Darwin)
                echo "macOS installation (using Homebrew):"
                echo "  brew install git fzf tmux"
                ;;
            Linux)
                # Detect Linux distribution
                if command -v apt &>/dev/null; then
                    echo "Ubuntu/Debian installation:"
                    echo "  sudo apt update && sudo apt install git fzf tmux"
                elif command -v yum &>/dev/null; then
                    echo "CentOS/RHEL installation:"
                    echo "  sudo yum install git fzf tmux"
                elif command -v pacman &>/dev/null; then
                    echo "Arch Linux installation:"
                    echo "  sudo pacman -S git fzf tmux"
                else
                    echo "Linux installation (check your package manager):"
                    echo "  Install: git fzf tmux"
                fi
                ;;
            *)
                echo "Please install the missing dependencies using your system's package manager"
                ;;
        esac
        echo
    fi
    
    if [[ ${#missing_optional[@]} -gt 0 ]]; then
        echo "Optional dependencies for enhanced experience:"
        for dep in "${missing_optional[@]}"; do
            print_warning "$dep is not installed (optional)"
        done
        echo
        
        # Installation instructions for optional deps
        case "$(uname)" in
            Darwin)
                echo "macOS installation (using Homebrew):"
                [[ " ${missing_optional[*]} " =~ " gum " ]] && echo "  brew install gum"
                [[ " ${missing_optional[*]} " =~ " gh " ]] && echo "  brew install gh"
                ;;
            Linux)
                if command -v apt &>/dev/null; then
                    echo "Ubuntu/Debian installation:"
                    [[ " ${missing_optional[*]} " =~ " gum " ]] && echo "  # gum: https://github.com/charmbracelet/gum#installation"
                    [[ " ${missing_optional[*]} " =~ " gh " ]] && echo "  sudo apt install gh"
                elif command -v pacman &>/dev/null; then
                    echo "Arch Linux installation:"
                    [[ " ${missing_optional[*]} " =~ " gum " ]] && echo "  sudo pacman -S gum"
                    [[ " ${missing_optional[*]} " =~ " gh " ]] && echo "  sudo pacman -S github-cli"
                else
                    echo "Linux installation:"
                    [[ " ${missing_optional[*]} " =~ " gum " ]] && echo "  gum: https://github.com/charmbracelet/gum#installation"
                    [[ " ${missing_optional[*]} " =~ " gh " ]] && echo "  gh: https://cli.github.com/"
                fi
                ;;
            *)
                [[ " ${missing_optional[*]} " =~ " gum " ]] && echo "  gum: https://github.com/charmbracelet/gum#installation"
                [[ " ${missing_optional[*]} " =~ " gh " ]] && echo "  gh: https://cli.github.com/"
                ;;
        esac
        echo
    fi
    
    # GitHub CLI authentication note
    if command -v gh &>/dev/null && ! gh auth status &>/dev/null; then
        echo "📋 GitHub CLI Authentication:"
        echo "  After installing gh, authenticate with:"
        echo "  gh auth login"
        echo
        echo "  This is required for wildcard repository cloning (e.g., 'org/*' patterns)"
        echo
    fi
    
    # Summary
    if [[ ${#missing_required[@]} -eq 0 ]]; then
        print_success "All required dependencies are installed!"
        if [[ ${#missing_optional[@]} -eq 0 ]]; then
            print_success "All optional dependencies are also installed!"
            echo "You're ready to use all repos features! 🎉"
        else
            echo "You can use repos now, with enhanced features available after installing optional dependencies."
        fi
    else
        echo "Install the required dependencies above, then run 'repos install' again to verify."
        exit 1
    fi
}

# Show git status for all repos
status_repos() {
    local repos
    repos=$(list_repos)
    
    if [[ -z "$repos" ]]; then
        print_error "No repositories found"
        exit 1
    fi
    
    echo "Checking status of all repositories..."
    echo
    
    local has_changes=false
    
    while IFS= read -r repo; do
        [[ -z "$repo" ]] && continue
        
        local repo_path="$REPOS_BASE_PATH/$repo"
        cd "$repo_path" || continue
        
        # Check if it's a git repository
        if [[ ! -d .git ]]; then
            print_warning "$repo is not a git repository"
            continue
        fi
        
        # Get git status
        local status_output
        status_output=$(git status --porcelain 2>/dev/null)
        
        if [[ -n "$status_output" ]]; then
            has_changes=true
            echo -e "${YELLOW}$repo${NC}"
            git status --short
            echo
        fi
    done <<<"$repos"
    
    if [[ "$has_changes" == false ]]; then
        print_success "All repositories are clean"
    fi
}

# Find and open files across all repositories
find_files() {
    local repos
    repos=$(list_repos)
    
    if [[ -z "$repos" ]]; then
        print_error "No repositories found"
        exit 1
    fi
    
    # Check if EDITOR is set
    if [[ -z "$EDITOR" ]]; then
        print_warning "EDITOR environment variable not set, using 'vim' as default"
        local editor="vim"
    else
        local editor="$EDITOR"
    fi
    
    echo "Searching files across all repositories..."
    
    # Build list of all git-tracked files with repo prefix
    local temp_file
    temp_file=$(mktemp)
    
    while IFS= read -r repo; do
        [[ -z "$repo" ]] && continue
        
        local repo_path="$REPOS_BASE_PATH/$repo"
        
        # Check if it's a git repository
        if [[ ! -d "$repo_path/.git" ]]; then
            continue
        fi
        
        # Get all git-tracked files and prefix with repo name
        (cd "$repo_path" && git ls-files 2>/dev/null | sed "s|^|$repo/|") >> "$temp_file"
    done <<<"$repos"
    
    # Check if any files were found
    if [[ ! -s "$temp_file" ]]; then
        rm -f "$temp_file"
        print_error "No git-tracked files found in any repository"
        exit 1
    fi
    
    # Use fzf to select file with preview
    local selected_file
    selected_file=$(cat "$temp_file" | fzf \
        --prompt="Search files: " \
        --height=20 \
        --reverse \
        --preview "head -50 $REPOS_BASE_PATH/{}" \
        --preview-window=right:50%:wrap)
    
    rm -f "$temp_file"
    
    if [[ -z "$selected_file" ]]; then
        echo "No file selected"
        exit 0
    fi
    
    local full_path="$REPOS_BASE_PATH/$selected_file"
    
    if [[ ! -f "$full_path" ]]; then
        print_error "File not found: $full_path"
        exit 1
    fi
    
    echo "Opening $selected_file with $editor..."
    "$editor" "$full_path"
}

# Check if gh CLI is installed and authenticated
check_gh_cli() {
    if ! command -v gh &>/dev/null; then
        print_error "GitHub CLI (gh) is not installed"
        echo "Install it from: https://cli.github.com/"
        return 1
    fi
    
    if ! gh auth status &>/dev/null; then
        print_error "GitHub CLI is not authenticated"
        echo "Run: gh auth login"
        return 1
    fi
    
    return 0
}

# Get all repositories for an organization/user using GitHub CLI
get_github_repos() {
    local org_user="$1"
    
    # Check gh CLI before proceeding
    check_gh_cli || return 1
    
    # Use gh to list repos (it handles both users and orgs automatically)
    local repos
    
    if has_gum; then
        repos=$(gum spin --spinner dot --title "Fetching repositories for $org_user..." -- \
            gh repo list "$org_user" --limit 1000 --json name --jq '.[].name' 2>/dev/null)
    else
        echo "Fetching repositories for $org_user..."
        repos=$(gh repo list "$org_user" --limit 1000 --json name --jq '.[].name' 2>/dev/null)
    fi
    
    if [[ -z "$repos" ]]; then
        # Try as user if org failed
        repos=$(gh api "users/$org_user/repos?per_page=100" --jq '.[].name' 2>/dev/null)
    fi
    
    echo "$repos"
}

# Parallel clone helper function
parallel_clone() {
    local git_url="$1"
    local repo_path
    repo_path=$(parse_git_url "$git_url") || return 1
    
    local clone_path="$REPOS_BASE_PATH/$repo_path"
    
    if [[ -d "$clone_path" ]]; then
        echo "SKIP:$repo_path"
        return 0
    fi
    
    mkdir -p "$(dirname "$clone_path")" 2>/dev/null
    
    if git clone "$git_url" "$clone_path" >/dev/null 2>&1; then
        echo "OK:$repo_path"
        return 0
    else
        echo "FAIL:$repo_path"
        return 1
    fi
}

export -f parallel_clone parse_git_url print_success print_error
export REPOS_BASE_PATH

# Setup repositories from ENSURE_CLONED list
setup_repos() {
    local parallel_jobs="${PARALLEL_JOBS:-$DEFAULT_PARALLEL_JOBS}"
    
    if [[ ${#ENSURE_CLONED[@]} -eq 0 ]]; then
        print_error "No repositories defined in ENSURE_CLONED variable"
        echo "Edit this script and add repositories to the ENSURE_CLONED array"
        exit 1
    fi
    
    # Check if any wildcard patterns exist that would need gh CLI
    local has_wildcards=false
    for pattern in "${ENSURE_CLONED[@]}"; do
        if [[ "$pattern" == *"/*" ]]; then
            has_wildcards=true
            break
        fi
    done
    
    if [[ "$has_wildcards" == true ]]; then
        check_gh_cli || exit 1
    fi
    
    local clone_urls=()
    
    # First, expand all patterns to get actual URLs
    for repo_pattern in "${ENSURE_CLONED[@]}"; do
        # Skip comments and empty lines
        [[ "$repo_pattern" =~ ^[[:space:]]*# ]] && continue
        [[ -z "$repo_pattern" ]] && continue
        
        # Check if it's a wildcard pattern
        if [[ "$repo_pattern" == *"/*" ]]; then
            # Extract organization/user from wildcard pattern
            local base_url="${repo_pattern%/*}"
            local org_user
            
            if [[ "$base_url" =~ git@.*:(.+)$ ]]; then
                org_user="${BASH_REMATCH[1]}"
            elif [[ "$base_url" =~ https?://.*github\.com/(.+)$ ]]; then
                org_user="${BASH_REMATCH[1]}"
            else
                print_error "Invalid wildcard pattern: $repo_pattern"
                continue
            fi
            
            local repos
            if ! repos=$(get_github_repos "$org_user"); then
                continue
            fi
            
            if [[ -z "$repos" ]]; then
                print_error "No repositories found for $org_user"
                continue
            fi
            
            # Add each repository URL
            while IFS= read -r repo_name; do
                [[ -z "$repo_name" ]] && continue
                clone_urls+=("${base_url}/${repo_name}.git")
            done <<<"$repos"
        else
            # Single repository
            clone_urls+=("$repo_pattern")
        fi
    done
    
    if [[ ${#clone_urls[@]} -eq 0 ]]; then
        print_error "No repositories to clone"
        exit 1
    fi
    
    echo "Found ${#clone_urls[@]} repositories to process"
    echo "Using $parallel_jobs parallel jobs"
    echo
    
    # Use parallel cloning
    echo "Cloning repositories (this may take a while)..."
    local results
    results=$(printf '%s\n' "${clone_urls[@]}" | \
        xargs -P "$parallel_jobs" -I {} bash -c 'parallel_clone "{}"')
    
    # Process results
    local cloned=0
    local skipped=0
    local failed=0
    
    while IFS= read -r result; do
        [[ -z "$result" ]] && continue
        
        case "$result" in
            OK:*)
                ((cloned++))
                print_success "Cloned ${result#OK:}"
                ;;
            SKIP:*)
                ((skipped++))
                echo "Skipped ${result#SKIP:} (already exists)"
                ;;
            FAIL:*)
                ((failed++))
                print_error "Failed ${result#FAIL:}"
                ;;
        esac
    done <<<"$results"
    
    local total=$((cloned + skipped + failed))
    
    echo
    print_success "Setup complete: $total repositories processed"
    echo "  Cloned: $cloned"
    echo "  Skipped: $skipped"
    echo "  Failed: $failed"
}

# Show help
show_help() {
    cat <<EOF
repos - Minimal repository manager

Usage:
  repos install            Guide through dependency installation
  repos add <git-url>      Clone a repository to organized path
  repos remove             Remove a repository (interactive)
  repos open               Open a repository in tmux (interactive)
  repos find               Find and open files across all repositories
  repos status             Show git status for all repositories
  repos setup              Clone all repositories from ENSURE_CLONED list
  repos help               Show this help message

Environment Variables:
  REPOS_BASE_PATH          Override repository base path (default: ~/repos)
  PARALLEL_JOBS            Number of parallel clone jobs (default: 4)

Repository base path: $REPOS_BASE_PATH

Examples:
  repos install            # Check dependencies and get installation guide
  repos add git@github.com:username/repo.git
  repos add https://github.com/username/repo.git
  repos remove
  repos open
  repos find               # Search and open files with $EDITOR
  repos status
  PARALLEL_JOBS=8 repos setup

Setup wildcard support:
  Edit the ENSURE_CLONED variable in this script to include:
  - Individual repos: "git@github.com:username/repo.git"
  - All repos from user/org: "git@github.com:organization/*"

Requirements:
  - git, fzf, tmux (required)
  - gum (optional, for better UX)
  - GitHub CLI (gh) for wildcard patterns
    - Install: https://cli.github.com/
    - Authenticate: gh auth login
EOF
}

# Initialize - check dependencies
check_dependencies

# Main command handler
case "${1:-}" in
install)
    install_deps
    ;;
add)
    add_repo "$2"
    ;;
remove)
    remove_repo
    ;;
open)
    open_repo
    ;;
find)
    find_files
    ;;
status)
    status_repos
    ;;
setup)
    setup_repos
    ;;
help | --help | -h)
    show_help
    ;;
*)
    if [[ -n "$1" ]]; then
        print_error "Unknown command: $1"
    fi
    show_help
    exit 1
    ;;
esac