#!/usr/bin/env bash

# Configuration
CONFIG_FILE="${XDG_CONFIG_HOME:-$HOME/.config}/repos/config.json"

# Defaults (can be overridden by config file)
_DEFAULT_REPOS_BASE_PATH="$HOME/repos"
_DEFAULT_PARALLEL_JOBS=4
_DEFAULT_TMUX_LAYOUT="ide"
_DEFAULT_TMUX_LAYOUTS_DIR="$HOME/.config/tmux/layouts"

# Colors for output
GREEN='\033[0;32m'
RED='\033[0;31m'
YELLOW='\033[0;33m'
NC='\033[0m' # No Color

# Helper functions
print_success() {
    echo -e "${GREEN}âœ“ $1${NC}"
}

print_error() {
    echo -e "${RED}âœ— $1${NC}"
}

print_warning() {
    echo -e "${YELLOW}âš  $1${NC}"
}

# Load configuration (config file > defaults)
load_config() {
    REPOS_BASE_PATH="$_DEFAULT_REPOS_BASE_PATH"
    DEFAULT_PARALLEL_JOBS="$_DEFAULT_PARALLEL_JOBS"
    TMUX_LAYOUT="$_DEFAULT_TMUX_LAYOUT"
    TMUX_LAYOUTS_DIR="$_DEFAULT_TMUX_LAYOUTS_DIR"

    if [[ -f "$CONFIG_FILE" ]]; then
        local val

        val=$(jq -r '.repos_base_path // empty' "$CONFIG_FILE" 2>/dev/null)
        [[ -n "$val" ]] && REPOS_BASE_PATH="${val/#\~/$HOME}"

        val=$(jq -r '.parallel_jobs // empty' "$CONFIG_FILE" 2>/dev/null)
        [[ -n "$val" ]] && DEFAULT_PARALLEL_JOBS="$val"

        val=$(jq -r '.tmux_layout // empty' "$CONFIG_FILE" 2>/dev/null)
        [[ -n "$val" ]] && TMUX_LAYOUT="$val"

        val=$(jq -r '.tmux_layouts_dir // empty' "$CONFIG_FILE" 2>/dev/null)
        [[ -n "$val" ]] && TMUX_LAYOUTS_DIR="${val/#\~/$HOME}"
    fi
}

# Get repositories to ensure are cloned from config (as JSON array)
get_ensure_cloned() {
    if [[ ! -f "$CONFIG_FILE" ]]; then
        return 1
    fi
    jq -c '.ensure_cloned[]? // empty' "$CONFIG_FILE" 2>/dev/null
}

# Extract URL from ensure_cloned entry (handles both string and object formats)
# Usage: get_entry_url <entry>
get_entry_url() {
    local entry="$1"
    if [[ "$entry" == "{"* ]]; then
        # It's a JSON object, extract url field
        echo "$entry" | jq -r '.url // empty'
    else
        # It's a plain string (remove quotes if present)
        echo "$entry" | tr -d '"'
    fi
}

# Extract postClone command from ensure_cloned entry
# Usage: get_entry_post_clone <entry>
get_entry_post_clone() {
    local entry="$1"
    if [[ "$entry" == "{"* ]]; then
        # It's a JSON object, extract postClone field
        echo "$entry" | jq -r '.postClone // empty'
    fi
    # Plain strings don't have postClone
}

# Create default configuration file
init_config() {
    local config_dir
    config_dir=$(dirname "$CONFIG_FILE")

    if [[ -f "$CONFIG_FILE" ]]; then
        print_warning "Config file already exists: $CONFIG_FILE"
        if ! confirm_action "Overwrite existing config?"; then
            echo "Aborted."
            return 1
        fi
    fi

    mkdir -p "$config_dir"

    cat > "$CONFIG_FILE" << 'EOF'
{
  "repos_base_path": "~/repos",
  "parallel_jobs": 4,
  "tmux_layout": "ide",
  "tmux_layouts_dir": "~/.config/tmux/layouts",
  "ensure_cloned": [
    "git@github.com:username/repo.git"
  ]
}
EOF

    print_success "Created config file: $CONFIG_FILE"
    echo "Edit it to add your repositories and customize settings."
}

# Initialize configuration - call early
load_config

# Check if gum is available (only used for confirmations)
has_gum() {
    command -v gum &>/dev/null
}

# Dependency check
check_dependencies() {
    local missing_deps=()

    for cmd in git fzf tmux jq; do
        if ! command -v "$cmd" &>/dev/null; then
            missing_deps+=("$cmd")
        fi
    done

    if [[ ${#missing_deps[@]} -gt 0 ]]; then
        print_error "Missing required dependencies: ${missing_deps[*]}"
        echo "Please install the missing dependencies and try again."
        exit 1
    fi

    # Check if REPOS_BASE_PATH exists
    if [[ ! -d "$REPOS_BASE_PATH" ]]; then
        print_warning "Repository base path does not exist: $REPOS_BASE_PATH"
        echo -n "Create it? (y/N) "
        read -r create_dir
        if [[ "$create_dir" == "y" || "$create_dir" == "Y" ]]; then
            if ! mkdir -p "$REPOS_BASE_PATH"; then
                print_error "Failed to create directory: $REPOS_BASE_PATH"
                exit 1
            fi
            print_success "Created directory: $REPOS_BASE_PATH"
        else
            exit 1
        fi
    fi
}

# Confirm action with gum or fallback
confirm_action() {
    local prompt="$1"

    if has_gum; then
        gum confirm "$prompt"
    else
        echo -n "$prompt (y/N) "
        read -r confirm
        [[ "$confirm" == "y" || "$confirm" == "Y" ]]
    fi
}

# Select repository with styled fzf
select_repo() {
    local prompt="$1"
    local repos
    repos=$(list_repos)

    if [[ -z "$repos" ]]; then
        print_error "No repositories found"
        return 1
    fi

    echo "$repos" | styled_fzf "$prompt"
}

# Get tmux session name from repo path
get_session_name() {
    echo "$1" | tr '/:.' '-'
}

# Set FZF config file path
styled_fzf() {
    local prompt="${1:-Select: }"
    local preview_cmd="${2:-}"
    local additional_args=("${@:3}")

    local fzf_args=(--border-label="â”ƒ repos â”ƒ" --prompt="$prompt")

    # Add preview if provided
    if [[ -n "$preview_cmd" ]]; then
        fzf_args+=(--preview "$preview_cmd" --preview-window=down:50%:wrap)
    fi

    # Add any additional arguments
    fzf_args+=("${additional_args[@]}")

    fzf "${fzf_args[@]}"
}

# Parse git URL to extract username and repo name
parse_git_url() {
    local url="$1"
    local username repo_name

    # Remove .git suffix if present
    url="${url%.git}"

    if [[ "$url" =~ ^git@.*:(.+)/(.+)$ ]]; then
        # SSH URL format: git@github.com:username/repo
        username="${BASH_REMATCH[1]}"
        repo_name="${BASH_REMATCH[2]}"
    elif [[ "$url" =~ ^https?://.*github\.com/(.+)/(.+)$ ]]; then
        # HTTPS URL format: https://github.com/username/repo
        username="${BASH_REMATCH[1]}"
        repo_name="${BASH_REMATCH[2]}"
    else
        print_error "Invalid Git URL format"
        return 1
    fi

    echo "$username/$repo_name"
}

# Clone a single repository
clone_single_repo() {
    local git_url="$1"
    local show_progress="${2:-true}"

    local repo_path
    repo_path=$(parse_git_url "$git_url") || return 1

    local clone_path="$REPOS_BASE_PATH/$repo_path"

    if [[ -d "$clone_path" ]]; then
        echo "Skipping $repo_path (already exists)"
        return 2 # Already exists
    fi

    # Create parent directory
    if ! mkdir -p "$(dirname "$clone_path")"; then
        print_error "Failed to create directory for $repo_path"
        return 1
    fi

    echo "Cloning $repo_path..."

    if [[ "$show_progress" == "true" ]]; then
        if git clone "$git_url" "$clone_path"; then
            print_success "Cloned $repo_path"
            return 0
        else
            print_error "Failed to clone $repo_path"
            return 1
        fi
    else
        if git clone "$git_url" "$clone_path" >/dev/null 2>&1; then
            print_success "Cloned $repo_path"
            return 0
        else
            print_error "Failed to clone $repo_path"
            return 1
        fi
    fi
}

# Interactive repository selection and cloning
interactive_add() {
    # Check gh CLI
    check_gh_cli || exit 1

    # Get authenticated username
    local username
    username=$(gh api user --jq .login 2>/dev/null)

    if [[ -z "$username" ]]; then
        print_error "Failed to get GitHub username"
        exit 1
    fi

    # Fetch all repos for the user
    local all_repos
    all_repos=$(get_github_repos "$username")

    if [[ -z "$all_repos" ]]; then
        print_error "No repositories found for user: $username"
        exit 1
    fi

    # Get list of already cloned repos (just repo names)
    local cloned_repos
    cloned_repos=$(list_repos | sed 's|^.*/||')

    # Filter out already cloned repos
    local available_repos
    available_repos=$(comm -23 <(echo "$all_repos" | sort) <(echo "$cloned_repos" | sort))

    if [[ -z "$available_repos" ]]; then
        print_success "All of your repositories are already cloned!"
        exit 0
    fi

    # Use fzf to select a repo
    local selected_repo
    selected_repo=$(echo "$available_repos" | styled_fzf "Select repository to clone: ")

    if [[ -z "$selected_repo" ]]; then
        echo "No repository selected"
        exit 0
    fi

    # Construct SSH URL and clone
    local git_url="git@github.com:${username}/${selected_repo}.git"
    clone_single_repo "$git_url" true
}

# Add a repository
add_repo() {
    local git_url="$1"

    if [[ -z "$git_url" ]]; then
        # No argument provided - use interactive mode
        interactive_add
        return
    fi

    clone_single_repo "$git_url" true
}

# List all repositories
list_repos() {
    if [[ ! -d "$REPOS_BASE_PATH" ]]; then
        return
    fi

    find "$REPOS_BASE_PATH" -mindepth 2 -maxdepth 2 -type d 2>/dev/null |
        sed "s|$REPOS_BASE_PATH/||" |
        sort
}

# Remove a repository
remove_repo() {
    local selected
    selected=$(select_repo "Select repository to remove: ")

    if [[ -z "$selected" ]]; then
        echo "No repository selected"
        exit 0
    fi

    local repo_path="$REPOS_BASE_PATH/$selected"

    # Kill tmux session if it exists
    local session_name
    session_name=$(get_session_name "$selected")
    tmux kill-session -t "$session_name" 2>/dev/null &&
        print_warning "Killed tmux session: $session_name"

    # Confirm removal
    if confirm_action "Are you sure you want to remove $selected?"; then
        if rm -rf "$repo_path"; then
            print_success "Repository removed: $selected"
        else
            print_error "Failed to remove repository: $selected"
            exit 1
        fi
    else
        echo "Removal cancelled"
    fi
}

# Open a repository in tmux
open_repo() {
    local selected="$1"

    # If no argument provided, use interactive selection
    if [[ -z "$selected" ]]; then
        selected=$(select_repo "Select repository to open: ")

        if [[ -z "$selected" ]]; then
            echo "No repository selected"
            exit 0
        fi
    fi

    # Check if the repository exists
    local repo_path="$REPOS_BASE_PATH/$selected"
    if [[ ! -d "$repo_path" ]]; then
        print_error "Repository not found: $selected"
        echo "Available repositories:"
        list_repos | head -10
        echo "..."
        echo "Use 'repos open' without arguments for interactive selection"
        exit 1
    fi

    local session_name
    session_name=$(get_session_name "$selected")

    # Check if session already exists (exact match, not prefix match)
    if tmux list-sessions -F "#{session_name}" 2>/dev/null | grep -qx "$session_name"; then
        if [[ -n "$TMUX" ]]; then
            tmux switch-client -t "$session_name"
        else
            tmux attach-session -t "$session_name"
        fi
    else
        # Create new session
        tmux new-session -d -s "$session_name" -c "$repo_path"

        # Apply layout if configured and layout script exists
        local layout_script="${TMUX_LAYOUTS_DIR}/${TMUX_LAYOUT}.sh"
        if [[ -n "$TMUX_LAYOUT" && -x "$layout_script" ]]; then
            "$layout_script" "$session_name" "$repo_path"
        fi

        # Switch to or attach the session
        if [[ -n "$TMUX" ]]; then
            tmux switch-client -t "$session_name"
        else
            tmux attach-session -t "$session_name"
        fi
    fi
}

# Guide user through dependency installation
install_deps() {
    echo "repos - Dependency Installation Guide"
    echo "===================================="
    echo

    # Check current status
    local missing_required=()
    local missing_optional=()

    # Check required dependencies
    for cmd in git fzf tmux jq; do
        if ! command -v "$cmd" &>/dev/null; then
            missing_required+=("$cmd")
        else
            print_success "$cmd is installed"
        fi
    done

    # Check optional dependencies
    if ! command -v gum &>/dev/null; then
        missing_optional+=("gum")
    else
        print_success "gum is installed (optional - enhanced UX for confirmations)"
    fi

    if ! command -v gh &>/dev/null; then
        missing_optional+=("gh")
    else
        print_success "gh is installed (optional - wildcard repo cloning)"
        # Check if authenticated
        if ! gh auth status &>/dev/null; then
            print_warning "GitHub CLI is not authenticated"
            echo "  Run: gh auth login"
        else
            print_success "GitHub CLI is authenticated"
        fi
    fi

    echo

    # Installation instructions for missing dependencies
    if [[ ${#missing_required[@]} -gt 0 ]]; then
        echo "Required dependencies to install:"
        for dep in "${missing_required[@]}"; do
            print_error "$dep is missing"
        done
        echo

        # OS-specific installation instructions
        case "$(uname)" in
        Darwin)
            echo "macOS installation (using Homebrew):"
            echo "  brew install git fzf tmux jq"
            ;;
        Linux)
            # Detect Linux distribution
            if command -v apt &>/dev/null; then
                echo "Ubuntu/Debian installation:"
                echo "  sudo apt update && sudo apt install git fzf tmux jq"
            elif command -v yum &>/dev/null; then
                echo "CentOS/RHEL installation:"
                echo "  sudo yum install git fzf tmux jq"
            elif command -v pacman &>/dev/null; then
                echo "Arch Linux installation:"
                echo "  sudo pacman -S git fzf tmux jq"
            else
                echo "Linux installation (check your package manager):"
                echo "  Install: git fzf tmux jq"
            fi
            ;;
        *)
            echo "Please install the missing dependencies using your system's package manager"
            ;;
        esac
        echo
    fi

    if [[ ${#missing_optional[@]} -gt 0 ]]; then
        echo "Optional dependencies for enhanced experience:"
        for dep in "${missing_optional[@]}"; do
            print_warning "$dep is not installed (optional)"
        done
        echo

        # Installation instructions for optional deps
        case "$(uname)" in
        Darwin)
            echo "macOS installation (using Homebrew):"
            [[ " ${missing_optional[*]} " =~ " gum " ]] && echo "  brew install gum"
            [[ " ${missing_optional[*]} " =~ " gh " ]] && echo "  brew install gh"
            ;;
        Linux)
            if command -v apt &>/dev/null; then
                echo "Ubuntu/Debian installation:"
                [[ " ${missing_optional[*]} " =~ " gum " ]] && echo "  # gum: https://github.com/charmbracelet/gum#installation"
                [[ " ${missing_optional[*]} " =~ " gh " ]] && echo "  sudo apt install gh"
            elif command -v pacman &>/dev/null; then
                echo "Arch Linux installation:"
                [[ " ${missing_optional[*]} " =~ " gum " ]] && echo "  sudo pacman -S gum"
                [[ " ${missing_optional[*]} " =~ " gh " ]] && echo "  sudo pacman -S github-cli"
            else
                echo "Linux installation:"
                [[ " ${missing_optional[*]} " =~ " gum " ]] && echo "  gum: https://github.com/charmbracelet/gum#installation"
                [[ " ${missing_optional[*]} " =~ " gh " ]] && echo "  gh: https://cli.github.com/"
            fi
            ;;
        *)
            [[ " ${missing_optional[*]} " =~ " gum " ]] && echo "  gum: https://github.com/charmbracelet/gum#installation"
            [[ " ${missing_optional[*]} " =~ " gh " ]] && echo "  gh: https://cli.github.com/"
            ;;
        esac
        echo
    fi

    # GitHub CLI authentication note
    if command -v gh &>/dev/null && ! gh auth status &>/dev/null; then
        echo "ðŸ“‹ GitHub CLI Authentication:"
        echo "  After installing gh, authenticate with:"
        echo "  gh auth login"
        echo
        echo "  This is required for wildcard repository cloning (e.g., 'org/*' patterns)"
        echo
    fi

    # Summary
    if [[ ${#missing_required[@]} -eq 0 ]]; then
        print_success "All required dependencies are installed!"
        if [[ ${#missing_optional[@]} -eq 0 ]]; then
            print_success "All optional dependencies are also installed!"
            echo "You're ready to use all repos features! ðŸŽ‰"
        else
            echo "You can use repos now, with enhanced features available after installing optional dependencies."
        fi
    else
        echo "Install the required dependencies above, then run 'repos install' again to verify."
        exit 1
    fi
}

# Show git status for all repos, grouped by owner
status_repos() {
    local repos
    repos=$(list_repos)

    if [[ -z "$repos" ]]; then
        print_error "No repositories found"
        exit 1
    fi

    local clean_only=false
    if [[ "$1" == "--clean" ]]; then
        clean_only=true
    fi

    echo "Checking status of all repositories..."
    echo

    # Group repositories by owner using associative arrays
    declare -A owner_repos
    declare -A owner_dirty_repos
    declare -A owner_non_git_repos
    local total_repos=0
    local total_dirty_repos=0
    local total_non_git=0

    while IFS= read -r repo; do
        [[ -z "$repo" ]] && continue
        ((total_repos++))

        local owner="${repo%%/*}"
        local repo_path="$REPOS_BASE_PATH/$repo"

        # Check if it's a git repository
        if [[ ! -d "$repo_path/.git" ]]; then
            owner_non_git_repos["$owner"]+="$repo "
            ((total_non_git++))
            continue
        fi

        # Get git status
        local status_output
        status_output=$(cd "$repo_path" && git status --porcelain 2>/dev/null)

        if [[ -n "$status_output" ]]; then
            owner_dirty_repos["$owner"]+="$repo "
            ((total_dirty_repos++))
        else
            owner_repos["$owner"]+="$repo "
        fi
    done <<<"$repos"

    # Show results grouped by owner
    local has_any_issues=false

    for owner in $(printf '%s\n' "${!owner_dirty_repos[@]}" "${!owner_non_git_repos[@]}" | sort -u); do
        local dirty_repos="${owner_dirty_repos[$owner]}"
        local non_git_repos="${owner_non_git_repos[$owner]}"

        if [[ -n "$dirty_repos" || -n "$non_git_repos" ]]; then
            has_any_issues=true
            echo -e "${YELLOW}=== $owner ===${NC}"

            # Show non-git directories first
            if [[ -n "$non_git_repos" ]]; then
                for repo in $non_git_repos; do
                    print_warning "$repo is not a git repository"
                done
                echo
            fi

            # Show dirty repositories
            if [[ -n "$dirty_repos" ]]; then
                for repo in $dirty_repos; do
                    local repo_path="$REPOS_BASE_PATH/$repo"
                    echo -e "${YELLOW}$repo${NC}"
                    (cd "$repo_path" && git status --short)
                    echo
                done
            fi
        fi
    done

    # Show clean repositories if not --clean flag
    if [[ "$clean_only" == false ]]; then
        local has_clean=false
        for owner in $(printf '%s\n' "${!owner_repos[@]}" | sort); do
            local clean_repos="${owner_repos[$owner]}"
            if [[ -n "$clean_repos" ]]; then
                if [[ "$has_clean" == false ]]; then
                    echo -e "${GREEN}=== Clean Repositories ===${NC}"
                    has_clean=true
                fi
                echo -e "${GREEN}$owner:${NC} $(echo $clean_repos | wc -w | tr -d ' ') repositories"
            fi
        done
        [[ "$has_clean" == true ]] && echo
    fi

    # Summary
    echo -e "${YELLOW}=== Summary ===${NC}"
    echo "Total repositories: $total_repos"
    if [[ $total_dirty_repos -gt 0 ]]; then
        echo -e "${YELLOW}Repositories with changes: $total_dirty_repos${NC}"
    else
        print_success "All git repositories are clean"
    fi
    if [[ $total_non_git -gt 0 ]]; then
        print_warning "Non-git directories: $total_non_git"
        for owner in $(printf '%s\n' "${!owner_non_git_repos[@]}" | sort); do
            local non_git_repos_list="${owner_non_git_repos[$owner]}"
            for repo in $non_git_repos_list; do
                echo "  â€¢ $repo"
            done
        done
    fi

    # Suggest cleanup if there are dirty repos
    if [[ $total_dirty_repos -gt 0 ]]; then
        echo
        echo "ðŸ’¡ Run 'repos cleanup' to interactively clean up repositories"
    fi
}

# Find and open files across all repositories
find_files() {
    local repos
    repos=$(list_repos)

    if [[ -z "$repos" ]]; then
        print_error "No repositories found"
        exit 1
    fi

    # Check if EDITOR is set
    if [[ -z "$EDITOR" ]]; then
        print_warning "EDITOR environment variable not set, using 'vim' as default"
        local editor="vim"
    else
        local editor="$EDITOR"
    fi

    echo "Searching files across all repositories..."

    # Build list of all git-tracked files with repo prefix
    local temp_file
    temp_file=$(mktemp)

    while IFS= read -r repo; do
        [[ -z "$repo" ]] && continue

        local repo_path="$REPOS_BASE_PATH/$repo"

        # Check if it's a git repository
        if [[ ! -d "$repo_path/.git" ]]; then
            continue
        fi

        # Get all git-tracked files and prefix with repo name
        (cd "$repo_path" && git ls-files 2>/dev/null | sed "s|^|$repo/|") >>"$temp_file"
    done <<<"$repos"

    # Check if any files were found
    if [[ ! -s "$temp_file" ]]; then
        rm -f "$temp_file"
        print_error "No git-tracked files found in any repository"
        exit 1
    fi

    # Use styled fzf to select file with preview and syntax highlighting
    local preview_cmd
    if command -v bat &>/dev/null; then
        preview_cmd="bat --color=always --style=numbers --line-range=:50 $REPOS_BASE_PATH/{}"
    elif command -v highlight &>/dev/null; then
        preview_cmd="highlight -O ansi --force $REPOS_BASE_PATH/{} 2>/dev/null | head -50"
    else
        preview_cmd="head -50 $REPOS_BASE_PATH/{}"
    fi

    local selected_file
    selected_file=$(cat "$temp_file" | styled_fzf "Search files: " "$preview_cmd")

    rm -f "$temp_file"

    if [[ -z "$selected_file" ]]; then
        echo "No file selected"
        exit 0
    fi

    local full_path="$REPOS_BASE_PATH/$selected_file"

    if [[ ! -f "$full_path" ]]; then
        print_error "File not found: $full_path"
        exit 1
    fi

    echo "Opening $selected_file with $editor..."
    "$editor" "$full_path"
}

# Open the repos script for editing
config_repos() {
    # Check if EDITOR is set
    if [[ -z "$EDITOR" ]]; then
        print_warning "EDITOR environment variable not set, using 'vim' as default"
        local editor="vim"
    else
        local editor="$EDITOR"
    fi

    # Get the path to this script
    local script_path
    script_path=$(realpath "${BASH_SOURCE[0]}")

    echo "Opening repos configuration with $editor..."
    "$editor" "$script_path"
}

# Check if gh CLI is installed and authenticated
check_gh_cli() {
    if ! command -v gh &>/dev/null; then
        print_error "GitHub CLI (gh) is not installed"
        echo "Install it from: https://cli.github.com/"
        return 1
    fi

    if ! gh auth status &>/dev/null; then
        print_error "GitHub CLI is not authenticated"
        echo "Run: gh auth login"
        return 1
    fi

    return 0
}

# Get all repositories for an organization/user using GitHub CLI
get_github_repos() {
    local org_user="$1"

    # Check gh CLI before proceeding
    check_gh_cli || return 1

    # Use gh to list repos (it handles both users and orgs automatically)
    local repos

    if has_gum; then
        repos=$(gum spin --spinner dot --title "Fetching repositories for $org_user..." -- \
            gh repo list "$org_user" --limit 1000 --json name --jq '.[].name' 2>/dev/null)
    else
        echo "Fetching repositories for $org_user..."
        repos=$(gh repo list "$org_user" --limit 1000 --json name --jq '.[].name' 2>/dev/null)
    fi

    if [[ -z "$repos" ]]; then
        # Try as user if org failed
        repos=$(gh api "users/$org_user/repos?per_page=100" --jq '.[].name' 2>/dev/null)
    fi

    echo "$repos"
}

# Parallel clone helper function
parallel_clone() {
    local git_url="$1"
    local repo_path
    repo_path=$(parse_git_url "$git_url") || return 1

    local clone_path="$REPOS_BASE_PATH/$repo_path"

    if [[ -d "$clone_path" ]]; then
        echo "SKIP:$repo_path"
        return 0
    fi

    mkdir -p "$(dirname "$clone_path")" 2>/dev/null

    if git clone "$git_url" "$clone_path" >/dev/null 2>&1; then
        echo "OK:$repo_path"
        return 0
    else
        echo "FAIL:$repo_path"
        return 1
    fi
}

export -f parallel_clone parse_git_url print_success print_error
export REPOS_BASE_PATH

# Setup repositories from config file
setup_repos() {
    local parallel_jobs="$DEFAULT_PARALLEL_JOBS"

    # Load repos from config
    if [[ ! -f "$CONFIG_FILE" ]]; then
        print_error "Config file not found: $CONFIG_FILE"
        echo "Run 'repos init' to create a default config file."
        exit 1
    fi

    local ensure_cloned=()
    while IFS= read -r line; do
        [[ -n "$line" ]] && ensure_cloned+=("$line")
    done < <(get_ensure_cloned)

    if [[ ${#ensure_cloned[@]} -eq 0 ]]; then
        print_error "No repositories defined in config file"
        echo "Edit $CONFIG_FILE and add repositories to ensure_cloned array."
        exit 1
    fi

    # Track postClone commands by URL
    declare -A post_clone_cmds

    # Check if any wildcard patterns exist that would need gh CLI
    local has_wildcards=false
    for entry in "${ensure_cloned[@]}"; do
        local url
        url=$(get_entry_url "$entry")
        if [[ "$url" == *"/*" ]]; then
            has_wildcards=true
            break
        fi
    done

    if [[ "$has_wildcards" == true ]]; then
        check_gh_cli || exit 1
    fi

    local clone_urls=()

    # First, expand all patterns to get actual URLs
    for entry in "${ensure_cloned[@]}"; do
        # Skip comments and empty lines
        [[ "$entry" =~ ^[[:space:]]*# ]] && continue
        [[ -z "$entry" ]] && continue

        # Extract URL from entry (handles both string and object formats)
        local repo_url
        repo_url=$(get_entry_url "$entry")
        [[ -z "$repo_url" ]] && continue

        # Store postClone command if present
        local post_clone
        post_clone=$(get_entry_post_clone "$entry")
        if [[ -n "$post_clone" ]]; then
            post_clone_cmds["$repo_url"]="$post_clone"
        fi

        # Check if it's a wildcard pattern
        if [[ "$repo_url" == *"/*" ]]; then
            # Extract organization/user from wildcard pattern
            local base_url="${repo_url%/*}"
            local org_user

            if [[ "$base_url" =~ git@.*:(.+)$ ]]; then
                org_user="${BASH_REMATCH[1]}"
            elif [[ "$base_url" =~ https?://.*github\.com/(.+)$ ]]; then
                org_user="${BASH_REMATCH[1]}"
            else
                print_error "Invalid wildcard pattern: $repo_url"
                continue
            fi

            local repos
            if ! repos=$(get_github_repos "$org_user"); then
                continue
            fi

            if [[ -z "$repos" ]]; then
                print_error "No repositories found for $org_user"
                continue
            fi

            # Add each repository URL
            while IFS= read -r repo_name; do
                [[ -z "$repo_name" ]] && continue
                clone_urls+=("${base_url}/${repo_name}.git")
            done <<<"$repos"
        else
            # Single repository
            clone_urls+=("$repo_url")
        fi
    done

    if [[ ${#clone_urls[@]} -eq 0 ]]; then
        print_error "No repositories to clone"
        exit 1
    fi

    echo "Found ${#clone_urls[@]} repositories to process"
    echo "Using $parallel_jobs parallel jobs"
    echo

    # Use parallel cloning
    local results
    if has_gum; then
        results=$(gum spin --spinner dot --title "Cloning repositories..." -- \
            bash -c 'printf "%s\n" '"$(printf '"%s" ' "${clone_urls[@]}")"' | xargs -P '"$parallel_jobs"' -I {} bash -c "parallel_clone \"{}\""')
    else
        echo "Cloning repositories (this may take a while)..."
        results=$(printf '%s\n' "${clone_urls[@]}" |
            xargs -P "$parallel_jobs" -I {} bash -c 'parallel_clone "{}"')
    fi

    # Process results
    local cloned=0
    local skipped=0
    local failed=0

    while IFS= read -r result; do
        [[ -z "$result" ]] && continue

        case "$result" in
        OK:*)
            ((cloned++))
            print_success "Cloned ${result#OK:}"
            ;;
        SKIP:*)
            ((skipped++))
            echo "Skipped ${result#SKIP:} (already exists)"
            ;;
        FAIL:*)
            ((failed++))
            print_error "Failed ${result#FAIL:}"
            ;;
        esac
    done <<<"$results"

    local total=$((cloned + skipped + failed))

    echo
    print_success "Setup complete: $total repositories processed"
    echo "  Cloned: $cloned"
    echo "  Skipped: $skipped"
    echo "  Failed: $failed"

    # Run postClone commands for repos that have them
    if [[ ${#post_clone_cmds[@]} -gt 0 ]]; then
        echo
        echo "Running postClone commands..."
        for repo_url in "${!post_clone_cmds[@]}"; do
            local post_clone_cmd="${post_clone_cmds[$repo_url]}"
            local repo_path
            repo_path=$(parse_git_url "$repo_url")
            repo_path="$REPOS_BASE_PATH/$repo_path"

            if [[ -d "$repo_path" ]]; then
                echo
                echo "â†’ Running postClone for $(basename "$repo_path"): $post_clone_cmd"
                if (cd "$repo_path" && eval "$post_clone_cmd"); then
                    print_success "postClone completed for $(basename "$repo_path")"
                else
                    print_error "postClone failed for $(basename "$repo_path")"
                fi
            fi
        done
    fi
}

# Interactive cleanup workflow using lazygit for repositories with changes
cleanup_repos() {
    # Check if lazygit is available
    if ! command -v lazygit &>/dev/null; then
        print_error "lazygit is not installed"
        echo "Install it from: https://github.com/jesseduffield/lazygit"
        case "$(uname)" in
        Darwin)
            echo "  brew install lazygit"
            ;;
        Linux)
            if command -v pacman &>/dev/null; then
                echo "  sudo pacman -S lazygit"
            elif command -v apt &>/dev/null; then
                echo "  # Follow installation guide at https://github.com/jesseduffield/lazygit"
            fi
            ;;
        esac
        exit 1
    fi

    local repos
    repos=$(list_repos)

    if [[ -z "$repos" ]]; then
        print_error "No repositories found"
        exit 1
    fi

    echo "Building cleanup queue..."

    # Build queue of dirty repositories and non-git directories
    local dirty_repos=()
    local non_git_repos=()
    while IFS= read -r repo; do
        [[ -z "$repo" ]] && continue

        local repo_path="$REPOS_BASE_PATH/$repo"

        # Check if it's a git repository
        if [[ ! -d "$repo_path/.git" ]]; then
            non_git_repos+=("$repo")
            continue
        fi

        # Get git status
        local status_output
        status_output=$(cd "$repo_path" && git status --porcelain 2>/dev/null)

        if [[ -n "$status_output" ]]; then
            dirty_repos+=("$repo")
        fi
    done <<<"$repos"

    # Check if there's anything to clean up
    if [[ ${#dirty_repos[@]} -eq 0 && ${#non_git_repos[@]} -eq 0 ]]; then
        print_success "All repositories are clean! Nothing to cleanup."
        return 0
    fi

    local total_items=$((${#dirty_repos[@]} + ${#non_git_repos[@]}))
    echo "Found ${#dirty_repos[@]} repositories with changes"
    if [[ ${#non_git_repos[@]} -gt 0 ]]; then
        echo "Found ${#non_git_repos[@]} non-git directories"
    fi
    echo

    # Process non-git directories first
    local current=1
    for repo in "${non_git_repos[@]}"; do
        local repo_path="$REPOS_BASE_PATH/$repo"
        local repo_name="${repo#*/}"

        echo -e "${YELLOW}Non-git directory: $repo${NC}"

        local actions=(
            "Initialize as Git|Run git init and make initial commit"
            "Remove Directory|Delete the entire directory"
            "Skip|Leave as-is and continue"
        )

        local selected_action
        selected_action=$(printf '%s\n' "${actions[@]}" | cut -d'|' -f1 | styled_fzf "Action for $repo_name: ")

        case "$selected_action" in
        "Initialize as Git")
            if (cd "$repo_path" && git init && git add -A && git commit -m "Initial commit"); then
                print_success "$repo_name: initialized as git repository"
            else
                print_error "$repo_name: git initialization failed"
            fi
            ;;
        "Remove Directory")
            if confirm_action "Really delete $repo_name directory?"; then
                if rm -rf "$repo_path"; then
                    print_success "$repo_name: directory removed"
                else
                    print_error "$repo_name: removal failed"
                fi
            fi
            ;;
        "Skip")
            echo "Skipping $repo_name"
            ;;
        esac

        # Show progress and prompt to continue
        echo
        echo "Progress: $current/$total_items items processed"

        # If this is the last item, don't prompt
        if [[ $current -eq $total_items ]]; then
            break
        fi

        # Use gum confirm if available, otherwise fallback
        if has_gum; then
            if ! gum confirm "Continue to next item?"; then
                echo "Cleanup stopped"
                break
            fi
        else
            echo -n "Continue to next item? (y/N) "
            read -r continue_input
            if [[ "$continue_input" != "y" && "$continue_input" != "Y" ]]; then
                echo "Cleanup stopped"
                break
            fi
        fi

        ((current++))
        echo
    done

    # Process each dirty repository with lazygit
    for repo in "${dirty_repos[@]}"; do
        local repo_path="$REPOS_BASE_PATH/$repo"

        echo -e "${YELLOW}Opening lazygit for: $repo${NC}"

        # Change to repository directory and run lazygit
        (cd "$repo_path" && lazygit)

        # Show progress and prompt to continue
        echo
        echo "Progress: $current/$total_items items processed"

        # If this is the last item, don't prompt
        if [[ $current -eq $total_items ]]; then
            break
        fi

        # Use gum confirm if available, otherwise fallback
        if has_gum; then
            if ! gum confirm "Continue to next repository?"; then
                echo "Cleanup stopped"
                break
            fi
        else
            echo -n "Continue to next repository? (y/N) "
            read -r continue_input
            if [[ "$continue_input" != "y" && "$continue_input" != "Y" ]]; then
                echo "Cleanup stopped"
                break
            fi
        fi

        ((current++))
        echo
    done

    print_success "Cleanup completed!"
}

# Show help
show_help() {
    # Check which tools are installed
    local git_s fzf_s tmux_s jq_s gum_s gh_s
    command -v git &>/dev/null && git_s="âœ“" || git_s="âœ—"
    command -v fzf &>/dev/null && fzf_s="âœ“" || fzf_s="âœ—"
    command -v tmux &>/dev/null && tmux_s="âœ“" || tmux_s="âœ—"
    command -v jq &>/dev/null && jq_s="âœ“" || jq_s="âœ—"
    command -v gum &>/dev/null && gum_s="âœ“" || gum_s="â—¦"
    command -v gh &>/dev/null && gh_s="âœ“" || gh_s="â—¦"

    printf ' â•­â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â•®
 â”‚                                        â”‚
 â”‚  repos - Minimal repository manager    â”‚
 â”‚                                        â”‚
 â•°â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â•¯

\033[1;34mUsage: repos <command> [options]\033[0m

\033[1;34mCommands:\033[0m
  \033[32minit\033[0m         - Create default config file
  \033[32minstall\033[0m      - Guide through dependency installation
  \033[32madd\033[0m          - Clone a repository [git-url] (interactive if no URL)
  \033[32mremove\033[0m       - Remove a repository (interactive)
  \033[32mopen\033[0m         - Open a repository in tmux [repo-path]
  \033[32mfind\033[0m         - Find and open files across all repositories
  \033[32mconfig\033[0m       - Edit the repos script configuration
  \033[32mstatus\033[0m       - Show git status for all repositories [\033[33m--clean\033[0m]
  \033[32mcleanup\033[0m      - Interactive cleanup workflow for dirty repositories
  \033[32msetup\033[0m        - Clone all repositories from config
  \033[32mhelp\033[0m         - Show this help message

\033[1;34mCurrent Configuration:\033[0m
  Config file: \033[36m%s\033[0m
  Repository base path: \033[36m%s\033[0m

\033[1;34mExamples:\033[0m
  repos init                                       # Create config file
  repos install                                    # Check dependencies
  repos add                                        # Interactive repo selection
  repos add git@github.com:username/repo.git       # Clone a repository
  repos open nikbrunner/dots                       # Open specific repo directly
  repos setup                                      # Clone all repos from config
  repos status --clean                             # Show only dirty repositories

\033[1;34mConfig File (ensure_cloned):\033[0m
  Add repositories to ensure_cloned array in config file:
  - Simple: "git@github.com:username/repo.git"
  - With postClone: {"url": "git@github.com:user/repo", "postClone": "./install.sh"}
  - Wildcard: "git@github.com:organization/*"

\033[1;34mRequirements:\033[0m
  %s git, %s fzf, %s tmux, %s jq (required)
  %s gum (optional, for enhanced confirmations)
  %s GitHub CLI (gh) for wildcard patterns
    Install: https://cli.github.com/
    Authenticate: gh auth login
' "$CONFIG_FILE" "$REPOS_BASE_PATH" "$git_s" "$fzf_s" "$tmux_s" "$jq_s" "$gum_s" "$gh_s"
}

# Initialize - check dependencies
check_dependencies

# Main command handler
case "${1:-}" in
init)
    init_config
    ;;
install)
    install_deps
    ;;
add)
    add_repo "$2"
    ;;
remove)
    remove_repo
    ;;
open)
    open_repo "$2"
    ;;
find)
    find_files
    ;;
config)
    config_repos
    ;;
status)
    status_repos "$2"
    ;;
cleanup)
    cleanup_repos
    ;;
setup)
    setup_repos
    ;;
help | --help | -h)
    show_help
    ;;
*)
    if [[ -n "$1" ]]; then
        print_error "Unknown command: $1"
    fi
    show_help
    exit 1
    ;;
esac
